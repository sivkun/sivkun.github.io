<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sivkun</title>
  
  <subtitle>follow your heart</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fsysfq.top/"/>
  <updated>2018-07-06T06:47:16.000Z</updated>
  <id>http://fsysfq.top/</id>
  
  <author>
    <name>石富全</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://fsysfq.top/2018/07/06/hello-world/"/>
    <id>http://fsysfq.top/2018/07/06/hello-world/</id>
    <published>2018-07-06T06:47:16.000Z</published>
    <updated>2018-07-06T06:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new   post"></a>Create a new   post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>transform</title>
    <link href="http://fsysfq.top/2017/07/24/transform/"/>
    <id>http://fsysfq.top/2017/07/24/transform/</id>
    <published>2017-07-24T03:12:15.000Z</published>
    <updated>2018-07-07T13:18:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>相关链接：</p><blockquote><p><a href="http://www.cnblogs.com/xiaohuochai/p/5350254.html#anchor2" target="_blank" rel="noopener">http://www.cnblogs.com/xiaohuochai/p/5350254.html#anchor2</a><br><a href="http://www.cnblogs.com/xiaohuochai/p/5351477.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaohuochai/p/5351477.html</a><br>透视原理与实现 <a href="http://blog.csdn.net/goncely/article/details/5397729" target="_blank" rel="noopener">http://blog.csdn.net/goncely/article/details/5397729</a><br><a href="http://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/</a></p></blockquote><p>在实现carousel效果的时候，用到了transform:translate属性，哎，以前看过的都忘了，只有再重新拾起来，这里做个备忘。上面4个链接可以帮助理解。尤其是张鑫旭大神的，如果对透视不太理解，然后再结合透视原理那篇文章。<br>下面是用到的关键css属性：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">perspective</span>:<span class="number">500px</span>; <span class="comment">/*视距，视角*/</span></span><br><span class="line">  <span class="attribute">perspective-origin</span>:center;<span class="comment">/*视点*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">  <span class="attribute">transform-origin</span>:<span class="number">50%</span> <span class="number">50%</span>;<span class="comment">/*变换中心*/</span></span><br><span class="line">  <span class="comment">/*transform-style 属性规定如何在 3D 空间中呈现被嵌套的元素。值：flat|preserve-3d,flat元素会被拍扁不会呈现3d效果，而preserve-3d可以呈现3d效果*/</span></span><br><span class="line">  <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(50deg) <span class="comment">/*旋转，绕Y轴旋转50°*/</span></span><br><span class="line">    <span class="built_in">scale</span>(0.45)  <span class="comment">/*缩放，为原来的0.45倍*/</span></span><br><span class="line">    <span class="built_in">skewX</span>(10deg) <span class="comment">/*倾斜，在X轴倾斜，表示原来垂直X轴的变发生倾斜*/</span></span><br><span class="line">    <span class="built_in">translate3d</span>(10px,10px,-10px);<span class="comment">/*平移，在空间中发生移动*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相关链接：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/5350254.html#anchor2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.c
      
    
    </summary>
    
      <category term="css" scheme="http://fsysfq.top/categories/css/"/>
    
    
      <category term="css3" scheme="http://fsysfq.top/tags/css3/"/>
    
      <category term="transform" scheme="http://fsysfq.top/tags/transform/"/>
    
      <category term="3d" scheme="http://fsysfq.top/tags/3d/"/>
    
  </entry>
  
  <entry>
    <title>webpack caching</title>
    <link href="http://fsysfq.top/2017/07/24/webpack-caching/"/>
    <id>http://fsysfq.top/2017/07/24/webpack-caching/</id>
    <published>2017-07-24T02:36:31.000Z</published>
    <updated>2018-07-07T13:18:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考 <a href="https://webpack.js.org/guides/caching/" target="_blank" rel="noopener">https://webpack.js.org/guides/caching/</a></p></blockquote><p>使用webpack打包好久了，但是对具体的配置的含义，有的还是不明白，其中一个就是webpack caching。<br>webpack caching主要目的是，使浏览器缓存公共文件，不必每次都从服务器请求新的bundle文件。<br>下面是基本的配置。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.prod.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  context: path.resolve(__dirname, <span class="string">".."</span>),<span class="comment">//我把配置文件放在了config文件夹下</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: [<span class="string">'./src/index.js'</span>],</span><br><span class="line">    vendor: [</span><br><span class="line">      <span class="string">'react'</span>,</span><br><span class="line">      <span class="string">'react-dom'</span>,</span><br><span class="line">      <span class="string">'redux'</span>,</span><br><span class="line">      <span class="string">'react-router'</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">    filename: <span class="string">"[name].[chunkhash:8].js"</span>,</span><br><span class="line">    chunkFilename: <span class="string">"[name].[chunkhash:8].js"</span>,</span><br><span class="line">    publicPath: <span class="string">'/'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [[<span class="string">'env'</span>, &#123; <span class="attr">modules</span>: <span class="literal">false</span> &#125;], <span class="string">'react'</span>],</span><br><span class="line">          plugins: [<span class="string">'transform-runtime'</span>],</span><br><span class="line">          cacheDirectory: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: [<span class="string">"vendor"</span>,<span class="string">"manifest"</span>],</span><br><span class="line">      filename: <span class="string">'[name].[chunkhash:8].js'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      template: <span class="string">'index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来对上面配置做个具体分析。<br>对于有多个入口的打包，如果不提取公共文件，打包后的文件是不相相互影响的。但是提取公共文件后，公共文件包含公共manifest，这样打包后的文件就是相互影响的了。<br>输出文件文件名配置有[hash]和[chunkhash]，他们的区别是如下</p><ul><li>[hash]这种方式，所有的文件hash后缀,都会相同，因此每次打包只要有一个文件改变所有的文件名都会改变。但是只有文件内容改变的文件，打包后的文件内容才会改变。</li><li>[chunkhash]这种方式会为每个文件单独起一个文件名，文件hash根据每一个文件的内容的hash值确定。因此文件内容不改变，文件名不变。如果不提取公共文件，没有改变的bundle，依旧可以被浏览器缓存。</li></ul><p>如果将公共代码提取出来，那么公共文件vendor中包含manifest (along with bootstrapping/runtime code) ，在每次应用代码文件修改的时候，文件的hash都会改变，在公共文件的bootstrapping中含有文件的哈希值，因此每次文件改变，公共文件内容也会改变，这就使得公共文件的意义不大了。因此需要把manifest单独提取出来。（ps:可以自己看一下manifest文件的内容，可以比对两次打包manifest内容的变化）。</p><p>这里没有使用webpack官网的配置方式，因为没有必要，manifest文件不太大，每次文件改变都对manifest文件重新发出请求的开销还是可以接受的。<br>上面的配置文件中使用了，<code>HtmlWebpackPlugin</code>插件，每次打包会在index.html中自动插入打包后的文件链接。就算多次打包文件名发生改变，也不用手动更改引用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;参考 &lt;a href=&quot;https://webpack.js.org/guides/caching/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://webpack.js.org/guides/caching/&lt;/a
      
    
    </summary>
    
      <category term="打包" scheme="http://fsysfq.top/categories/%E6%89%93%E5%8C%85/"/>
    
    
      <category term="webpack" scheme="http://fsysfq.top/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>regExp-and-example</title>
    <link href="http://fsysfq.top/2017/07/09/regExp-and-example/"/>
    <id>http://fsysfq.top/2017/07/09/regExp-and-example/</id>
    <published>2017-07-09T08:21:19.000Z</published>
    <updated>2018-07-07T13:18:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周复习巩固了正则表达式要点，做个总结！</p><h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p>看到别人处理css选择器的时候，使用到了正则表达式，涉及到分组捕获等知识，还有实现数字每三位逗号分隔这种形式，使用正则表达式实现，想破头皮弄不出来，只好重新学习正则表达式。</p><h1 id="易忘难点"><a href="#易忘难点" class="headerlink" title="易忘难点"></a>易忘难点</h1><ol><li>在操作符后面加一个问号?字符（?操作符的一个重载），如<code>/a+?/</code>:让表达式变成非贪婪的，进行最小限度的匹配。</li><li><code>分组捕获</code>：正则表达式有一部分用括号进行分组时，它具有双重责任，同时也创建所谓的捕获。<code>/(ab)+/</code>匹配一个或多个连续出现的子字符串‘ab’</li><li><code>或操作符</code>：可以用(<code>|</code>)字符表示或者的关系。<code>/(ab)+|(cd)+/</code>匹配出现一次或多次的”ab”或”cd”。</li><li><code>反向引用</code>：捕获的反向引用。如：<code>/^([dtn]a\1)/</code>：可以匹配任意一个以”d””t””n”开头，且后面紧跟着一个a字符，并且后面跟着和第一个捕获相同字符的字符串。<code>\1</code>匹配的字符需要在匹配的时候才能确定。</li><li>在匹配xml类型标记元素的时候可能会很有用，如：<code>/&lt;(\w+)&gt;(.+)&lt;\/\1&gt;/</code>可以匹配<code>&lt;strong&gt;something&lt;/strong&gt;</code>这样的简单元素。如果不使用反向引用是无法做到的，因为我们无法知道闭合标签和开始标签是否匹配。</li><li><code>\b</code> : 匹配单词边界,就是位于字符\w（[a-zA-Z0-9_]）和\W[^a-zA-Z0-9_]之间的位置，或者位于字符\w和字符串的开头或者结束之间的位置。</li><li><code>\B</code>: 匹配非单词边界</li><li><code>exp1(?=exp2)</code>:正向前瞻（零宽正向先行断言）,要匹配的exp1要满足后面是exp2</li><li><code>exp1(?!exp2)</code>:负向前瞻（零宽负向先行断言），要匹配的exp1要满足后面是不是exp2</li><li><code>(?:exp)</code>:正则表达式中小括号具有分组和捕获双重作用，如果在小阔号里面开始加上<code>?:</code>则可以使其不被捕获。<a id="more"></a><h1 id="用于正则表达式的方法"><a href="#用于正则表达式的方法" class="headerlink" title="用于正则表达式的方法"></a>用于正则表达式的方法</h1>有2个是正则对象的方法，有4个字符串对象的方法</li><li><code>RegExp.prototype.test()</code></li><li><code>RegExp.prototype.exec()</code></li><li><code>String.prototype.match()</code></li><li><code>String.prototype.search()</code></li><li><code>String.prototype.replace()</code></li><li><code>String.prototype.split()</code><br>下面分别介绍</li></ol><h2 id="RegExp-prototype-test"><a href="#RegExp-prototype-test" class="headerlink" title="RegExp.prototype.test()"></a><code>RegExp.prototype.test()</code></h2><p>检测正则表达式和指定的字符串是否匹配，返回true或false。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testinput</span>(<span class="params">re, str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> midstring;</span><br><span class="line">    <span class="keyword">if</span> (re.test(str)) &#123;</span><br><span class="line">        midstring = <span class="string">" contains "</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        midstring = <span class="string">" does not contain "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(str + midstring + re.source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/c/g</span></span><br><span class="line">reg.test(<span class="string">'ccc'</span>);<span class="comment">//true</span></span><br><span class="line">reg.test(<span class="string">'ccc'</span>);<span class="comment">//true</span></span><br><span class="line">reg.test(<span class="string">'ccc'</span>);<span class="comment">//true</span></span><br><span class="line">reg.test(<span class="string">'ccc'</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>如果regexp是全局匹配，<code>test</code>可执行多次，可以手动记录匹配的次数。</p><h2 id="String-prototypr-search-regexp"><a href="#String-prototypr-search-regexp" class="headerlink" title="String.prototypr.search(regexp)"></a><code>String.prototypr.search(regexp)</code></h2><p>执行正则表达式和string对象之间的一个搜索匹配，返回首次匹配索引，否则返回-1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testinput</span>(<span class="params">re, str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> midstring;</span><br><span class="line">  <span class="keyword">if</span> (str.search(re) != <span class="number">-1</span>)&#123;</span><br><span class="line">    midstring = <span class="string">" contains "</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    midstring = <span class="string">" does not contain "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log (str + midstring + re);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String-prototype-match-regexp"><a href="#String-prototype-match-regexp" class="headerlink" title="String.prototype.match(regexp)"></a><code>String.prototype.match(regexp)</code></h2><p>如果正则表达式没有 <code>g</code> 标志，则 <code>str.match()</code> 会返回和 <code>RegExp.exec()</code> 相同的结果。而且返回的 Array 拥有一个额外的 <code>input</code> 属性，该属性包含被解析的原始字符串。另外，还拥有一个 <code>index</code> 属性，该属性表示匹配结果在原字符串中的索引（以0开始）。</p><p>如果正则表达式包含 <code>g</code> 标志，则该方法返回一个 Array ，它包含所有匹配的子字符串而不是匹配对象。捕获组不会被返回(即不返回<code>index</code>属性和<code>input</code>属性)。如果没有匹配到，则返回  <code>null</code> 。</p><p>参看：RegExp 方法</p><ul><li>如果你需要知道一个字符串是否匹配一个正则表达式 <code>RegExp</code> ，可使用 <code>search()</code> 。</li><li>如果你只是需要第一个匹配结果，你可能想要使用 <code>RegExp.exec()</code> 。</li><li>如果你想要获得捕获组，并且设置了全局标志，你需要用 <code>RegExp.exec()</code> 。</li></ul><h2 id="RegExp-prototype-exec-str"><a href="#RegExp-prototype-exec-str" class="headerlink" title="RegExp.prototype.exec(str)"></a><code>RegExp.prototype.exec(str)</code></h2><p>当正则表达式使用 “g” 标志时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配。当你这样做时，查找将从正则表达式的  lastIndex 属性指定的位置开始。（test() 也会更新 lastIndex 属性）。例如，你使用下面的脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myRe = <span class="regexp">/ab*/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abbcdefabh'</span>;</span><br><span class="line"><span class="keyword">var</span> myArray;</span><br><span class="line"><span class="keyword">while</span> ((myArray = myRe.exec(str)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">'Found '</span> + myArray[<span class="number">0</span>] + <span class="string">'. '</span>;</span><br><span class="line">  msg += <span class="string">'Next match starts at '</span> + myRe.lastIndex;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a><code>String.prototype.replace()</code></h2><p><code>str.replace(regexp|substr,newSubStr|function)</code>  </p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">"fontFamily"</span>.replace(<span class="regexp">/([A-Z])/g</span>,<span class="string">'-$1'</span>).toLowerCase()<span class="comment">//"font-family"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match, p1, p2, p3, offset, string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// p1 is nondigits, p2 digits, and p3 non-alphanumerics</span></span><br><span class="line">  <span class="keyword">return</span> [p1, p2, p3].join(<span class="string">' - '</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newString = <span class="string">'abc12345#$*%'</span>.replace(<span class="regexp">/([^\d]*)(\d*)([^\w]*)/</span>, replacer);</span><br><span class="line"><span class="comment">//'abc - 12345 - #$*%'</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="String-prototype-split"><a href="#String-prototype-split" class="headerlink" title="String.prototype.split()"></a><code>String.prototype.split()</code></h2><p><code>str.split(separator[,limit])</code><br>参数<br><code>separator</code><br>指定用来分割字符串的字符（串）。<code>separator</code> 可以是一个字符串或正则表达式。 如果忽略 <code>separator</code>，则返回整个字符串的数组形式。如果 <code>separator</code> 是一个空字符串，则 <code>str</code> 将会把原字符串中每个字符的数组形式返回。<br><code>limit</code><br>一个整数，限定返回的分割片段数量。<code>split</code> 方法仍然分割每一个匹配的 <code>separato</code>r，但是返回的数组只会截取最多 <code>limit</code> 个元素。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myString = <span class="string">"Hello 1 word. Sentence number 2."</span>;</span><br><span class="line"><span class="keyword">var</span> splits = myString.split(<span class="regexp">/(\d)/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(splits);</span><br><span class="line"><span class="comment">//[Hello ,1, word. Sentence number ,2,.]</span></span><br></pre></td></tr></table></figure></p><h2 id="没有捕获的分组"><a href="#没有捕获的分组" class="headerlink" title="没有捕获的分组(?:)"></a>没有捕获的分组(?:)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/((?:ninja-)+)sword/</span>;</span><br><span class="line"><span class="keyword">var</span> ninjas = <span class="string">"ninja-ninja-ninja-sword"</span>.match(pattern);</span><br></pre></td></tr></table></figure><h1 id="正则常见解决方案"><a href="#正则常见解决方案" class="headerlink" title="正则常见解决方案"></a>正则常见解决方案</h1><h2 id="修剪字符串"><a href="#修剪字符串" class="headerlink" title="修剪字符串"></a>修剪字符串</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (str||<span class="string">''</span>).replace(<span class="regexp">/^\s+|\s+$/g</span>,<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配换行符"><a href="#匹配换行符" class="headerlink" title="匹配换行符"></a>匹配换行符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">"&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world&lt;/i&gt;"</span>;</span><br><span class="line">/.*<span class="regexp">/.exec(html)[0]==='&lt;b&gt;Hello&lt;/</span>b&gt;<span class="string">'</span></span><br><span class="line"><span class="string">/[\s\S]*/.exec(html)[0]==="&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world&lt;/i&gt;"</span></span><br><span class="line"><span class="string">/(?:.|\s)*/.exec(html)[0]==='</span>&lt;b&gt;Hello&lt;<span class="regexp">/b&gt;\n&lt;i&gt;world&lt;/i</span>&gt;<span class="string">'</span></span><br></pre></td></tr></table></figure><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"\u5FCD\u8005\u30D1\u30EF\u30FC"</span>;</span><br><span class="line"><span class="keyword">var</span> matchAll = <span class="regexp">/[\w\u0080-\uFFFF_-]+/</span>;</span><br><span class="line">text.match(matchAll)</span><br></pre></td></tr></table></figure><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/^((\w+)|(\\.))+$/</span>;</span><br><span class="line"><span class="keyword">var</span> tests = [</span><br><span class="line">  <span class="string">"formUpdate"</span>,</span><br><span class="line">  <span class="string">"form\\.update\\.whatever"</span>,</span><br><span class="line">  <span class="string">"form\\:update"</span>,</span><br><span class="line">  <span class="string">"\\f\\o\\r\\m\\up\\d\\a\\t\\e"</span>,</span><br><span class="line">  <span class="string">"form:update"</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> n = <span class="number">0</span>;n&lt;tests.length;n++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pattern.test(tests[n]))<span class="comment">//true true true true false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="牛逼例子"><a href="#牛逼例子" class="headerlink" title="牛逼例子"></a>牛逼例子</h1><h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><p>要求：</p><ol><li>至少6个字符</li><li>至少一个小写字母</li><li>至少一个大写字母</li><li>至少一个数字</li><li>只包含数字和字母</li></ol><p>方法一：<br>匹配多次，每个都满足。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params">password</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="regexp">/^[A-Za-z0-9]&#123;6,&#125;$/</span>.test(password) &amp;&amp;</span><br><span class="line">          /[A-Z]+<span class="regexp">/           .test(password) &amp;&amp;</span></span><br><span class="line"><span class="regexp">          /</span>[a-z]+<span class="regexp">/           .test(password) &amp;&amp;</span></span><br><span class="line"><span class="regexp">          /</span>[<span class="number">0</span><span class="number">-9</span>]+<span class="regexp">/           .test(password) ;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>方法二：</p><p>运用正向前瞻（零宽正向先行断言），出神入化、淋漓尽致！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params">password</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]&#123;6,&#125;$/</span>.test(password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是给出解释<br>/^(?=.<em>\d)(?=.</em>[a-z])(?=.<em>[A-Z])[a-zA-Z0-9]{6,}$/<br>  ^ assert position at start of the string<br>  (?=.</em>\d) Positive Lookahead - Assert that the regex below can be matched<br>    .<em> matches any character (except newline)<br>      Quantifier: Between zero and unlimited times, as many times as possible, giving back as needed [greedy]<br>    \d match a digit [0-9]<br>  (?=.</em>[a-z]) Positive Lookahead - Assert that the regex below can be matched<br>    .<em> matches any character (except newline)<br>      Quantifier: Between zero and unlimited times, as many times as possible, giving back as needed [greedy]<br>    [a-z] match a single character present in the list below<br>      a-z a single character in the range between a and z (case sensitive)<br>  (?=.</em>[A-Z]) Positive Lookahead - Assert that the regex below can be matched<br>    .<em> matches any character (except newline)<br>      Quantifier: Between zero and unlimited times, as many times as possible, giving back as needed [greedy]<br>    [A-Z] match a single character present in the list below<br>      A-Z a single character in the range between A and Z (case sensitive)<br>  [a-zA-Z0-9]{6,} match a single character present in the list below<br>    Quantifier: Between 6 and unlimited times, as many times as possible, giving back as needed [greedy]<br>    a-z a single character in the range between a and z (case sensitive)<br>    A-Z a single character in the range between A and Z (case sensitive)<br>    0-9 a single character in the range between 0 and 9<br>  $ assert position at end of the string<br>我的理解：<br>`/^(?=.</em>\d)(?=.<em>[a-z])(?=.</em>[A-Z])[a-zA-Z0-9]{6,}$/<code>表达式</code>(?=exp)`（正向前瞻或者零宽正向先行断言）只是表示一种期望，期望接下来必须要出现的内容，如果不出现则会匹配失败，不占字符位置。</p><ol><li><code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])</code>这么多表示，从字符串开头以后，期望接下来的字符中要出现至少一个数字，至少一个小写字母，至少一个大写字母，满足才能匹配。</li><li>其实可以把这些期望去掉理解剩下的部分<code>/^[a-zA-Z0-9]{6,}$/</code>，表示字符串中只能出现字母和数字，并且字符长度不能少于6，满足这样的字符串才能匹配。</li><li>现在把1和2的限制条件一综合，正是题目的要求。</li></ol><h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><p>实现indexOf和lastIndexOf<br>要求：<br>  第一个参数：可以是字符串或者正则表达式。<br>  第二个参数：源字符串的索引，表示开始匹配的位置。<br>  lastIndexOf是从开始匹配的位置从右向左匹配<br>  indexOf是从匹配开始的位置从左向右匹配<br>  返回结果： 正确匹配时，在源字符串中的索引。<br>            匹配失败时，返回-1<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.indexOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">arguments</span>[<span class="number">0</span>], b = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">0</span>,subStr = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span>( b != <span class="literal">undefined</span> ) &#123;</span><br><span class="line">    subStr = <span class="keyword">this</span>.slice(<span class="built_in">parseInt</span>(b));</span><br><span class="line">    result += b</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> index = subStr.search(a);</span><br><span class="line">  result = index === <span class="number">-1</span> ? <span class="number">-1</span> : result + index;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">String</span>.prototype.lastIndexOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">arguments</span>[<span class="number">0</span>], b = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">-1</span>;</span><br><span class="line">  (a <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &amp;&amp; (a=a.source);</span><br><span class="line">  a = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'(?:\\B|\\b)'</span>+<span class="string">'(?='</span>+a+<span class="string">')[\\s\\S]'</span>,<span class="string">'g'</span>);</span><br><span class="line">  b === <span class="literal">undefined</span> &amp;&amp; (b = <span class="keyword">this</span>.length);</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(arr = a.exec(<span class="keyword">this</span>))&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.index &lt;= b)</span><br><span class="line">      result = arr.index;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h2><p>实现数字每3位用逗号分隔<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">splitNum</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> (<span class="string">''</span>+n).replace(<span class="regexp">/\B(?=(?:\d&#123;3&#125;)+\b)/g</span>,<span class="string">','</span>);</span><br><span class="line">&#125;</span><br><span class="line">splitNum(<span class="number">1234567890</span>)<span class="comment">//"1,234,567,890"</span></span><br></pre></td></tr></table></figure></p><p><code>&#39;123456789&#39;.replace(/\B(?=(?:\d{3})+\b)/g, &#39;,&#39;)</code><br>执行过程：<br>replace函数会进行多次匹配，\b表示了要匹配到单词边界。</p><ol><li>首先从1和2中间开始但是后面有8个数字不满足前瞻性条件</li><li>然后到2和3中间，同样不满足</li><li>到3和4中间，满足后面有6个数字</li><li>把在3和4中间的\B(非单词边界)替换为”,”。</li><li>依次往下匹配替换</li><li>最终返回新的字符串”123,456,789”</li></ol><p>正则很强大，比常规的实现方法简洁方便很多。<br>也可以参考：<a href="http://www.cnblogs.com/sivkun/p/7123963.html" target="_blank" rel="noopener">http://www.cnblogs.com/sivkun/p/7123963.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周复习巩固了正则表达式要点，做个总结！&lt;/p&gt;
&lt;h1 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h1&gt;&lt;p&gt;看到别人处理css选择器的时候，使用到了正则表达式，涉及到分组捕获等知识，还有实现数字每三位逗号分隔这种形式，使用正则表达式实现，想破头皮弄不出来，只好重新学习正则表达式。&lt;/p&gt;
&lt;h1 id=&quot;易忘难点&quot;&gt;&lt;a href=&quot;#易忘难点&quot; class=&quot;headerlink&quot; title=&quot;易忘难点&quot;&gt;&lt;/a&gt;易忘难点&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在操作符后面加一个问号?字符（?操作符的一个重载），如&lt;code&gt;/a+?/&lt;/code&gt;:让表达式变成非贪婪的，进行最小限度的匹配。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;分组捕获&lt;/code&gt;：正则表达式有一部分用括号进行分组时，它具有双重责任，同时也创建所谓的捕获。&lt;code&gt;/(ab)+/&lt;/code&gt;匹配一个或多个连续出现的子字符串‘ab’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;或操作符&lt;/code&gt;：可以用(&lt;code&gt;|&lt;/code&gt;)字符表示或者的关系。&lt;code&gt;/(ab)+|(cd)+/&lt;/code&gt;匹配出现一次或多次的”ab”或”cd”。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;反向引用&lt;/code&gt;：捕获的反向引用。如：&lt;code&gt;/^([dtn]a\1)/&lt;/code&gt;：可以匹配任意一个以”d””t””n”开头，且后面紧跟着一个a字符，并且后面跟着和第一个捕获相同字符的字符串。&lt;code&gt;\1&lt;/code&gt;匹配的字符需要在匹配的时候才能确定。&lt;/li&gt;
&lt;li&gt;在匹配xml类型标记元素的时候可能会很有用，如：&lt;code&gt;/&amp;lt;(\w+)&amp;gt;(.+)&amp;lt;\/\1&amp;gt;/&lt;/code&gt;可以匹配&lt;code&gt;&amp;lt;strong&amp;gt;something&amp;lt;/strong&amp;gt;&lt;/code&gt;这样的简单元素。如果不使用反向引用是无法做到的，因为我们无法知道闭合标签和开始标签是否匹配。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\b&lt;/code&gt; : 匹配单词边界,就是位于字符\w（[a-zA-Z0-9_]）和\W[^a-zA-Z0-9_]之间的位置，或者位于字符\w和字符串的开头或者结束之间的位置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\B&lt;/code&gt;: 匹配非单词边界&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exp1(?=exp2)&lt;/code&gt;:正向前瞻（零宽正向先行断言）,要匹配的exp1要满足后面是exp2&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exp1(?!exp2)&lt;/code&gt;:负向前瞻（零宽负向先行断言），要匹配的exp1要满足后面是不是exp2&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(?:exp)&lt;/code&gt;:正则表达式中小括号具有分组和捕获双重作用，如果在小阔号里面开始加上&lt;code&gt;?:&lt;/code&gt;则可以使其不被捕获。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="web" scheme="http://fsysfq.top/categories/web/"/>
    
      <category term="RegExp" scheme="http://fsysfq.top/categories/web/RegExp/"/>
    
    
      <category term="javascript" scheme="http://fsysfq.top/tags/javascript/"/>
    
      <category term="RegExp" scheme="http://fsysfq.top/tags/RegExp/"/>
    
  </entry>
  
  <entry>
    <title>react-dependency-injection</title>
    <link href="http://fsysfq.top/2017/07/02/react-dependency-injection/"/>
    <id>http://fsysfq.top/2017/07/02/react-dependency-injection/</id>
    <published>2017-07-02T15:27:36.000Z</published>
    <updated>2018-07-07T13:18:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>分享很好的一篇文章，原文链接：<a href="https://github.com/krasimir/react-in-patterns/tree/master/patterns/dependency-injection" target="_blank" rel="noopener">https://github.com/krasimir/react-in-patterns/tree/master/patterns/dependency-injection</a></p></blockquote><h2 id="React-in-patterns-Dependency-injection"><a href="#React-in-patterns-Dependency-injection" class="headerlink" title="React in patterns / Dependency injection"></a><a href="../../README.md">React in patterns</a> / Dependency injection</h2><ul><li><a href="https://github.com/krasimir/react-in-patterns/tree/master/patterns/dependency-injection/src" target="_blank" rel="noopener">Source code using React’s context</a></li><li><a href="https://github.com/krasimir/react-in-patterns/tree/master/patterns/dependency-injection-module-system/src" target="_blank" rel="noopener">Source code using module system</a></li></ul><hr><p>Big part of the modules/components that we write have dependencies. A proper management of these dependencies is critical for the success of the project. There is a technique (some people consider it as a <em>pattern</em>) called <a href="http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript" target="_blank" rel="noopener"><em>dependency injection</em></a> that helps solving the problem.</p><p>In React the need of dependency injector is easily visible. Let’s consider the following application tree:<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Title.jsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Title</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------</span></span><br><span class="line"><span class="comment">// Header.jsx</span></span><br><span class="line"><span class="keyword">import</span> Title <span class="keyword">from</span> <span class="string">'./Title.jsx'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;Title /&gt;</span><br><span class="line">    &lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ -----------------------------------</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ App.jsx</span></span><br><span class="line"><span class="regexp">import Header from './</span>Header.jsx<span class="string">';</span></span><br><span class="line"><span class="string">class App extends React.Component &#123;</span></span><br><span class="line"><span class="string">  constructor(props) &#123;</span></span><br><span class="line"><span class="string">    super(props);</span></span><br><span class="line"><span class="string">    this.state = &#123; title: '</span>React <span class="keyword">in</span> patterns<span class="string">' &#125;;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  render() &#123;</span></span><br><span class="line"><span class="string">    return &lt;Header /&gt;;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure></p><p>The string “React in patterns” should somehow reach the <code>Title</code> component. The direct way of doing this is to pass it from <code>App</code> to <code>Header</code> and then <code>Header</code> to pass it to <code>Title</code>. However, this may work for these three components but what happens if there are multiple properties and deeper nesting. Lots of components will have to mention properties that they are not interested in. It is clear that most React components receive their dependencies via props but the question is how these dependencies reach that point.</p><p>We already saw how the <a href="https://github.com/krasimir/react-in-patterns/tree/master/patterns/higher-order-components" target="_blank" rel="noopener">higher-order component</a> may be used to inject data. Let’s use the same technique to inject the <code>title</code> variable:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inject.jsx</span></span><br><span class="line"><span class="keyword">var</span> title = <span class="string">'React in patterns'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">inject</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Injector</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Component</span><br><span class="line">          &#123;...this.state&#125;</span><br><span class="line">          &#123;...this.props&#125;</span><br><span class="line">          title=&#123; title &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------</span></span><br><span class="line"><span class="comment">// Header.jsx</span></span><br><span class="line"><span class="keyword">import</span> inject <span class="keyword">from</span> <span class="string">'./inject.jsx'</span>;</span><br><span class="line"><span class="keyword">import</span> Title <span class="keyword">from</span> <span class="string">'./Title.jsx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> EnhancedTitle = inject(Title);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;EnhancedTitle /&gt;</span><br><span class="line">    &lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>The <code>title</code> is hidden in a middle layer (higher-order component) where we pass it as a prop to the original <code>Title</code> component. That’s all nice but it solves only half of the problem. Now we don’t have to pass the <code>title</code> down the tree but how this data will reach the <code>enhance.jsx</code> helper.</p><h2 id="Using-React’s-context"><a href="#Using-React’s-context" class="headerlink" title="Using React’s context"></a>Using React’s context</h2><p>React has the concept of <a href="https://facebook.github.io/react/docs/context.html" target="_blank" rel="noopener"><em>context</em></a>. The <em>context</em> is something that every component may have access to. It’s something like an <a href="https://github.com/krasimir/EventBus" target="_blank" rel="noopener">event bus</a> but for data. A single model which we can access from everywhere.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a place where we'll define the context</span></span><br><span class="line"><span class="keyword">var</span> context = &#123; <span class="attr">title</span>: <span class="string">'React in patterns'</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">App.childContextTypes = &#123;</span><br><span class="line">  title: React.PropTypes.string</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a place where we need data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inject</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">var</span> title = <span class="keyword">this</span>.context.title;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Inject.contextTypes = &#123;</span><br><span class="line">  title: React.PropTypes.string</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Notice that we have to specify the exact signature of the context object. With <code>childContextTypes</code> and <code>contextTypes</code>. If those are not specified then the <code>context</code> object will be empty. That may be a little bit frustrating because we may have lots of stuff to put there. That’s why it is a good practice that our <code>context</code> is not just a plain object but it has an interface that allows us to store and retrieve data. For example:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dependencies.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  get(key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  register(key, value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then, if we go back to our example, the very top <code>App</code> component may look like that:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dependencies <span class="keyword">from</span> <span class="string">'./dependencies'</span>;</span><br><span class="line"></span><br><span class="line">dependencies.register(<span class="string">'title'</span>, <span class="string">'React in patterns'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> dependencies;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Header /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">App.childContextTypes = &#123;</span><br><span class="line">  data: React.PropTypes.object,</span><br><span class="line">  get: React.PropTypes.func,</span><br><span class="line">  register: React.PropTypes.func</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>And our <code>Title</code> component gets it’s data through the context:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Title.jsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;&#123; this.context.get('title') &#125;&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Title.contextTypes = &#123;</span><br><span class="line">  data: React.PropTypes.object,</span><br><span class="line">  get: React.PropTypes.func,</span><br><span class="line">  register: React.PropTypes.func</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Ideally we don’t want to specify the <code>contextTypes</code> every time when we need an access to the context. This detail may be wrapped in a higher-order component. And even more, we may write an utility function that is more descriptive and helps us declare the exact wiring. I.e instead of accessing the context directly with <code>this.context.get(&#39;title&#39;)</code> we ask the higher-order component to get what we need and to pass it as a prop to our component. For example:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Title.jsx</span></span><br><span class="line"><span class="keyword">import</span> wire <span class="keyword">from</span> <span class="string">'./wire'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Title</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> wire(Title, [<span class="string">'title'</span>], <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">title</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; title &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>The <code>wire</code> function accepts first a React component, then an array with all the needed dependencies (which are <code>register</code>ed already) and then a function which I like to call <code>mapper</code>. It receives what’s stored in the context as a raw data and returns an object which is the actual React props for our component (<code>Title</code>). In this example we just pass what we get - a <code>title</code> string variable. However, in a real app this could be a collection of data stores, configuration or something else. So, it’s nice that we pass exactly what we need and don’t pollute the components with data that they don’t need.</p><p>Here is how the <code>wire</code> function looks like:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">wire</span>(<span class="params">Component, dependencies, mapper</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inject</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">var</span> resolved = dependencies.map(<span class="keyword">this</span>.context.get.bind(<span class="keyword">this</span>.context));</span><br><span class="line">      <span class="keyword">var</span> props = mapper(...resolved);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> React.createElement(Component, props);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Inject.contextTypes = &#123;</span><br><span class="line">    data: React.PropTypes.object,</span><br><span class="line">    get: React.PropTypes.func,</span><br><span class="line">    register: React.PropTypes.func</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> Inject;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Inject</code> is a higher-order component that gets access to the context and retrieves all the items listed under <code>dependencies</code> array. The <code>mapper</code> is a function receiving the <code>context</code> data and transforms it to props for our component.</p><p>At the end of this section we should mention that the usage of <code>context</code> is not highly recommended by Facebook:</p><blockquote><p>Context is an advanced and experimental feature. The API is likely to change in future releases.</p></blockquote><blockquote><p>Most applications will never need to use context. Especially if you are just getting started with React, you likely do not want to use context. Using context will make your code harder to understand because it makes the data flow less clear. It is similar to using global variables to pass state through your application.</p></blockquote><blockquote><p>If you have to use context, use it sparingly.</p></blockquote><blockquote><p>Regardless of whether you’re building an application or a library, try to isolate your use of context to a small area and avoid using the context API directly when possible so that it’s easier to upgrade when the API changes.</p></blockquote><h2 id="Using-the-module-system"><a href="#Using-the-module-system" class="headerlink" title="Using the module system"></a>Using the module system</h2><p>If we don’t want to use the context there are a couple of other ways to achieve the injection. They are not exactly React specific but worth mentioning. One of them is using the module system.</p><p>As we know the typical module system in JavaScript has a caching mechanism. It’s nicely noted in the <a href="https://nodejs.org/api/modules.html#modules_caching" target="_blank" rel="noopener">Node’s documentation</a>:</p><blockquote><p>Modules are cached after the first time they are loaded. This means (among other things) that every call to require(‘foo’) will get exactly the same object returned, if it would resolve to the same file.</p></blockquote><blockquote><p>Multiple calls to require(‘foo’) may not cause the module code to be executed multiple times. This is an important feature. With it, “partially done” objects can be returned, thus allowing transitive dependencies to be loaded even when they would cause cycles.</p></blockquote><p>How’s that helping for our injection? Well, if we export an object we are actually exporting a <a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#singletonpatternjavascript" target="_blank" rel="noopener">singleton</a> and every other module that imports the file will get the same object. This allows us to <code>register</code> our dependencies and later <code>fetch</code> them in another file.</p><p>Let’s create a new file called <code>di.jsx</code> with the following content:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dependencies = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">key, dependency</span>) </span>&#123;</span><br><span class="line">  dependencies[key] = dependency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dependencies[key]) <span class="keyword">return</span> dependencies[key];</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`"<span class="subst">$&#123; key &#125;</span> is not registered as dependency.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">wire</span>(<span class="params">Component, deps, mapper</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Injector</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">      <span class="keyword">this</span>._resolvedDependencies = mapper(...deps.map(fetch));</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Component</span><br><span class="line">          &#123;...this.state&#125;</span><br><span class="line">          &#123;...this.props&#125;</span><br><span class="line">          &#123;...this._resolvedDependencies&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We’ll store the dependencies in <code>dependencies</code> global variable (it’s global for our module, not at an application level). We then export two functions <code>register</code> and <code>fetch</code> that write and read entries. It looks a little bit like implementing setter and getter against a simple JavaScript object. Then we have the <code>wire</code> function that accepts our React component and returns a <a href="https://github.com/krasimir/react-in-patterns/tree/master/patterns/higher-order-components" target="_blank" rel="noopener">higher-order component</a>. In the constructor of that component we are resolving the dependencies and later while rendering the original component we pass them as props. We follow the same pattern where we describe what we need (<code>deps</code> argument) and extract the needed props with a <code>mapper</code> function.</p><p>Having the <code>di.jsx</code> helper we are again able to register our dependencies at the entry point of our application (<code>app.jsx</code>) and inject them wherever (<code>Title.jsx</code>) we need.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.jsx</span></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'./Header.jsx'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; register &#125; <span class="keyword">from</span> <span class="string">'./di.jsx'</span>;</span><br><span class="line"></span><br><span class="line">register(<span class="string">'my-awesome-title'</span>, <span class="string">'React in patterns'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Header /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// -----------------------------------</span><br><span class="line">// Header.jsx</span><br><span class="line">import Title from './Title.jsx';</span><br><span class="line"></span><br><span class="line">export default function Header() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;Title /&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -----------------------------------</span><br><span class="line">// Title.jsx</span><br><span class="line">import &#123; wire &#125; from './di.jsx';</span><br><span class="line"></span><br><span class="line">var Title = function(props) &#123;</span><br><span class="line">  return &lt;h1&gt;&#123; props.title &#125;&lt;/h1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default wire(Title, ['my-awesome-title'], title =&gt; (&#123; title &#125;));</span><br></pre></td></tr></table></figure><p>If we look at the <code>Title.jsx</code> file we’ll see that the actual component and the wiring may live in different files. That way the component and the mapper function become easily unit testable.</p><h2 id="Injecting-with-the-help-of-a-build-process"><a href="#Injecting-with-the-help-of-a-build-process" class="headerlink" title="Injecting with the help of a build process"></a>Injecting with the help of a build process</h2><p>We are all processing our JavaScript before shipping it to the browser. This biggest benefit of having an intermediate process is the ability to add features which are normally not there. Like for example the support of <a href="http://krasimirtsonev.com/blog/article/constructive-destructuring-es6-assignment" target="_blank" rel="noopener">ES6 destructuring</a> with <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a> or static type checking with <a href="https://flowtype.org/" target="_blank" rel="noopener">Flow</a>. There are tools for dependency injection too. <a href="https://github.com/inversify/InversifyJS" target="_blank" rel="noopener">InversifyJS</a> is one of them and in the next section we will see how it works with React components.</p><h3 id="Dependency-injection-powered-by-an-IoC-container"><a href="#Dependency-injection-powered-by-an-IoC-container" class="headerlink" title="Dependency injection powered by an IoC container"></a>Dependency injection powered by an IoC container</h3><p>Not long ago an user in Twitter asked <a href="https://twitter.com/mweststrate" target="_blank" rel="noopener">Michel Weststrate</a>(the author of <a href="https://github.com/mobxjs/mobx" target="_blank" rel="noopener">MobX</a>) the following:</p><blockquote><p>How safe is it to use mobx-react <provider>? Or are there any other options for connecting stores to components without passing them explicitly through each component?</provider></p></blockquote><p>The <a href="https://twitter.com/mweststrate/status/750267384926208000" target="_blank" rel="noopener">answer</a> was the following:</p><blockquote><p>Dependency injection like InversifyJS also works nicely</p></blockquote><p><a href="https://github.com/inversify/InversifyJS" target="_blank" rel="noopener">InversifyJS</a> is an IoC container. We can use an IoC container to inject a value into React components without passing it explicitly through each component and without using the context.</p><p>In this demonstration we are going to use InversifyJS and <a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="noopener">TypeScript</a>. We are using InversifyJS because it works in both Node.js and web browsers. This is an important feature because some React applications use server-side rendering. We are also using TypeScript because it is the recommended by InversifyJS.</p><p>InversifyJS supports two kinds of injections:</p><ul><li>Constructor injection</li><li>Property injection</li></ul><p>In order to use “constructor injection” the IoC container needs to be able to create the instances of the classes. In React the components sometimes are just functions (not classes) and we can’t delegate the creation of the instances of the components to the IoC container. This means that <strong>constructor injection powered by IoC containers don’t play nicely with React</strong></p><p>However, <strong>property injection works just fine</strong> considering the fact that we want to pass dependencies to components without passing them explicitly through each component.</p><p>Let’s take a look to a basic example.</p><p>We need to start by configuring the IoC container. In InversifyJs we need to create a dictionary that maps a type identifier with a type. The dictionary entries are known as “type bindings”.</p><p>In this case, we are binding the identifier <code>UserStore</code> to the class <code>UserStore</code>. This time the identifier is a Class but InversifyJS also allows us to use <code>Symbols</code> or string literals as identifiers. Symbols or string literals are required when we use interfaces.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Kernel, makePropertyInjectDecorator &#125; <span class="keyword">from</span> <span class="string">"inversify"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserStore &#125; <span class="keyword">from</span> <span class="string">"./store/user"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"reflect-metadata"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> kernel = <span class="keyword">new</span> Kernel();</span><br><span class="line">kernel.bind&lt;UserStore&gt;(UserStore).to(UserStore);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pInject = makePropertyInjectDecorator(kernel);</span><br><span class="line"><span class="keyword">export</span> &#123; kernel, pInject &#125;;</span><br></pre></td></tr></table></figure><p>We also need to generate a decorator using the function <code>makePropertyInjectDecorator</code>.</p><p>The generated <code>pInject</code> decorator allows us to flag the properties of a class that we want to be injected:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; pInject &#125; <span class="keyword">from</span> <span class="string">"./utils/di"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserStore &#125; <span class="keyword">from</span> <span class="string">"./store/user"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> User <span class="keyword">extends</span> React.Component&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@pInject</span>(UserStore)</span><br><span class="line">    <span class="keyword">private</span> userStore: UserStore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;h1&gt;&#123;<span class="keyword">this</span>.userStore.pageTitle&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>Injected properties are <em>lazy evaluated</em>. This means that the value of the <code>userStore</code> property is only set after we try to access it for the first time.</p><p>Based on the <a href="https://facebook.github.io/react/docs/context.html" target="_blank" rel="noopener">React docs</a> we should try to avoid using context:</p><p>The main advantage of using an IoC container like InversifyJS is that <strong>we are not using the context</strong>!</p><p>InversifyJS is also great for testing because we can declare a new bindings and inject a mock or stub instead of a real value:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.bind&lt;UserStore&gt;(UserStore).toConstantValue(&#123; pageTitle: <span class="string">"Some text for testing..."</span> &#125;);</span><br></pre></td></tr></table></figure><p>Find some real use cases of InversifyJS with React <a href="https://github.com/Mercateo/dwatch/blob/master/app/src/components/site/LocaleSwitcher.tsx#L12" target="_blank" rel="noopener">here</a> and <a href="https://github.com/Mercateo/dwatch/blob/master/app/src/components/site/Header.tsx#L14" target="_blank" rel="noopener">here</a> or learn more about InversifyJS at the official repository <a href="https://github.com/inversify/InversifyJS" target="_blank" rel="noopener">here</a>.</p><h3 id="Final-thoughts"><a href="#Final-thoughts" class="headerlink" title="Final thoughts"></a>Final thoughts</h3><p>Dependency injection is a tough problem. Especially in JavaScript. It’s not really an issue within React application but appears everywhere. At the time of this writing React offers only the <code>context</code> as an instrument for resolving dependencies. As we mentioned above this technique should be used sparingly. And of course there are some alternatives. For example using the module system or libraries like InversifyJS.</p><h3 id="Other-resources-related-to-dependency-injection"><a href="#Other-resources-related-to-dependency-injection" class="headerlink" title="Other resources related to dependency injection"></a>Other resources related to dependency injection</h3><ul><li><a href="https://medium.com/@marziosuperina/level-up-your-dependencies-in-react-part-1-d67bb2711b51" target="_blank" rel="noopener">Level-up your dependencies in React </a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;分享很好的一篇文章，原文链接：&lt;a href=&quot;https://github.com/krasimir/react-in-patterns/tree/master/patterns/dependency-injection&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/krasimir/react-in-patterns/tree/master/patterns/dependency-injection&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;React-in-patterns-Dependency-injection&quot;&gt;&lt;a href=&quot;#React-in-patterns-Dependency-injection&quot; class=&quot;headerlink&quot; title=&quot;React in patterns / Dependency injection&quot;&gt;&lt;/a&gt;&lt;a href=&quot;../../README.md&quot;&gt;React in patterns&lt;/a&gt; / Dependency injection&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/krasimir/react-in-patterns/tree/master/patterns/dependency-injection/src&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Source code using React’s context&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/krasimir/react-in-patterns/tree/master/patterns/dependency-injection-module-system/src&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Source code using module system&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Big part of the modules/components that we write have dependencies. A proper management of these dependencies is critical for the success of the project. There is a technique (some people consider it as a &lt;em&gt;pattern&lt;/em&gt;) called &lt;a href=&quot;http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;em&gt;dependency injection&lt;/em&gt;&lt;/a&gt; that helps solving the problem.&lt;/p&gt;
&lt;p&gt;In React the need of dependency injector is easily visible. Let’s consider the following application tree:&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://fsysfq.top/categories/web/"/>
    
      <category term="技术" scheme="http://fsysfq.top/categories/web/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="react" scheme="http://fsysfq.top/tags/react/"/>
    
      <category term="模式" scheme="http://fsysfq.top/tags/%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>selection-and-popover</title>
    <link href="http://fsysfq.top/2017/07/01/selection-and-popover/"/>
    <id>http://fsysfq.top/2017/07/01/selection-and-popover/</id>
    <published>2017-07-01T14:31:17.000Z</published>
    <updated>2018-07-07T13:18:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/font_ajz0qys9mh392j4i.css"></p><style>  .popover {    position: absolute;    display: block;    padding: 1px;    margin: 0;    max-width: 400px;    background: #fff;    border: 1px solid #777;    box-shadow: 1px 3px 10px #aaa;    border-radius: 5px;  }  .popover>.arrow {    position: absolute;    display: block;    width: 0;    height: 0;    border: 11px solid;    border-color: transparent;  }  .popover>.arrow::after {    position: absolute;    display: block;    content: '';    width: 0;    height: 0;    border: 10px solid;    border-color: transparent;  }  .popover.bottom>.arrow {    border-top-width: 0px;    border-bottom-color: #777;    top: -11px;    left: 50%;    margin-left: -11px;  }  .popover.bottom>.arrow::after {    border-top-width: 0px;    border-bottom-color: #fff;    top: 1px;    left: -10px;  }  .popover.top>.arrow {    border-bottom-width: 0px;    border-top-color: #777;    margin-left: -11px;    left: 50%;    top: 100%;  }  .popover.top>.arrow::after {    border-bottom-width: 0px;    border-top-color: #fff;    left: -10px;    top: -11px;  }  .popover.bottom.edit>.arrow {    border-bottom-color: transparent;  }  .popover.bottom.edit>.arrow::after {    border-bottom-color: #262625;  }  .popover.top.edit>.arrow {    border-top-color: transparent;  }  .popover.top.edit>.arrow::after {    border-top-color: #262625;  }</style><h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p>前两天看到一个面试题，问CSS实现三角形原理，想到以前做过气泡弹出框，气泡弹出框的小角是个三角形，因此对CSS实现三角形原理还是了解的。但是具体实现有些生疏了，因此又实现了一遍。同时注意到，使用Google划词翻译的时候，会弹出气泡框显示翻译内容，激发了我做出这种效果的欲望，可是那时候正在学习其它的东西，就先搁置先来了，不过呢，看来是天意，鬼使神差般把我链接到了<a href="https://medium.com/@marziosuperina/level-up-your-dependencies-in-react-part-1-d67bb2711b51" target="_blank" rel="noopener">medium</a>。并且有下面的情形。<br><img src="/2017/07/01/selection-and-popover/medium.png" alt="medium"><br>这时就决定做一个玩玩。<br><a id="more"></a></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="弹出框实现"><a href="#弹出框实现" class="headerlink" title="弹出框实现"></a>弹出框实现</h2><p>首先我选择了从弹出框入手，以前做过类似的例子，但是弹框气泡头可以向左、向右、向上、向下。在实现的时候需要好好设计。由于自己经验不足，因此参考了<a href="http://v3.bootcss.com/javascript/#popovers" target="_blank" rel="noopener">bootstrap</a> 上组件的实现。这里只实现了向上、向下的情况。<br>代码如下：<br>css:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">  <span class="selector-class">.popover</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#777</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">3px</span> <span class="number">10px</span> <span class="number">#aaa</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.popover</span>&gt;<span class="selector-class">.arrow</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">11px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.popover</span>&gt;<span class="selector-class">.arrow</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*弹框显示在指定区域下方*/</span></span><br><span class="line">  <span class="selector-class">.popover</span><span class="selector-class">.bottom</span>&gt;<span class="selector-class">.arrow</span> &#123;</span><br><span class="line">    <span class="attribute">border-top-width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-color</span>: <span class="number">#777</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">11px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">11px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.popover</span><span class="selector-class">.bottom</span>&gt;<span class="selector-class">.arrow</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">border-top-width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*弹框显示在指定区域上方*/</span></span><br><span class="line">  <span class="selector-class">.popover</span><span class="selector-class">.top</span>&gt;<span class="selector-class">.arrow</span> &#123;</span><br><span class="line">    <span class="attribute">border-bottom-width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">border-top-color</span>: <span class="number">#777</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">11px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100%</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.popover</span><span class="selector-class">.top</span>&gt;<span class="selector-class">.arrow</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">border-bottom-width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">border-top-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">11px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*剩下的不写了*/</span></span><br></pre></td></tr></table></figure></p><p>html:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position:relative"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"float:left;position:relative;"</span> <span class="attr">class</span>=<span class="string">"popover bottom"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"arrow"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>bottom<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Laborum earum rerum, est odit quod eveniet facere facilis! Sapiente</span><br><span class="line">      rem minus est numquam aperiam distinctio, suscipit cupiditate vero, maxime, obcaecati nisi?</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"float:left;position:relative;"</span> <span class="attr">class</span>=<span class="string">"popover top"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"arrow"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>top<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Laborum earum rerum, est odit quod eveniet facere facilis! Sapiente</span><br><span class="line">      rem minus est numquam aperiam distinctio, suscipit cupiditate vero, maxime, obcaecati nisi?</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>效果：</p> <div style="position:relative;float:left;display:flex;justify-content:center;flex-wrap:wrap"> <div style="float:left;position:relative;" class="popover bottom"> <div class="arrow"></div><h3 class="title">bottom</h3> <div class="content"> Lorem ipsum dolor sit amet, consectetur adipisicing elit. Laborum earum rerum, est odit quod eveniet facere facilis! Sapienterem minus est numquam aperiam distinctio, suscipit cupiditate vero, maxime, obcaecati nisi? </div></div><div style="float:left;position:relative;" class="popover top"><div class="arrow"></div><h3 class="title">top</h3><div class="content"> Lorem ipsum dolor sit amet, consectetur adipisicing elit. Laborum earum rerum, est odit quod eveniet facere facilis! Sapiente rem minus est numquam aperiam distinctio, suscipit cupiditate vero, maxime, obcaecati nisi?</div></div></div><br><div style="clear:both"></div><h2 id="订制弹框"><a href="#订制弹框" class="headerlink" title="订制弹框"></a>订制弹框</h2><p>显示效果如下，可以在该页面尝试。<br><img src="/2017/07/01/selection-and-popover/显示效果.png" alt="效果"><br>更改箭头颜色<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.popover</span><span class="selector-class">.bottom</span><span class="selector-class">.edit</span>&gt;<span class="selector-class">.arrow</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.popover</span><span class="selector-class">.bottom</span><span class="selector-class">.edit</span>&gt;<span class="selector-class">.arrow</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom-color</span>: <span class="number">#262625</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.popover</span><span class="selector-class">.top</span><span class="selector-class">.edit</span>&gt;<span class="selector-class">.arrow</span> &#123;</span><br><span class="line">  <span class="attribute">border-top-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.popover</span><span class="selector-class">.top</span><span class="selector-class">.edit</span>&gt;<span class="selector-class">.arrow</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">border-top-color</span>: <span class="number">#262625</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建弹出框，<code>tools.createElement</code>是自己封装的方法。通过审查元素可以看到。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createEditPopover</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arrowDOM = tools.createElement(<span class="string">'div'</span>, &#123;</span><br><span class="line">      className: <span class="string">'arrow'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> contentDOM = tools.createElement(<span class="string">'div'</span>, &#123;</span><br><span class="line">      className: <span class="string">'popover-content'</span>,</span><br><span class="line">      style: &#123; <span class="attr">lineHeight</span>: <span class="string">'40px'</span>, <span class="attr">color</span>: <span class="string">'#fff'</span> &#125;,</span><br><span class="line">      innerHTML: <span class="string">'&lt;i style="font-size:22px;margin:0 7px" class="iconfont icon-edit1 "&gt;\</span></span><br><span class="line"><span class="string">        &lt;/i&gt;&lt;i style="font-size:22px;margin:0px 7px" class="iconfont icon-message "&gt;&lt;/i&gt;\</span></span><br><span class="line"><span class="string">        &lt;/i&gt;&lt;i style="font-size:22px;margin:0px 7px;margin-top:2px" class="iconfont icon-twitter"&gt;&lt;/i&gt;\</span></span><br><span class="line"><span class="string">        &lt;/i&gt;&lt;i style="font-size:22px;margin:0px 7px" class="iconfont icon-wodebiji"&gt;&lt;/i&gt;'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> popoverWidth = <span class="number">160</span>,</span><br><span class="line">      popoverHeight = <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">var</span> popoverDOM = tools.createElement(<span class="string">'div'</span>, &#123;</span><br><span class="line">      style: &#123;</span><br><span class="line">        width: popoverWidth + <span class="string">'px'</span>,</span><br><span class="line">        height: popoverHeight + <span class="string">'px'</span>,</span><br><span class="line">        top: <span class="number">0</span>,</span><br><span class="line">        left: <span class="number">0</span>,</span><br><span class="line">        userSelect: <span class="string">'none'</span>,</span><br><span class="line">        background: <span class="string">'#262625'</span>,</span><br><span class="line">        zIndex: <span class="number">2000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, [arrowDOM, contentDOM]);</span><br><span class="line">    <span class="keyword">return</span> popoverDOM;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="获得选择区域"><a href="#获得选择区域" class="headerlink" title="获得选择区域"></a>获得选择区域</h2><p>本以为，获取选择区域及内容可以通过<code>onselect</code>事件获得，测试发现不行，<code>onselect</code>只能作用域文本输入框<code>&lt;input type=&quot;text&quot;&gt;, &lt;textarea&gt;</code>。要是想获取选择的<code>div</code>内容时，就要用到<code>window.getSelection</code>。参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getSelection" target="_blank" rel="noopener">mdn getSelection</a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Selection" target="_blank" rel="noopener">mdn selection</a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Range" target="_blank" rel="noopener">mdn range</a>。获取选择内容很简单。但是要做的是，选中文字的时候，弹框出现在选中文字区域的中心，因此就要获取到选择区域的位置信息。开始的时候没注意<code>range</code>对象的方法，就在Stack Overflow搜到了一个和我现在要做的一样的内容。自己再走前人走过的坑，善用搜索引擎！<a href="https://stackoverflow.com/questions/31559219/position-element-to-center-of-selected-range" target="_blank" rel="noopener">前往</a>,惊人的相似。</p><p>代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedTextPos</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">window</span>.getSelection) &#123;</span><br><span class="line">       <span class="keyword">var</span> selection = <span class="built_in">window</span>.getSelection();</span><br><span class="line">       <span class="keyword">var</span> range = selection.getRangeAt(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">var</span> rect = range.getBoundingClientRect();</span><br><span class="line">       <span class="comment">//常规浏览器</span></span><br><span class="line">       <span class="comment">// &#123;</span></span><br><span class="line">       <span class="comment">//   bottom: 49.60000228881836,</span></span><br><span class="line">       <span class="comment">//   height: 20.80000114440918,</span></span><br><span class="line">       <span class="comment">//   left: 376,</span></span><br><span class="line">       <span class="comment">//   right: 389.6000061035156,</span></span><br><span class="line">       <span class="comment">//   top: 28.80000114440918,</span></span><br><span class="line">       <span class="comment">//   width: 13.600006103515625</span></span><br><span class="line">       <span class="comment">// &#125;</span></span><br><span class="line">       <span class="keyword">return</span> rect;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.getSelection) &#123;</span><br><span class="line">       <span class="keyword">var</span> selection = <span class="built_in">document</span>.getSelection();</span><br><span class="line">       <span class="keyword">var</span> range = selection.getRangeAt(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">var</span> rect = range.getBoundingClientRect();</span><br><span class="line">       <span class="keyword">return</span> rect;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.selection) &#123;</span><br><span class="line">       <span class="keyword">var</span> selection = <span class="built_in">document</span>.selection.createRange();</span><br><span class="line">       <span class="comment">// selection对象，兼容ie&lt;9</span></span><br><span class="line">       <span class="comment">//&#123;</span></span><br><span class="line">       <span class="comment">//   boundingHeight: 81,</span></span><br><span class="line">       <span class="comment">//   boundingLeft: 224,</span></span><br><span class="line">       <span class="comment">//   boundingTop: 534,</span></span><br><span class="line">       <span class="comment">//   boundingWidth: 309,</span></span><br><span class="line">       <span class="comment">//   htmlText: "balabalabala..",</span></span><br><span class="line">       <span class="comment">//   offsetLeft: 222,</span></span><br><span class="line">       <span class="comment">//   offsetTop: 532,</span></span><br><span class="line">       <span class="comment">//   text: "党媒:台当局不重视经费仅给5万 武术在台湾快断根山西回应“演唱会损坏足球草坪”：将下“封杀令”国防部回应“建军节阅兵”传言：将适时发布进展"</span></span><br><span class="line">       <span class="comment">// &#125;</span></span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         top: selection.boundingTop,</span><br><span class="line">         left: selection.boundingLeft,</span><br><span class="line">         width: selection.boundingWidth,</span><br><span class="line">         height: selection.boundingHeight,</span><br><span class="line">         bottom: selection.boundingTop + selection.boundingHeight,</span><br><span class="line">         right: selection.boundingLeft + selection.boundingWidth</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getSelectedText</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">window</span>.getSelection) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">window</span>.getSelection().toString();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.getSelection) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">document</span>.getSelection();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.selection) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">document</span>.selection.createRange().text;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>以上代码不适用于<code>&lt;input type=&quot;text&quot;&gt;, &lt;textarea&gt;</code>。想了些办法都不好实现。要是定位<code>textarea</code>中选中文字位置，思路是：通过<code>onselect</code>事件获得<code>selectionStart</code>和<code>selectionEnd</code>,想办法计算选择文字开始和结束所在的行、输入框中字体宽度以及输入框在文档中的位置，有了这些信息就可以计算选中区域的位置信息，但是很麻烦，而且有点难。想想这种需求不多，如果有这种需求可以使用可编辑div实现，现在一些富文本编辑器应该就是使用的这种形式实现的。</p><h2 id="操作逻辑实现"><a href="#操作逻辑实现" class="headerlink" title="操作逻辑实现"></a>操作逻辑实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> editPopover = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> prevText = <span class="string">""</span>;</span><br><span class="line">tools.addEvent(<span class="built_in">document</span>, <span class="string">'mouseup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  selection = <span class="built_in">window</span>.getSelection();</span><br><span class="line">  range = selection.getRangeAt(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">var</span> rect = getSelectedTextPos();</span><br><span class="line">  <span class="keyword">var</span> txt = getSelectedText();</span><br><span class="line">  <span class="comment">//txt!=prevText作用是当鼠标再次点击选中区域的时候，使得弹框也能消失</span></span><br><span class="line">  <span class="keyword">if</span> (txt != <span class="string">""</span> &amp;&amp; txt != prevText) &#123;</span><br><span class="line">    prevText = txt</span><br><span class="line">    <span class="keyword">var</span> center_x = rect.left + rect.width / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> center_y = rect.top &gt; <span class="number">100</span> ? <span class="built_in">document</span>.body.scrollTop + rect.top : <span class="built_in">document</span>.body.scrollTop + rect.bottom;</span><br><span class="line">    <span class="comment">//document.body.scrollTop修正页面有滚动条的情况</span></span><br><span class="line">    <span class="keyword">var</span> pos = rect.top &gt; <span class="number">100</span> ? <span class="string">'top edit'</span> : <span class="string">'bottom edit'</span>;</span><br><span class="line">    <span class="keyword">var</span> popoverWidth = <span class="number">160</span>,</span><br><span class="line">      popoverHeight = <span class="number">40</span>,</span><br><span class="line">      popoverLeft = center_x - popoverWidth / <span class="number">2</span> + <span class="string">'px'</span>,</span><br><span class="line">      popoverTop;</span><br><span class="line">    <span class="comment">//只内存中只保留一个实例，不用每次单击都创建。</span></span><br><span class="line">    editPopover = editPopover || createEditPopover();</span><br><span class="line">    <span class="keyword">if</span> (pos === <span class="string">'top edit'</span>) &#123;</span><br><span class="line">      popoverTop = center_y - popoverHeight - <span class="number">14</span> + <span class="string">'px'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      popoverTop = center_y + <span class="number">11</span> + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    editPopover.className = <span class="string">"popover "</span> + pos;</span><br><span class="line">    editPopover.style.left = popoverLeft;</span><br><span class="line">    editPopover.style.top = popoverTop;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(editPopover);</span><br><span class="line">    <span class="comment">//为document添加mousedown事件，点击页面使得弹框消失，要是点击弹框弹框不消失。</span></span><br><span class="line">    <span class="keyword">var</span> removeEvent = tools.addEvent(<span class="built_in">document</span>, <span class="string">'mousedown'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ele = e.target;</span><br><span class="line">      <span class="keyword">var</span> isPopover = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">while</span> (ele != <span class="built_in">document</span>.body &amp;&amp; ele != <span class="literal">null</span>) &#123;<span class="comment">// 这里判断点击的是否是弹框。</span></span><br><span class="line">        <span class="keyword">if</span> (ele == editPopover) &#123;</span><br><span class="line">          isPopover = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ele = ele.parentNode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!isPopover) &#123;</span><br><span class="line">        <span class="built_in">document</span>.body.removeChild(editPopover);</span><br><span class="line">        removeEvent(); <span class="comment">//弹框移除，移除mousedown事件</span></span><br><span class="line">        e.stopPropagation();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>保持求知欲，不断探索新鲜事物是不断进步的源泉。<br>附加：<br>在查看google translate插件html代码的时候发现了shadow-dom，带着疑惑一探究竟。 <a href="http://www.cnblogs.com/coco1s/p/5711795.html" target="_blank" rel="noopener">http://www.cnblogs.com/coco1s/p/5711795.html</a><br>如何查看shadow dom?（chrome 58.0.3029.81）f12控制开，找出控制台的setting-&gt;preference-&gt;element-&gt;Show user agent shadow DOM。<br>看chrome使用的技巧：<a href="http://www.cnblogs.com/AloneSword/p/4546935.html。" target="_blank" rel="noopener">http://www.cnblogs.com/AloneSword/p/4546935.html。</a></p><script>    var tools = (function () {      var $ = function (selector) {        return [].slice.call(document.querySelectorAll(selector));      }      /**        * eventTarget:要添加拖动事件的元素        * moveTarget：要移动的元素（绝对定位），eventTarget的父元素        * onMove: 元素移动的时候要触发的回调        * onEnd: 元素停止移动触发回调        * direction：'x'只能横向移动,'y'只能纵向移动,'xy'：随便移动        * 拖动绝对定位元素        */      var dragMove = function (eventTarget, moveTarget, onMove, onEnd, direction) {        // initzIndex(moveTarget);        onMove = onMove != null ? onMove : null;        onEnd = onEnd != null ? onEnd : null;        direction = direction != null ? direction : 'xy';        var startX, startY, origX, origY;        eventTarget.addEventListener('mousedown', function (e) {          //  setTopzIndex(moveTarget);          startX = e.clientX;          startY = e.clientY;          origX = moveTarget.offsetLeft;          origY = moveTarget.offsetTop;          document.addEventListener('mousemove', handleMove, true);          document.addEventListener('mouseup', handleUp, true);          e.stopPropagation();        });        function handleMove(e) {          if (direction === 'xy') {            moveTarget.style.left = (e.clientX - startX + origX) + "px";            moveTarget.style.top = (e.clientY - startY + origY) + "px";          } else if (direction === 'x') {            moveTarget.style.left = (e.clientX - startX + origX) + "px";          } else if (direction === 'y') {            moveTarget.style.top = (e.clientY - startY + origY) + "px";          }          if (onMove) {            onMove(e);          }        }        function handleUp(e) {          document.removeEventListener('mouseup', handleUp, true);          document.removeEventListener('mousemove', handleMove, true);          e.stopPropagation();          onEnd && onEnd(e);        }      }      function currying(fn, args) {        if (typeof args === 'undefined') {          args = [];        } else if (Object.prototype.toString.call(args) !== '[object Array]') {          args = [args];        }        return function () {          args2 = [].slice.call(arguments);          var ag = [].concat.apply(args2, args);          fn.apply(this, ag);        }      }      function addEvent(ele, type, fn, args, capture) {        if (typeof args === 'boolean') {          capture = args;          args = [];        }        if (!capture) {          capture = false;        }        var fn = currying(fn, args);        ele.addEventListener(type, fn, capture);        return function removeEvent() {          ele.removeEventListener(type, fn, capture);        }      }      function isArray(obj) {        return Object.prototype.toString.call(obj) === '[object Array]';      }      function createElement(tag, options, children) {        var property = { id: true, className: true, title: true, innerHTML: true, innerText: true };        var element = document.createElement(tag);        for (var key in options) {          if (property[key]) {            element[key] = options[key];          }        }        if (options['style']) {          for (var key in options['style']) {            element.style[key] = options.style[key];          }        }        if (tools.isArray(children)) {          children.forEach(function (ele) {            element.appendChild(ele);          });        } else if (typeof children === 'object' && children.hasOwnProperty('onclick')) {          element.appendChild(children);        }        return element;      }      function createCss(name, obj) {        var styles = [];        var preg = /([a-z]+)([A-Z])/g;        for (var key in obj) {          if (obj.hasOwnProperty(key)) {            var newKey = key.replace(preg, function (match, p1, p2) {              return [p1, p2.toLowerCase()].join('-');            });            styles.push(newKey + ':' + obj[key]);          }        }        return name + '{' + styles.join(';') + '}';      }      return {        $: $,        currying: currying,        addEvent: addEvent,        dragMove: dragMove,        isArray: isArray,        createElement: createElement,        createCss: createCss      }    })();    function createEditPopover() {      var arrowDOM = tools.createElement('div', {        className: 'arrow',      });      var contentDOM = tools.createElement('div', {        className: 'popover-content',        style: { lineHeight: '40px', color: '#fff' },        innerHTML: '<i style="font-size:22px;margin:0 7px" class="iconfont icon-edit1 ">\          </i><i style="font-size:22px;margin:0px 7px" class="iconfont icon-message "></i>\          </i><i style="font-size:22px;margin:0px 7px;margin-top:2px" class="iconfont icon-twitter"></i>\          </i><i style="font-size:22px;margin:0px 7px" class="iconfont icon-wodebiji"></i>'      });      var popoverWidth = 160,        popoverHeight = 40;      var popoverDOM = tools.createElement('div', {        style: {          width: popoverWidth + 'px',          height: popoverHeight + 'px',          top: 0,          left: 0,          userSelect: 'none',          background: '#262625',          zIndex: 2000        }      }, [arrowDOM, contentDOM]);      return popoverDOM;    }    var editPopover = null;    var prevText = "";    tools.addEvent(document, 'mouseup', function (e) {      selection = window.getSelection();      range = selection.getRangeAt(0);      var rect = getSelectedTextPos();      var txt = getSelectedText();      //txt!=prevText作用是当鼠标再次点击选中区域的时候，使得弹框也能消失      if (txt != "" && txt != prevText) {        prevText = txt        var center_x = rect.left + rect.width / 2;        var center_y = rect.top > 100 ? document.body.scrollTop + rect.top : document.body.scrollTop + rect.bottom;        //document.body.scrollTop修正页面有滚动条的情况        var pos = rect.top > 100 ? 'top edit' : 'bottom edit';        var popoverWidth = 160,          popoverHeight = 40,          popoverLeft = center_x - popoverWidth / 2 + 'px',          popoverTop;        //只内存中只保留一个实例，不用每次单击都创建。        editPopover = editPopover || createEditPopover();        if (pos === 'top edit') {          popoverTop = center_y - popoverHeight - 14 + 'px'        } else {          popoverTop = center_y + 11 + 'px';        }        editPopover.className = "popover " + pos;        editPopover.style.left = popoverLeft;        editPopover.style.top = popoverTop;        document.body.appendChild(editPopover);        //为document添加mousedown事件，点击页面使得弹框消失，要是点击弹框弹框不消失。        var removeEvent = tools.addEvent(document, 'mousedown', function (e) {          var ele = e.target;          var isPopover = false;          while (ele != document.body && ele != null) {// 这里判断点击的是否是弹框。            if (ele == editPopover) {              isPopover = true;              break;            }            ele = ele.parentNode;          }          if (!isPopover) {            document.body.removeChild(editPopover);            removeEvent(); //弹框移除，移除mousedown事件            e.stopPropagation();          }        });      }    })    //https://stackoverflow.com/questions/31559219/position-element-to-center-of-selected-range    function getSelectedTextPos() {      if (window.getSelection) {        var selection = window.getSelection();        var range = selection.getRangeAt(0);        var rect = range.getBoundingClientRect();        //常规浏览器        // {        //   bottom: 49.60000228881836,        //   height: 20.80000114440918,        //   left: 376,        //   right: 389.6000061035156,        //   top: 28.80000114440918,        //   width: 13.600006103515625        // }        return rect;      }      else if (document.getSelection) {        var selection = document.getSelection();        var range = selection.getRangeAt(0);        var rect = range.getBoundingClientRect();        return rect;      }      else if (document.selection) {        var selection = document.selection.createRange();        // selection对象，兼容ie<9        //{        //   boundingHeight: 81,        //   boundingLeft: 224,        //   boundingTop: 534,        //   boundingWidth: 309,        //   htmlText: "balabalabala..",        //   offsetLeft: 222,        //   offsetTop: 532,        //   text: "党媒:台当局不重视经费仅给5万 武术在台湾快断根山西回应“演唱会损坏足球草坪”：将下“封杀令”国防部回应“建军节阅兵”传言：将适时发布进展"        // }        return {          top: selection.boundingTop,          left: selection.boundingLeft,          width: selection.boundingWidth,          height: selection.boundingHeight,          bottom: selection.boundingTop + selection.boundingHeight,          right: selection.boundingLeft + selection.boundingWidth        }      }    }    function getSelectedText() {      if (window.getSelection) {        return window.getSelection().toString();      }      else if (document.getSelection) {        return document.getSelection();      }      else if (document.selection) {        return document.selection.createRange().text;      }    }</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//at.alicdn.com/t/font_ajz0qys9mh392j4i.css&quot;&gt;&lt;/p&gt;
&lt;style&gt;
  .popover {
    position: absolute;
    display: block;
    padding: 1px;
    margin: 0;
    max-width: 400px;
    background: #fff;
    border: 1px solid #777;
    box-shadow: 1px 3px 10px #aaa;
    border-radius: 5px;
  }

  .popover&gt;.arrow {
    position: absolute;
    display: block;
    width: 0;
    height: 0;
    border: 11px solid;
    border-color: transparent;
  }

  .popover&gt;.arrow::after {
    position: absolute;
    display: block;
    content: &#39;&#39;;
    width: 0;
    height: 0;
    border: 10px solid;
    border-color: transparent;
  }

  .popover.bottom&gt;.arrow {
    border-top-width: 0px;
    border-bottom-color: #777;
    top: -11px;
    left: 50%;
    margin-left: -11px;
  }

  .popover.bottom&gt;.arrow::after {
    border-top-width: 0px;
    border-bottom-color: #fff;
    top: 1px;
    left: -10px;
  }



  .popover.top&gt;.arrow {
    border-bottom-width: 0px;
    border-top-color: #777;
    margin-left: -11px;
    left: 50%;
    top: 100%;
  }

  .popover.top&gt;.arrow::after {
    border-bottom-width: 0px;
    border-top-color: #fff;
    left: -10px;
    top: -11px;
  }

  .popover.bottom.edit&gt;.arrow {
    border-bottom-color: transparent;
  }

  .popover.bottom.edit&gt;.arrow::after {
    border-bottom-color: #262625;
  }

  .popover.top.edit&gt;.arrow {
    border-top-color: transparent;
  }

  .popover.top.edit&gt;.arrow::after {
    border-top-color: #262625;
  }
&lt;/style&gt;

&lt;h1 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h1&gt;&lt;p&gt;前两天看到一个面试题，问CSS实现三角形原理，想到以前做过气泡弹出框，气泡弹出框的小角是个三角形，因此对CSS实现三角形原理还是了解的。但是具体实现有些生疏了，因此又实现了一遍。同时注意到，使用Google划词翻译的时候，会弹出气泡框显示翻译内容，激发了我做出这种效果的欲望，可是那时候正在学习其它的东西，就先搁置先来了，不过呢，看来是天意，鬼使神差般把我链接到了&lt;a href=&quot;https://medium.com/@marziosuperina/level-up-your-dependencies-in-react-part-1-d67bb2711b51&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;medium&lt;/a&gt;。并且有下面的情形。&lt;br&gt;&lt;img src=&quot;/2017/07/01/selection-and-popover/medium.png&quot; alt=&quot;medium&quot;&gt;&lt;br&gt;这时就决定做一个玩玩。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://fsysfq.top/categories/web/"/>
    
      <category term="技术" scheme="http://fsysfq.top/categories/web/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="css" scheme="http://fsysfq.top/tags/css/"/>
    
      <category term="javascript" scheme="http://fsysfq.top/tags/javascript/"/>
    
      <category term="selection" scheme="http://fsysfq.top/tags/selection/"/>
    
      <category term="popover" scheme="http://fsysfq.top/tags/popover/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的javascript(上)</title>
    <link href="http://fsysfq.top/2017/07/01/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript-%E4%B8%8A/"/>
    <id>http://fsysfq.top/2017/07/01/你不知道的javascript-上/</id>
    <published>2017-07-01T14:06:04.000Z</published>
    <updated>2018-07-07T13:18:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天又看了一遍《你不知道的javascript（上）》，依旧收货颇多。发现书上将的一些内容，再次看的时候已经记不清楚了。一些理解有偏颇的概念，得到了重新的认识。最后讲的“行为委托”对象关联模型与面向“类”的编程思想进行了对比，作者阐述了对象关联模型在javascript中的优势，应用对象关联模型进行javascript编程更加自然、更加符合javascript语言特性。<br>下面我记载了一些，自己没有掌握的或者容易出错、容易遗忘的内容。<br><a id="more"></a></p><h1 id="作用域与闭包"><a href="#作用域与闭包" class="headerlink" title="作用域与闭包"></a>作用域与闭包</h1><p>在严格模式的程序中，<code>eval(..)</code>在运行时有其自己的词法作用域，意味着其中的声明无法<br>修改所在的作用域。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">eval</span>( str );</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">foo( <span class="string">"var a = 2"</span>);</span><br></pre></td></tr></table></figure></p><p><code>eval(..)</code>函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而<code>with</code>声明<br>实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。</p><blockquote><p>另外一个不推荐使用eval(..)和with的原因是会被严格模式所影响（限制）。with被完全<br>禁止，而在保留核心功能的前提下，间接或非安全地使用eval(..)也被禁止了。</p></blockquote><p>JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进<br>行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。</p><p>但如果引擎在代码中发现了eval(..)或with，它只能简单地假设关于标识符位置的判断都是无效<br>的，因为无法在词法分析阶段明确知道eval(..)会接收到什么代码，这些代码会如何对作用域进行<br>修改，也无法知道传递给with用来创建新词法作用域的对象的内容到底是什么。</p><p>设计的时候要遵循<code>最小特权原则</code></p><h2 id="函数声明和表达式"><a href="#函数声明和表达式" class="headerlink" title="函数声明和表达式"></a>函数声明和表达式</h2><blockquote><p>区分函数声明和表达式最简单的方法是看function关键字出现在声明中的位置（不仅仅<br>是一行代码，而是整个声明中的位置）。如果function是声明中的第一个词，那么就是一个函数<br>声明，否则就是一个函数表达式。函数声明会提升</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码片段被引擎理解为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意，var foo尽管出现在function foo()…的声明之前，但它是重复的声明（因此被忽略了），因为<br>函数声明会被提升到普通变量之前。</p></blockquote><p>一段代码及输出如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">b = c;</span><br><span class="line"></span><br><span class="line">b();</span><br><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(b);    <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(c);    <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>将上述代码稍作修改:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">b();</span><br><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(b);    <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(c);    <span class="comment">//Uncaught ReferenceError: c is not defined</span></span><br></pre></td></tr></table></figure></p><p>再次将上述代码稍作修改:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);    <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);    <span class="comment">//2</span></span><br><span class="line">    <span class="built_in">console</span>.log(c);    <span class="comment">//fuction c()&#123;...  这里c仍然是一个function 只读的。如果使用var c = 3;这里就是3了。</span></span><br><span class="line">&#125;;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure></p><p>Here’s how it works: when the interpreter at the code execution stage meets named FE, before creating FE, it creates auxiliary special object and adds it in front of the current scope chain. Then it creates FE itself at which stage the function gets the [[Scope]] property (as we know from the Chapter 4. Scope chain) — the scope chain of the context which created the function (i.e. in [[Scope]] there is that special object). After that, the name of FE is added to the special object as unique property; value of this property is the reference to the FE. And the last action is removing that special object from the parent scope chain. Let’s see this algorithm on the pseudo-code:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">specialObject = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">Scope = specialObject + Scope;</span><br><span class="line">  </span><br><span class="line">foo = <span class="keyword">new</span> FunctionExpression;</span><br><span class="line">foo.[[Scope]] = Scope;</span><br><span class="line">specialObject.foo = foo; <span class="comment">// &#123;DontDelete&#125;, &#123;ReadOnly&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">delete</span> Scope[<span class="number">0</span>]; <span class="comment">// remove specialObject from the front of scope chain</span></span><br></pre></td></tr></table></figure><h1 id="this和对象原型"><a href="#this和对象原型" class="headerlink" title="this和对象原型"></a>this和对象原型</h1><p><code>forEach</code>:<code>[1,2,3].forEach(fn,obj)</code>第二个参数obj表示fn调用时的上下文，fn中this关键字指向obj。</p><p>使用<code>new</code>来调用函数，或者发生构造函数调用时，会自动执行下面的操作。</p><ol><li>构造一个全新的对象</li><li>这个新对象会被执行[[原型]]连接</li><li>这个新对象会绑定到函数调用的this</li><li>如果函数没有返回其它对象，那么<code>new</code>表达式中的函数调用会自动返回这个新对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="comment">// 与 ECMAScript 5 最接近的</span></span><br><span class="line">        <span class="comment">// 内部 IsCallable 函数</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">          <span class="string">"Function.prototype.bind - what is trying "</span> +</span><br><span class="line">          <span class="string">"to be bound is not callable"</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">debugger</span></span><br><span class="line">      <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">        fToBind = <span class="keyword">this</span>,</span><br><span class="line">        fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">        fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> fToBind.apply(</span><br><span class="line">  <span class="comment">//这里的this，如果是通过new调用，this会指向一个对象。通过this instanceof fNOP可以判断调用的方式是直接调用还是通过new。</span></span><br><span class="line">  <span class="comment">//如果bind(null)或者bind(undefined),则相当于执行fToBind.apply(null,args)，这时this指向window。这点和原生bind不一致。仅使用this //instanceof fNOP做判断，应该更合理。</span></span><br><span class="line">  <span class="comment">//如果bind(obj),则相当于执行fToBind.apply(this,args),这时this指向新创建的对象。</span></span><br><span class="line">  <span class="comment">//MDN上现在这里已经改为this instanceof fNOP? this: oThis || this。</span></span><br><span class="line">            <span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp;</span><br><span class="line">              oThis ? <span class="keyword">this</span> : oThis  </span><br><span class="line">            ,</span><br><span class="line">            aArgs.concat(</span><br><span class="line">              <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">            )</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        ;</span><br><span class="line">      fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">      fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">      <span class="keyword">return</span> fBound;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.a = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> bar = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> baz = foo.bind(bar)</span><br><span class="line">    baz(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(bar.a);</span><br><span class="line">    <span class="keyword">var</span> baw = <span class="keyword">new</span> baz(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(baw.a);</span><br></pre></td></tr></table></figure><h2 id="判断this"><a href="#判断this" class="headerlink" title="判断this"></a>判断this</h2><p>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来<br>进行判断：</p><ol><li>函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。<br><code>var bar = new foo()</code></li><li>函数是否通过call、apply（显式绑定）或者硬绑定调用？如果是的话，this绑定的是指定的对象。<br><code>var bar = foo.call(obj2)</code></li><li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。<br><code>var bar = obj1.foo()</code></li><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。<br><code>var bar = foo()</code><br>就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白this的绑定原理了。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">foo</span>: foo &#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">a</span>: <span class="number">4</span> &#125;;</span><br><span class="line">o.foo(); <span class="comment">// 3</span></span><br><span class="line">(p.foo = o.foo)(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>赋值表达式的返回值是目标函数的引用，因此调用位置是<code>foo()</code>而不是<code>p.foo()</code>或者<code>o.foo()</code>。  </p><p><strong>注意：对于默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是<br>否处于严格模式。如果函数体处于严格模式，this会被绑定到undefined，否则this会被绑定到全局<br>对象。</strong>  </p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个箭头函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//this继承自foo()</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = foo.call( obj1 );</span><br><span class="line">bar.call( obj2 ); <span class="comment">// 2, 不是3！</span></span><br></pre></td></tr></table></figure><p>foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar（引用箭头<br>函数）的this 也会绑定到obj1，箭头函数的绑定无法被修改。（new也不行！）.</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>注意，简单基本类型（string、boolean、number、null和undefined）本身并不是对象。null有时会被当<br>作一种对象类型，但是这其实只是语言本身的一个bug，即对null执行typeof null时会返回字符<br>串”object”。1实际上，null本身是基本类型。<br>1原理是这样的，不同的对象在底层都表示为二进制，在JavaScript中二进制前三位都为0的话会被<br>判断为object类型，null的二进制表示是全0，自然前三位也是0，所以执行typeof时会返<br>回“object”</p><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><ol><li><p>Writable<br><code>writable</code>:决定是否可以修改属性的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">false</span>, <span class="comment">// not writable!</span></span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125; );</span><br><span class="line">myObject.a = <span class="number">3</span>;</span><br><span class="line">myObject.a; <span class="comment">// 2 严格模式下会报错TypeError</span></span><br></pre></td></tr></table></figure></li><li><p>Configurable<br>只要属性是可配置的，就可以使用<code>defineProperty(..)</code>来修改属性描述符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">myObject.a = <span class="number">3</span>;</span><br><span class="line">myObject.a; <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">4</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>, <span class="comment">// 不可配置！</span></span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125; );</span><br><span class="line">myObject.a; <span class="comment">// 4</span></span><br><span class="line">myObject.a = <span class="number">5</span>;</span><br><span class="line">myObject.a; <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">6</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125; ); <span class="comment">// TypeError</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">6</span>,</span><br><span class="line">  writable: <span class="literal">false</span>, <span class="comment">// 将writable由true改为false，不会报错</span></span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure></li></ol><p><code>configurable:false</code>会禁止删除这个属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  a:<span class="number">2</span> </span><br><span class="line">&#125;;</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">delete</span> myObject.a;</span><br><span class="line">myObject.a; <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125; );</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">delete</span> myObject.a;</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><ol start="3"><li>Enumerable<br>控制对象的属性是否会出现在对象的属性枚举中，比如说<code>for...in</code>循环。如果为false，这个属性不会出现在枚举中，虽然仍然可以正常访问它。</li></ol><h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><ol><li><p>对象常量<br>不可修改、重定义或者删除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"FAVORITE_NUMBER"</span>, &#123;</span><br><span class="line">  value: <span class="number">42</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure></li><li><p>禁止扩展<br>禁止一个对象添加新属性并且保留已有属性，<code>Object.preventExtensions(..)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions( myObject );</span><br><span class="line">myObject.b = <span class="number">3</span>;</span><br><span class="line">myObject.b; <span class="comment">// undefined严格模式会TypeError</span></span><br></pre></td></tr></table></figure></li><li><p>密封<br><code>Object.seal(..)</code>会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调<br>用<code>Object.preventExtensions(..)</code>并把所有现有属性标记为<code>configurable:false</code>。<br>所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性<br>的值）。</p></li><li>冻结<br><code>Object.freeze(..)</code>会创建一个冻结对象，这个方法实际上会在一个现有对象上调<br>用<code>Object.seal(..)</code>并把所有“数据访问”属性标记为<code>writable:false</code>，这样就无法修改它们的值。</li></ol><h3 id="Get"><a href="#Get" class="headerlink" title="[[Get]]"></a><code>[[Get]]</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><code>myObject.a</code>是一次属性访问，但是这条语句并不仅仅是在<code>myObjet</code>中查找名字为<code>a</code>的属性，虽然看起<br>来好像是这样。<br>在语言规范中，<code>myObject.a</code>在<code>myObject</code>上实际上是实现了<code>[[Get]]</code>操作（有点像函数调<br>用：<code>[[Get]]()</code>）。对象默认的内置<code>[[Get]]</code>操作首先在对象中查找是否有名称相同的属性，如果找到<br>就会返回这个属性的值。<br>然而，如果没有找到名称相同的属性，按照<code>[[Get]]</code>算法的定义会执行另外一种非常重要的行为。就是遍历可能存在的<code>[[Prototype]]</code>链，也就是原型链。</p><h3 id="Put"><a href="#Put" class="headerlink" title="[[Put]]"></a>[[Put]]</h3><p>如果已经存在这个属性，<code>[[Put]]</code>算法大致会检查下面这些内容。</p><ol><li>属性是否是访问描述符,如果是并且存在<code>setter</code>就调用<code>setter</code>。</li><li>属性的数据描述符中<code>writable</code>是否是<code>false</code>,如果是，在非严格模式下静默失败，在严格模式下<br>抛出<code>TypeError</code>异常。</li><li>如果都不是，将该值设置为属性的值。</li></ol><h3 id="Getter和-Setter"><a href="#Getter和-Setter" class="headerlink" title="Getter和 Setter"></a>Getter和 Setter</h3><p>对象默认的<code>[[Put]]</code>和<code>[[Get]]</code>操作分别可以控制属性值的设置和获取。</p><p>在ES5中可以使用<code>getter</code>和<code>setter</code>部分改写默认操作，但是只能应用在单个属性上，无法应用在整<br>个对象上。<code>getter</code>是一个隐藏函数，会在获取属性值时调用。<code>setter</code>也是一个隐藏函数，会在设置属<br>性值时调用。<br>当你给一个属性定义<code>getter</code>、<code>setter</code>或者两者都有时，这个属性会被定义为“访问描述符”（和“数据描<br>述符”相对）。<br>对于访问描述符来说，JavaScript会忽略它们的<code>value</code>和<code>writable</code>特性，取而代之的是<br>关心<code>set</code>和<code>get</code>（还有<code>configurable</code>和<code>enumerable</code>）特性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line"><span class="comment">//给a定义一个getter</span></span><br><span class="line">get a() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(</span><br><span class="line">  myObject, <span class="comment">// 目标对象</span></span><br><span class="line">  <span class="string">"b"</span>, <span class="comment">// 属性名</span></span><br><span class="line">  &#123; <span class="comment">// 描述符</span></span><br><span class="line">  <span class="comment">// 给b设置一个getter</span></span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="number">2</span> &#125;,</span><br><span class="line">  <span class="comment">// 确保b会出现在对象的属性列表中</span></span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br><span class="line">myObject.b; <span class="comment">// 4</span></span><br><span class="line"><span class="comment">//也可以使用字面量形式</span></span><br><span class="line"><span class="keyword">var</span> myObject2 = &#123;</span><br><span class="line">  <span class="comment">// 给 a 定义一个getter</span></span><br><span class="line">  get a() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._a_;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 给 a 定义一个setter</span></span><br><span class="line">  set a(val) &#123;</span><br><span class="line">  <span class="keyword">this</span>._a_ = val * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObject2.a = <span class="number">2</span>;</span><br><span class="line">myObject2.a; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><blockquote><p>遍历数组下标时采用的是数字顺序（for循环或者其他迭代器），但是遍历对象属性时的顺<br>序是不确定的，在不同的JavaScript引擎中可能不一样。因此，在不同的环境中需要保证一致性<br>时，一定不要相信任何观察到的顺序，它们是不可靠的。</p></blockquote><p>es6 增加的<code>for...of</code>可以直接遍历数组值。（如果对象定义了迭代器的话也可以遍历对象）<br>数组有内置的@@iterator，因此for..of可以直接应用在数组上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ];</span><br><span class="line"><span class="keyword">var</span> it = myArray[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">it.next(); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; done:true &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>@@iterator本身并不是一个迭代器对象，而是一个返回迭代器对象的函数——这点非常精妙并且非常重要。</p></blockquote><p>可以给想遍历的对象定义@@iterator<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  b: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="built_in">Symbol</span>.iterator, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> ks = <span class="built_in">Object</span>.keys( o );</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: o[ks[idx++]];</span><br><span class="line">          done: (idx &gt; ks.length)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 手动遍历myObject</span></span><br><span class="line"><span class="keyword">var</span> it = myObject[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">it.next(); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br><span class="line"><span class="comment">// 用for..of遍历myObject</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> myObject) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log( v );</span><br><span class="line">&#125; <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>随机数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> randoms = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="built_in">Math</span>.random() &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> randoms_pool = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> randoms) &#123;</span><br><span class="line">  randoms_pool.push( n );</span><br><span class="line">  <span class="keyword">if</span>(randoms_pool.length === <span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="混合对象“类”"><a href="#混合对象“类”" class="headerlink" title="混合对象“类”"></a>混合对象“类”</h2><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><code>Object.prototype</code><br>所有普通的[[Protorype]]链最终都会执行内置的<code>Object.prototype</code>.</p><h3 id="属性设置和屏蔽"><a href="#属性设置和屏蔽" class="headerlink" title="属性设置和屏蔽"></a>属性设置和屏蔽</h3><p><code>myObject.foo=&#39;bar&#39;</code>;</p><ol><li>如果在[[Prototype]]链上层存在名为foo的普通数据访问属性（参见第3章）并且没有被标记为<br>只读（writable:false），那就会直接在myObject中添加一个名为foo的新属性，它是屏蔽属性。</li><li>如果在[[Prototype]]链上层存在foo，但是它被标记为只读（writable:false），那么无法修改已<br>有属性或者在myObject上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条<br>赋值语句会被忽略。总之，不会发生屏蔽。</li><li>如果在[[Prototype]]链上层存在foo并且它是一个setter（参见第3章），那就一定会调用这个<br>setter。foo不会被添加到（或者说屏蔽于）myObject，也不会重新定义foo这个setter。<br>如果你希望在第二种和第三种情况下也屏蔽foo，那就不能使用=操作符来赋值，而是使<br>用Object.defineProperty(..)来向myObject添加foo。</li></ol><blockquote><p>这看起来有点奇怪，myObject对象竟然会因为其他对象中有一个只读foo就不能包含foo属性。更奇怪的是，这个<br>限制只存在于=赋值中，使用Object.defineProperty(..)并不会受到影响。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherObject = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject );</span><br><span class="line">anotherObject.a; <span class="comment">// 2</span></span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br><span class="line">anotherObject.hasOwnProperty( <span class="string">"a"</span> ); <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">"a"</span> ); <span class="comment">// false</span></span><br><span class="line">myObject.a++; <span class="comment">// 隐式屏蔽！</span></span><br><span class="line">anotherObject.a; <span class="comment">// 2</span></span><br><span class="line">myObject.a; <span class="comment">// 3</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">"a"</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在普通的函数调用前加上<code>new</code>关键字之后，就会把这个函数调用变成一个“构造函数调用”。实际上，new会劫持所有普通函数并用构造对象的形式调用它。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NothingSpecial</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"Don't mind me!"</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> NothingSpecial();</span><br><span class="line"><span class="comment">// "Don't mind me!"</span></span><br><span class="line">a; <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure></p><p><code>NothingSpecial</code>只是一个普通的函数，但是使用<code>new</code>调用时，它就会构造一个对象并赋值给a，这看<br>起来像是<code>new</code>的一个副作用（无论如何都会构造一个对象）。这个调用是一个构造函数调用，但<br>是<code>NothingSpecial</code>本身并不是一个构造函数。<br>换句话说，在JavaScript中对于“构造函数”最准确的解释是，所有带<code>new</code>的函数调用。<br>函数不是构造函数，但是当且仅当使用<code>new</code>时，函数调用会变成“构造函数调用”。</p><p><code>constructor</code>:<code>Foo.prototype</code>的<code>.constructor</code>属性只是<code>Foo</code>函数在声明时的默认属性。可以被更改，不可枚举。</p><h2 id="（原型）继承"><a href="#（原型）继承" class="headerlink" title="（原型）继承"></a>（原型）继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.myName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name,label</span>) </span>&#123;</span><br><span class="line">  Foo.call( <span class="keyword">this</span>, name );</span><br><span class="line">  <span class="keyword">this</span>.label = label;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个新的Bar.prototype对象并关联到Foo.prototype</span></span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create( Foo.prototype );</span><br><span class="line"><span class="comment">// 注意！现在没有Bar.prototype.constructor了</span></span><br><span class="line"><span class="comment">// 如果你需要这个属性的话可能需要手动修复一下它</span></span><br><span class="line">Bar.prototype.myLabel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar( <span class="string">"a"</span>, <span class="string">"Obj a"</span> );</span><br><span class="line">a.myName();<span class="comment">//"a"</span></span><br><span class="line">a.myLabel();<span class="comment">//"obj a"</span></span><br></pre></td></tr></table></figure><p><code>Object.create(..)</code>会创建一个‘新’对象并把新对象内部的<code>[[prototype]]</code>关联到你指定的对象。<br>在声明<code>function Bar(){..}</code>的时候，和其他函数一样，<code>Bar</code>会有一个<code>.prototype</code>关联到默认的对象，但是这个对象并不是我们想要的<code>Foo.prototype</code>。因此创建了一个新的对象并把它关联到我们希望的对象上，直接把原始的关联对象抛弃掉。<br>注意，下面这两种方式是常见的错误做法，实际上他们都存在一些问题：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Bar.prototype = Foo.prototype;</span><br><span class="line"><span class="comment">//基本满足需求，但是可能会产生一些副作用。</span></span><br><span class="line">Bar.prototype = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure></p><p><code>Bar.prototype = Foo.prototype</code>并不会创建一个关联到<code>Bar.prototype</code>的新对象，它只是<br>让<code>Bar.prototype</code>直接引用<code>Foo.prototype</code>对象。因此当你执行类似<code>Bar.prototype.myLabel = ...</code>的赋<br>值语句时会直接修改<code>Foo.prototype</code>对象本身。显然这不是你想要的结果，否则你根本不需要<code>Bar</code>对<br>象，直接使用<code>Foo</code>就可以了，这样代码也会更简单一些。</p><p><code>Bar.prototype = new Foo()</code>的确会创建一个关联到<code>Bar.prototype</code>的新对象。但是它使用了<code>Foo(..)</code>的‘构造函数调用’，如果函数<code>Foo</code>有一些副作用（比如写日志、修改状态、注册到其它对象、给<code>this</code>添加数据属性，等等）的话，就会影响到<code>Bar()</code>的后代，后果不堪设想。</p><p>使用<code>Object.create(..)</code>的唯一的缺点就是需要创建一个新的对象，然后把旧对象抛弃掉，不能直接修改已有的默认对象。</p><p>在ES6之前，我们只能通过设置<code>.__proto__</code>属性来实现，但是这个方法并不是标准并且无法兼容所有浏览器。ES6添加了<br>辅助函数<code>Object.setPrototypeOf(..)</code>，可以用标准并且可靠的方法来修改关联。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype);</span><br><span class="line"><span class="comment">//ES6 开始可以直接修改现有的Bar.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeof( Bar.prototype, Foo.prototype);</span><br></pre></td></tr></table></figure></p><p>如果忽略掉<code>Object.create(..)</code>方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它实际<br>上比ES6及其之后的方法更短而且可读性更高。不过无论如何，这是两种完全不同的语法。</p><p><code>instanceof</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.blah = ...;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line">a <span class="keyword">instanceof</span> Foo</span><br></pre></td></tr></table></figure></p><p><code>instanceof</code>:判断在对象<code>a</code>的整条<code>[[prototype]]</code>链中是否有指向<code>Foo.prototype</code>的对象。</p><p>可惜，这个方法只能处理对象（<code>a</code>）和函数（带<code>.prototype</code>引用的<code>Foo</code>）之间的关系。如果你想判断两<br>个对象（比如<code>a</code>和<code>b</code>）之间是否通过<code>[[Prototype]]</code>链关联，只用<code>instanceof</code>无法实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo.prototype.isPrototypeOf(a);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><code>isPrototype</code>:判断在<code>a</code>的整条<code>[[Prototype]]</code>链中是否出现过<code>Foo.prototype</code>.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非常简单：b是否出现在c的[[Prototype]]链中？</span></span><br><span class="line">b.isPrototypeOf( c );</span><br></pre></td></tr></table></figure></p><p><code>Object.getPrototypeOf(a)</code>:获取<code>a</code>的<code>[[Prototype]]</code>链。</p><p><code>a.__proto__ === Foo.prototype; // true</code>,<code>.__proto__</code>（在ES6之前并不是标准！）引用对象内部的<code>[[Prototype]]</code>对象。</p><h2 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h2><p><code>[[Prototype]]</code>机制就是存在于对象中的一个内部链接，它会引用其他对象。<br>通常来说，这个链接的作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就会继续<br>在<code>[[Prototype]]</code>关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查<br>找它的<code>[[Prototype]]</code>，以此类推。这一系列对象的链接被称为“原型链”。</p><h3 id="创建关联"><a href="#创建关联" class="headerlink" title="创建关联"></a>创建关联</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherObject = &#123;</span><br><span class="line">a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject, &#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="number">3</span></span><br><span class="line">  &#125;,</span><br><span class="line">  c: &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">myObject.hasOwnProperty( <span class="string">"a"</span> ); <span class="comment">// false</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">"b"</span> ); <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">"c"</span> ); <span class="comment">// true</span></span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br><span class="line">myObject.b; <span class="comment">// 3</span></span><br><span class="line">myObject.c; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h3 id="关联关系是备用"><a href="#关联关系是备用" class="headerlink" title="关联关系是备用"></a>关联关系是备用</h3><p>看起来对象之间的关联关系是处理“缺失”属性或者方法时的一种备用选项。这个说法有点道理，但<br>是我认为这并不是<code>[[Prototype]]</code>的本质。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> anotherObject = &#123;</span><br><span class="line">  cool: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"cool!"</span> );</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject );</span><br><span class="line">myObject.cool(); <span class="comment">// "cool!"</span></span><br></pre></td></tr></table></figure></p><p>由于存在<code>[[Prototype]]</code>机制，这段代码可以正常工作。但是如果你这样写只是为了让<code>myObject</code>在无<br>法处理属性或者方法时可以使用备用的<code>anotherObject</code>，那么你的软件就会变得有点“神奇”，而且很<br>难理解和维护。<br>但是你可以让你的API设计不那么“神奇”，同时仍然能发挥<code>[[Prototype]]</code>关联的威力：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherObject = &#123;</span><br><span class="line">  cool: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"cool!"</span> );</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject );</span><br><span class="line">myObject.doCool = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.cool(); <span class="comment">// 内部委托！</span></span><br><span class="line">&#125;;</span><br><span class="line">myObject.doCool(); <span class="comment">// "cool!"</span></span><br></pre></td></tr></table></figure></p><p>内部委托比起直接委托可以让API接口设计更加清晰。</p><h1 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h1><p>“类”和“委托”这两种设计模式，在思维模型方面的区别。<br>典型的面向对象风格：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.me = who;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.identify =<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  Foo.call( <span class="keyword">this</span>, who );</span><br><span class="line">&#125; </span><br><span class="line">Bar.prototype =<span class="built_in">Object</span>.create( Foo.prototype );</span><br><span class="line">Bar.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">"Hello, "</span> + <span class="keyword">this</span>.identify() + <span class="string">"."</span> );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> Bar( <span class="string">"b1"</span> );</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> Bar( <span class="string">"b2"</span> );</span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure></p><p>对象关联风格：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Foo = &#123;</span><br><span class="line">init: <span class="function"><span class="keyword">function</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.me = who;</span><br><span class="line">&#125;,</span><br><span class="line">identify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Bar = <span class="built_in">Object</span>.create( Foo );</span><br><span class="line">Bar.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert( <span class="string">"Hello, "</span> + <span class="keyword">this</span>.identify() + <span class="string">"."</span> );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Object</span>.create( Bar );</span><br><span class="line">b1.init( <span class="string">"b1"</span> );</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="built_in">Object</span>.create( Bar );</span><br><span class="line">b2.init( <span class="string">"b2"</span> );</span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总问言之，javascript中对象关联比类风格的代码更加简洁（而且功能相同）<br>行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript<br>的<code>[[Prototype]]</code>机制本质上就是行为委托机制。也就是说，我们可以选择在JavaScript中努力实现<br>类机制，也可以拥抱更自然的<code>[[Prototype]]</code>委托机制。<br>对象关联（对象之间相互关联）是一种编码风格，它倡导的是直接创建和关联对象，不把他们抽象成类。对象关联可以用基于<code>[[prototype]]</code>的行为委托自然的实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天又看了一遍《你不知道的javascript（上）》，依旧收货颇多。发现书上将的一些内容，再次看的时候已经记不清楚了。一些理解有偏颇的概念，得到了重新的认识。最后讲的“行为委托”对象关联模型与面向“类”的编程思想进行了对比，作者阐述了对象关联模型在javascript中的优势，应用对象关联模型进行javascript编程更加自然、更加符合javascript语言特性。&lt;br&gt;下面我记载了一些，自己没有掌握的或者容易出错、容易遗忘的内容。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://fsysfq.top/categories/web/"/>
    
      <category term="技术" scheme="http://fsysfq.top/categories/web/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="javascript" scheme="http://fsysfq.top/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>http总结</title>
    <link href="http://fsysfq.top/2017/07/01/http%E6%80%BB%E7%BB%93/"/>
    <id>http://fsysfq.top/2017/07/01/http总结/</id>
    <published>2017-07-01T13:52:52.000Z</published>
    <updated>2018-07-07T13:18:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Get和Post方法区别"><a href="#Get和Post方法区别" class="headerlink" title="Get和Post方法区别"></a>Get和Post方法区别</h1><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p><ol><li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连。如userInfo.php?id=17065&amp;name=test.POST方法是把提交的数据放在HTTP包的Body中。</li><li>GET提交的数据大小有限制（因为浏览器URL的长度有限制），而POST方法提交的数据没有限制。</li><li>GET方式提交数据会有安全问题。</li></ol><h1 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h1><blockquote><p><a href="http://mp.weixin.qq.com/s/tluGR6Xc2tCjtaOLWO9q6Q" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/tluGR6Xc2tCjtaOLWO9q6Q</a><br><a href="http://www.cnblogs.com/wakey/p/4241516.html" target="_blank" rel="noopener">http://www.cnblogs.com/wakey/p/4241516.html</a></p></blockquote><p>Cache-Control即可以用于请求头，也可以用于响应头。响应头是重点掌握内容。<br>它控制着两个缓存：本地缓存（私有缓存）和共享缓存。<br>本地缓存，是指在客户端本地机器中的缓存。站在开发者的角度，它并不完全受你的控制，通常浏览器会自己决定是否把某些内容放到缓存中，这意味着：不要依赖于本地缓存。<br>共享缓存，处于客户端和服务器之间的缓存。即 CDN。你对共享缓存拥有绝对的控制，应该好好地利用它。<br><a id="more"></a><br>Cache-Control有三种属性：缓冲能力、过期时间和二次验证<br>首先是缓冲能力，它关注的是缓存到什么地方，和是否应该被缓存。他的几个重要的属性是：</p><ul><li>private:表示它只应该存在本地缓存</li><li>public:表示它既可以存在共享缓存，也可以被存在本地缓存</li><li>no-cache:表示不论是本地缓存还是共享缓存，在使用它以前必须用缓存里的值重新验证。</li><li>no-store:表示不允许被缓存<br>第二个是过期时间，很显然它关注的是内容可以被缓存多久。它的几个重要的属性是：</li><li><code>max-age = &lt;seconds&gt;</code>:设置缓存时间，单位为秒。本地和共享可以使用。</li><li><code>s-maxage = &lt;seconds&gt;</code>:覆盖<code>max-age</code>属性。只在共享缓存中起作用。<br>最后一个是二次验证，表示精细控制。它的几个重要属性是：</li><li>immutable:表示文档是不能更改的。</li><li>must-revalidate:表示客户端必须检查代理服务器上是否存在，即时已经本地缓存了也要检查。</li><li>proxy-revalidata:表示共享缓存必须要检查源是否存在，即使已经有缓存。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public max-age=<span class="number">3600</span></span><br><span class="line">Cache-Control: private immutable</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Cache-Control: public max-age=<span class="number">3600</span> s-maxage=<span class="number">7200</span></span><br><span class="line">Cache-Control: public max-age=<span class="number">3600</span> proxy-revalidate</span><br></pre></td></tr></table></figure></li></ul><p>上面的意思：</p><ol><li>本地缓存和 CDN 缓存均缓存 1 小时；</li><li>不能缓存在 CDN，只能缓存在本地。并且一旦被缓存了，则不能被更新；</li><li>不能缓存。如果一定要缓存的话，确保对其进行了二次验证；</li><li>本地缓存 1 小时，CDN 上缓存 2 小时；</li><li>本地和 CDN 均缓存 1 小时。但是如果 CDN 收到请求，则尽管已经缓存了 1 小时，还是要检查源中文档是否已经被改变。</li></ol><h1 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h1><p>ETag是实体标签（Entity Tag）的缩写， 根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。<br>ETag是Web服务端产生的，然后发给浏览器客户端。浏览器客户端是不用关心Etag是如何产生的。<br>为什么使用ETag呢？ 主要是为了解决Last-Modified 无法解决的一些问题。</p><ol><li>某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。</li><li>某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。</li><li>一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。</li></ol><h1 id="浏览器不使用缓存"><a href="#浏览器不使用缓存" class="headerlink" title="浏览器不使用缓存"></a>浏览器不使用缓存</h1><p>CTRL+F5强制刷新浏览器，或者设置IE。  可以让浏览器不使用缓存。</p><ol><li>浏览器发送Http request, 给Web 服务器， header中带有Cache-Control: no-cache.   明确告诉Web服务器，客户端不使用缓存。 </li><li>Web服务器将把最新的文档发送给浏览器客户端.<br>Pragma: no-cache的作用和Cache-Control: no-cache一模一样。 都是不使用缓存。<br>Pragma: no-cache 是HTTP 1.0中定义的， 所以为了兼容HTTP 1.0. 所以会同时使用Pragma: no-cache和Cache-Control: no-cache</li></ol><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><blockquote><p><a href="http://www.cnblogs.com/wakey/p/4241526.html" target="_blank" rel="noopener">http://www.cnblogs.com/wakey/p/4241526.html</a>  </p></blockquote><p>204    No Content(没有内容)    Response中包含一些Header和一个状态行， 但不包括实体的主题内容（没有response body）<br>302    Found（已找到）    与状态码301类似。但这里的移除是临时的。 客户端会使用Location中给出的URL，重新发送新的HTTP request。<br>304    Not Modified（未修改）    客户的缓存资源是最新的， 要客户端使用缓存<br>401    Unauthorized（未授权）    需要客户端对自己认证<br>403    Forbidden（禁止）    请求被服务器拒绝了<br>404    Not Found（未找到）    未找到资源<br>407    Proxy Authentication Required(要求进行代理认证)    与状态码401类似， 用于需要进行认证的代理服务器  </p><h2 id="206-Partial-Content-部分内容"><a href="#206-Partial-Content-部分内容" class="headerlink" title="206 Partial Content(部分内容)"></a>206 Partial Content(部分内容)</h2><p>206状态码代表服务器已经成功处理了部分GET请求（只有发送GET 方法的request, web服务器才可能返回206），<br>应用场景：</p><ol><li>FlashGet, 迅雷或者HTTP下载工具都是使用206状态码来实现断点续传</li><li>将以个大文档分解为多个下载段同时下载 比如，在线看视频  </li></ol><h2 id="400-Bad-Request（坏请求"><a href="#400-Bad-Request（坏请求" class="headerlink" title="400 Bad Request（坏请求)"></a>400 Bad Request（坏请求)</h2><p>发送的Request中的数据有错误(比如：表单有错误，Cookie有错误)，  这个我们也经常见到。   </p><h2 id="411-Length-Required（要求长度指示）"><a href="#411-Length-Required（要求长度指示）" class="headerlink" title="411 Length Required（要求长度指示）"></a>411 Length Required（要求长度指示）</h2><p>服务器要求在Request中包含Content-Length。<br>当浏览器使用Post方法，发送数据给Web服务器时， 必须要有Content-Length。这样Web服务器才知道你要发送多少数据，否则Web服务器会返回411状态码<br>实例： 发送一个Post方法的Request 给<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>.   Request中没有Content-Length</p><h2 id="413-Request-Entity-Too-Large（请求实体太大）"><a href="#413-Request-Entity-Too-Large（请求实体太大）" class="headerlink" title="413 Request Entity Too Large（请求实体太大）"></a>413 Request Entity Too Large（请求实体太大）</h2><p>作用：客户端发送的实体主体部分比服务器能够或者希望处理的要大。  一般情况下我们看不到这个状态码。 因为浏览器不会发送太大的数据给网站，但是机器人可能会。<br>实例: 用post方法发送一个大文件(100MB以上)给<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></p><h2 id="414-Request-URI-Too-Long-请求URI太长"><a href="#414-Request-URI-Too-Long-请求URI太长" class="headerlink" title="414 Request URI Too Long(请求URI太长)"></a>414 Request URI Too Long(请求URI太长)</h2><p>就是说Request URI太长， 一般浏览器本身对URI的长度就会有限制，所以不会发送URI很长的Request. 我们平常是根本看不到414错误的。 但是机器人可以发送很长URI。  </p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>可以大致把Cookie分为2类： 回话cookie和持久cookie<br>会话cookie: 是一种临时的cookie，它记录了用户访问站点时的设置和偏好，关闭浏览器，会话cookie就被删除了<br>持久cookie: 存储在硬盘上，（不管浏览器退出，或者电脑重启，持久cookie都存在）， 持久cookie有过期时间</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Get和Post方法区别&quot;&gt;&lt;a href=&quot;#Get和Post方法区别&quot; class=&quot;headerlink&quot; title=&quot;Get和Post方法区别&quot;&gt;&lt;/a&gt;Get和Post方法区别&lt;/h1&gt;&lt;p&gt;Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;amp;相连。如userInfo.php?id=17065&amp;amp;name=test.POST方法是把提交的数据放在HTTP包的Body中。&lt;/li&gt;
&lt;li&gt;GET提交的数据大小有限制（因为浏览器URL的长度有限制），而POST方法提交的数据没有限制。&lt;/li&gt;
&lt;li&gt;GET方式提交数据会有安全问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;Cache-Control&quot;&gt;&lt;a href=&quot;#Cache-Control&quot; class=&quot;headerlink&quot; title=&quot;Cache-Control&quot;&gt;&lt;/a&gt;Cache-Control&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s/tluGR6Xc2tCjtaOLWO9q6Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mp.weixin.qq.com/s/tluGR6Xc2tCjtaOLWO9q6Q&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/wakey/p/4241516.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/wakey/p/4241516.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Cache-Control即可以用于请求头，也可以用于响应头。响应头是重点掌握内容。&lt;br&gt;它控制着两个缓存：本地缓存（私有缓存）和共享缓存。&lt;br&gt;本地缓存，是指在客户端本地机器中的缓存。站在开发者的角度，它并不完全受你的控制，通常浏览器会自己决定是否把某些内容放到缓存中，这意味着：不要依赖于本地缓存。&lt;br&gt;共享缓存，处于客户端和服务器之间的缓存。即 CDN。你对共享缓存拥有绝对的控制，应该好好地利用它。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="协议" scheme="http://fsysfq.top/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="http" scheme="http://fsysfq.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>连续发送ajax</title>
    <link href="http://fsysfq.top/2017/06/25/%E8%BF%9E%E7%BB%AD%E5%8F%91%E9%80%81ajax/"/>
    <id>http://fsysfq.top/2017/06/25/连续发送ajax/</id>
    <published>2017-06-25T14:47:42.000Z</published>
    <updated>2018-07-06T06:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>测试全局一个XMLHttpRequest对象，用来发送ajax请求，会出现的问题。<br>加深对ajax的认识，以及chrome一个请求的timing分析。<br>分析过程如下</p><h1 id="服务器端php-apache"><a href="#服务器端php-apache" class="headerlink" title="服务器端php+apache"></a>服务器端php+apache</h1><p>作用是客户端发送post请求数据（json格式），根据发送的来请求进行休眠（便于观察），然后直接返回请求内容。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"Access-control-allow-origin:*"</span>);<span class="comment">//这里我是测试的允许跨域</span></span><br><span class="line">$str = file_get_contents(<span class="string">'php://input'</span>); <span class="comment">//这里得到字符串</span></span><br><span class="line">$data = json_decode($str);<span class="comment">//转成JSON对象</span></span><br><span class="line">sleep($data-&gt;sleepTime);<span class="comment">//休眠，便于观察</span></span><br><span class="line"><span class="comment">//echo $data-&gt;masterIP;//如果要操作数据可以这样操作</span></span><br><span class="line"><span class="keyword">echo</span> json_encode($data); <span class="comment">//json_encode又转成字符串</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h2 id="使用一个XMLHttpRequest对象发送ajax请求"><a href="#使用一个XMLHttpRequest对象发送ajax请求" class="headerlink" title="使用一个XMLHttpRequest对象发送ajax请求"></a>使用一个XMLHttpRequest对象发送ajax请求</h2><p>如下创建一个全局的<code>xmlHttp</code>对象:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttp = GetXmlHttpObject();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetXmlHttpObject</span>(<span class="params"></span>) //<span class="title">check</span> <span class="title">browser</span> <span class="title">support</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xmlHttp = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Firefox, Opera 8.0+, Safari</span></span><br><span class="line">    xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// Internet Explorer</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Msxml2.XMLHTTP"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> xmlHttp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发送请求方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send1</span>(<span class="params">n, sleepTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">"http://localhost/echo.php"</span>;</span><br><span class="line">  xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlHttp.readyState == <span class="number">4</span> &amp;&amp; xmlHttp.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(xmlHttp.responseText);<span class="comment">//解析为json对象</span></span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xmlHttp.open(<span class="string">"POST"</span>, url, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">var</span> data = &#123;</span><br><span class="line">    n: n,</span><br><span class="line">    sleepTime: sleepTime,</span><br><span class="line">    masterIP: <span class="string">"172.20.1.1"</span>,</span><br><span class="line">    slavesIP: [<span class="string">"172.20.1.2"</span>, <span class="string">"172.20.1.3"</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> sendData = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">  xmlHttp.send(sendData);<span class="comment">//发送</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发送多次请求：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* n: 发送请求次数</span></span><br><span class="line"><span class="comment">* sleepTime: 控制服务器sleep时间</span></span><br><span class="line"><span class="comment">* tick: 控制每隔多久发送一次请求 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exec1</span>(<span class="params">n, sleepTime, tick</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    setTimeout((<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; send1(i, sleepTime); &#125;</span><br><span class="line">    &#125;)(i), tick * i * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每隔一秒发送一次请求，服务器端休眠一秒。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec1(<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>结果：<br><img src="/2017/06/25/连续发送ajax/globalxhr5times.png" alt="globalxhr5times"><br>可以发现前四次请求都被取消了，只有最后一次成功。并且最后一次请求用时1.01s。<br>当然如果连续发送前四次也会被取消。 </p><p>每隔1.01秒发送一次请求，服务器端休眠一秒。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec1(<span class="number">5</span>,<span class="number">1</span>,<span class="number">1.01</span>);</span><br></pre></td></tr></table></figure></p><p>结果：<br><img src="/2017/06/25/连续发送ajax/globalxhr5times_success.png" alt="globalxhr5times_success"><br>显然请求都成功了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>同一个XMLHttpRequest对象，可以多次发送ajax请求，但是不能同时处理多个请求。<br>可以有用处：通过ajax方式进行页面无刷新更新的时候。通过ajax返回的数据插入页面这种方式更新页面内容，导航切换过快上一个请求还没返回，就会被取消，不会发生过一段时间页面出现上一次请求的内容。（我就遇到过着样的问题）。</p><h2 id="通过创建多个对象同时发送ajax请求"><a href="#通过创建多个对象同时发送ajax请求" class="headerlink" title="通过创建多个对象同时发送ajax请求"></a>通过创建多个对象同时发送ajax请求</h2><p>代码如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">send2</span>(<span class="params">n, sleepTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xmlHttp = GetXmlHttpObject();</span><br><span class="line">  <span class="keyword">var</span> sparkServerIP = <span class="string">"172.20.1.1"</span>;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">"http://localhost/echo.php"</span>;</span><br><span class="line">  xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlHttp.readyState == <span class="number">4</span> &amp;&amp; xmlHttp.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(xmlHttp.responseText);<span class="comment">//解析为json对象</span></span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xmlHttp.open(<span class="string">"POST"</span>, url, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">var</span> data = &#123;</span><br><span class="line">    n: n,</span><br><span class="line">    sleepTime: sleepTime,</span><br><span class="line">    masterIP: <span class="string">"172.20.1.1"</span>,</span><br><span class="line">    slavesIP: [<span class="string">"172.20.1.2"</span>, <span class="string">"172.20.1.3"</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> sendData = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">  xmlHttp.send(sendData);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">exec2</span>(<span class="params">n, sleepTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    send2(i, sleepTime)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">exec2(<span class="number">15</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>网络请求图：<br><img src="/2017/06/25/连续发送ajax/15TimesXhr.png" alt="15TimesXhr"><br>绿条部分可以看出这15次请求是分拨进行的，6个一波。说明chrome xhr请求并发量为6。 灰色线条表示：chrome等待发出请求。<br><img src="/2017/06/25/连续发送ajax/chromeTimeLine.png" alt="chromeTimeLine"><br>时间线中stalled停滞不前，表示chrome请求发出前的等待时间。<br>多次发送同一个请求，前6次会进行dns查询和初始化连接，然后的请求会重复利用已经初始化的网络请求对象。<br>在request、response阶段：<br>包括:请求时间，waiting（ttfb）时间，和content download时间。<br>waiting：服务端处理时间,即受到请求到输出响应头这段时间。<br>content download：服务器处理完进行响应，客户端下载时间。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>同一个客户端通过ajax向apache服务器中同一个php文件发出请求，apache会创建不同的进程进行响应。</li><li>同一个xmlHttprequest实例，连续发出请求时，如果前一个请求没有返回响应，则前一个ajax请求会被取消。如果前一个请求返回，后一个请求不会取消前一个请求。</li><li>如果要同时发送多个请求要创建多个xhr对象。</li><li>chrome浏览器能并发进行6个http请求。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h1&gt;&lt;p&gt;测试全局一个XMLHttpRequest对象，用来发送ajax请求，会出现的问题。&lt;br&gt;加深对ajax的认识，以及chrome一个请求的timing分析。&lt;br&gt;分析过程如下&lt;/p&gt;
&lt;h1 id=&quot;服务器端php-apache&quot;&gt;&lt;a href=&quot;#服务器端php-apache&quot; class=&quot;headerlink&quot; title=&quot;服务器端php+apache&quot;&gt;&lt;/a&gt;服务器端php+apache&lt;/h1&gt;&lt;p&gt;作用是客户端发送post请求数据（json格式），根据发送的来请求进行休眠（便于观察），然后直接返回请求内容。&lt;br&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;header(&lt;span class=&quot;string&quot;&gt;&quot;Access-control-allow-origin:*&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//这里我是测试的允许跨域&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$str = file_get_contents(&lt;span class=&quot;string&quot;&gt;&#39;php://input&#39;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//这里得到字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$data = json_decode($str);&lt;span class=&quot;comment&quot;&gt;//转成JSON对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sleep($data-&amp;gt;sleepTime);&lt;span class=&quot;comment&quot;&gt;//休眠，便于观察&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//echo $data-&amp;gt;masterIP;//如果要操作数据可以这样操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;echo&lt;/span&gt; json_encode($data); &lt;span class=&quot;comment&quot;&gt;//json_encode又转成字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://fsysfq.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="http://fsysfq.top/categories/%E6%8A%80%E6%9C%AF/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Ajax" scheme="http://fsysfq.top/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>react-router-analysis</title>
    <link href="http://fsysfq.top/2017/06/17/react-router-analysis/"/>
    <id>http://fsysfq.top/2017/06/17/react-router-analysis/</id>
    <published>2017-06-17T10:22:23.000Z</published>
    <updated>2018-07-06T06:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接</p><blockquote><p><a href="https://reacttraining.com/react-router/web/api/BrowserRouter" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/api/BrowserRouter</a><br><a href="https://github.com/ReactTraining/history" target="_blank" rel="noopener">https://github.com/ReactTraining/history</a></p></blockquote><p><strong>版本：react-router V4</strong></p><h1 id="history"><a href="#history" class="headerlink" title="history"></a>history</h1><p>react-router官方文档有说<code>history is mutable</code>。<br>给的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="comment">// will be true</span></span><br><span class="line">    <span class="keyword">const</span> locationChanged = nextProps.location !== <span class="keyword">this</span>.props.location</span><br><span class="line"></span><br><span class="line">    <span class="comment">// INCORRECT, will *always* be false because history is mutable.</span></span><br><span class="line">    <span class="keyword">const</span> locationChanged = nextProps.history.location !== <span class="keyword">this</span>.props.history.location</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;Route component=&#123;Comp&#125;/&gt;</span><br></pre></td></tr></table></figure></p><p>原因是：<code>&lt;Route&gt;</code>向<code>Comp</code>传入props包括<code>match, location, history, staticContext</code>(见<code>&lt;Route&gt;</code>分析),<code>history</code>是从<code>context</code>上下文中获取得到，一直是对同一个对象的引用，所以一直<code>nextProps.history.location === this.props.history.location</code>，而<code>nextProps.location !== this.props.location</code>，是因为在<code>history</code>库里面<code>history.location</code>的计算方式，是重新计算<code>location</code>对象。<code>const location = createLocation(path, state, createKey(), history.location)</code>。具体见<a href="https://github.com/ReactTraining/history/blob/master/modules/LocationUtils.js" target="_blank" rel="noopener">https://github.com/ReactTraining/history/blob/master/modules/LocationUtils.js</a><br><a id="more"></a></p><h2 id="createHistory-props"><a href="#createHistory-props" class="headerlink" title="createHistory(props={})"></a>createHistory(props={})</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">createBrowserHistory(&#123;</span><br><span class="line">  basename: <span class="string">''</span>,             <span class="comment">// The base URL of the app (see below)</span></span><br><span class="line">  forceRefresh: <span class="literal">false</span>,      <span class="comment">// Set true to force full page refreshes</span></span><br><span class="line">  keyLength: <span class="number">6</span>,             <span class="comment">// The length of location.key</span></span><br><span class="line">  <span class="comment">// A function to use to confirm navigation with the user (see below)</span></span><br><span class="line">  getUserConfirmation: <span class="function">(<span class="params">message, callback</span>) =&gt;</span> callback(<span class="built_in">window</span>.confirm(message))</span><br><span class="line">&#125;)</span><br><span class="line">createMemoryHistory(&#123;</span><br><span class="line">  initialEntries: [ <span class="string">'/'</span> ],  <span class="comment">// The initial URLs in the history stack</span></span><br><span class="line">  initialIndex: <span class="number">0</span>,          <span class="comment">// The starting index in the history stack</span></span><br><span class="line">  keyLength: <span class="number">6</span>,             <span class="comment">// The length of location.key</span></span><br><span class="line">  <span class="comment">// A function to use to confirm navigation with the user. Required</span></span><br><span class="line">  <span class="comment">// if you return string prompts from transition hooks (see below)</span></span><br><span class="line">  getUserConfirmation: <span class="literal">null</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">createHashHistory(&#123;</span><br><span class="line">  basename: <span class="string">''</span>,             <span class="comment">// The base URL of the app (see below)</span></span><br><span class="line">  hashType: <span class="string">'slash'</span>,        <span class="comment">// The hash type to use (see below)</span></span><br><span class="line">  <span class="comment">// A function to use to confirm navigation with the user (see below)</span></span><br><span class="line">  getUserConfirmation: <span class="function">(<span class="params">message, callback</span>) =&gt;</span> callback(<span class="built_in">window</span>.confirm(message))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>history对象结构：</p><p><img src="/2017/06/17/react-router-analysis/history.png" alt="history"></p><h1 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h1><p><code>BrowserRouter</code>是对<code>Router</code>封装后的高阶组件。封装进去了<code>browserHistory</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserRouter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    basename: PropTypes.string,</span><br><span class="line">    forceRefresh: PropTypes.bool,</span><br><span class="line">    getUserConfirmation: PropTypes.func,</span><br><span class="line">    keyLength: PropTypes.number,</span><br><span class="line">    children: PropTypes.node</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  history = createHistory(<span class="keyword">this</span>.props)</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Router history=&#123;this.history&#125; children=&#123;this.props.children&#125;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>BrowserRouter</code>接收的props当做了<code>createHistory</code>的参数。<br>如果设置了<code>basename</code>属性，history初始化后，<code>history.location.pathname</code>的值是url中pathname除去<code>basename</code>后面的部分。<br>下面是在history的<code>createBrowserHistory</code>的部分源码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : <span class="string">''</span></span><br><span class="line"> <span class="keyword">const</span> getDOMLocation = <span class="function">(<span class="params">historyState</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; key, state &#125; = (historyState || &#123;&#125;)</span><br><span class="line">   <span class="keyword">const</span> &#123; pathname, search, hash &#125; = <span class="built_in">window</span>.location</span><br><span class="line">   <span class="keyword">let</span> path = pathname + search + hash</span><br><span class="line">   <span class="keyword">if</span> (basename)</span><br><span class="line">     path = stripBasename(path, basename)<span class="comment">//如果设置了basename，path会除去basename部分。</span></span><br><span class="line">   <span class="keyword">return</span> createLocation(path, state, key)</span><br><span class="line"> &#125;</span><br><span class="line"> stripBasename = <span class="function">(<span class="params">path, prefix</span>) =&gt;</span></span><br><span class="line"> hasBasename(path, prefix) ? path.substr(prefix.length) : path</span><br></pre></td></tr></table></figure></p><p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router basename=<span class="string">'reactRouter'</span>&gt;</span><br><span class="line">  &lt;Route path=<span class="string">'/about'</span> component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/Router&gt;</span></span><br></pre></td></tr></table></figure></p><p>浏览器地址栏显示：<a href="http://localhost:3000/reactRouter/about，此时，`history.location.pathname=&#39;/about&#39;`。" target="_blank" rel="noopener">http://localhost:3000/reactRouter/about，此时，`history.location.pathname=&#39;/about&#39;`。</a></p><h1 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h1><p><code>Router</code>初始化路由环境，监听<code>history</code>对象变化触发更新，通过<code>context</code>向下传递<code>history</code>和<code>route</code>信息。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">getChildContext() &#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     router: &#123;</span><br><span class="line">       ...this.context.router,</span><br><span class="line">       history: <span class="keyword">this</span>.props.history,</span><br><span class="line">       route: &#123;</span><br><span class="line">         location: <span class="keyword">this</span>.props.history.location,</span><br><span class="line">         match: <span class="keyword">this</span>.state.match</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> state = &#123;</span><br><span class="line">   match: <span class="keyword">this</span>.computeMatch(<span class="keyword">this</span>.props.history.location.pathname)</span><br><span class="line"> &#125;</span><br><span class="line"> computeMatch(pathname) &#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     path: <span class="string">'/'</span>,</span><br><span class="line">     url: <span class="string">'/'</span>,</span><br><span class="line">     params: &#123;&#125;,</span><br><span class="line">     isExact: pathname === <span class="string">'/'</span><span class="comment">//作用是判断是精确全部匹配到尾，还是前部分匹配。</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> componentWillMount() &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; children, history &#125; = <span class="keyword">this</span>.props</span><br><span class="line">   invariant(</span><br><span class="line">     children == <span class="literal">null</span> || React.Children.count(children) === <span class="number">1</span>,</span><br><span class="line">     <span class="string">'A &lt;Router&gt; may have only one child element'</span></span><br><span class="line">   )</span><br><span class="line">   <span class="comment">// Do this here so we can setState when a &lt;Redirect&gt; changes the</span></span><br><span class="line">   <span class="comment">// location in componentWillMount. This happens e.g. when doing</span></span><br><span class="line">   <span class="comment">// server rendering using a &lt;StaticRouter&gt;.</span></span><br><span class="line">   <span class="comment">// history.listen会监听history的变化，触发组件更新。</span></span><br><span class="line">   <span class="keyword">this</span>.unlisten = history.listen(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">       match: <span class="keyword">this</span>.computeMatch(history.location.pathname)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//render只是将子组件简单的渲染输出。</span></span><br><span class="line"> render() &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; children &#125; = <span class="keyword">this</span>.props</span><br><span class="line">   <span class="keyword">return</span> children ? React.Children.only(children) : <span class="literal">null</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>可以看出<code>match</code>对象结构：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/'</span>,</span><br><span class="line">  url: <span class="string">'/'</span>,</span><br><span class="line">  params: &#123;&#125;,</span><br><span class="line">  isExact: pathname === <span class="string">'/'</span><span class="comment">//作用是判断是精确全部匹配到尾，还是前部分匹配。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h1><p><code>Route</code>作用：根据<code>location</code>和<code>path</code>匹配路由,判断是否渲染<code>component</code>，并向<code>component</code>传入props<code>{ match, location, history, staticContext }</code></p><p>在Route.js的render函数中添加注释：<code>console.log(&quot;&lt;start&gt;\n&quot;,this.props.path,this.state.match,&quot;\n&lt;/end&gt;&quot;)</code>进行测试，<br>观察<code>match</code>对象变化，发现顶层路由<code>Route</code>都会进行匹配判断。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    computedMatch: PropTypes.object, <span class="comment">// private, from &lt;Switch&gt;</span></span><br><span class="line">    path: PropTypes.string,</span><br><span class="line">    exact: PropTypes.bool,<span class="comment">//精确匹配路由</span></span><br><span class="line">    strict: PropTypes.bool,<span class="comment">//严格匹配路径，关乎尾随的斜杠。</span></span><br><span class="line">    component: PropTypes.func,<span class="comment">//路由匹配时，渲染指定组件。</span></span><br><span class="line">    render: PropTypes.func,<span class="comment">//不指定component的情况下，可以使用render来渲染匹配的组件。</span></span><br><span class="line">    children: PropTypes.oneOfType([ <span class="comment">//在路径匹配的情况下会渲染children，exact属性无效</span></span><br><span class="line">      PropTypes.func,</span><br><span class="line">      PropTypes.node</span><br><span class="line">    ]),</span><br><span class="line">    location: PropTypes.object<span class="comment">//设置Location，作用暂时不知。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    router: PropTypes.shape(&#123;</span><br><span class="line">      history: PropTypes.object.isRequired,</span><br><span class="line">      route: PropTypes.object.isRequired,</span><br><span class="line">      staticContext: PropTypes.object</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    router: PropTypes.object.isRequired</span><br><span class="line">  &#125;</span><br><span class="line">  getChildContext() &#123; <span class="comment">//更新context中的route属性，继续向子元素传递。</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      router: &#123;</span><br><span class="line">        ...this.context.router,</span><br><span class="line">        route: &#123;</span><br><span class="line">          location: <span class="keyword">this</span>.props.location || <span class="keyword">this</span>.context.router.route.location,</span><br><span class="line">          match: <span class="keyword">this</span>.state.match</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123;</span><br><span class="line">    match: <span class="keyword">this</span>.computeMatch(<span class="keyword">this</span>.props, <span class="keyword">this</span>.context.router)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//计算match对象的值，&lt;Switch&gt;已经计算了computedMatch，具体见&lt;Switch&gt;分析。</span></span><br><span class="line">  computeMatch(&#123; computedMatch, location, path, strict, exact &#125;, &#123; route &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (computedMatch)</span><br><span class="line">      <span class="keyword">return</span> computedMatch <span class="comment">// &lt;Switch&gt; already computed the match for us</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> pathname = (location || route.location).pathname <span class="comment">//这里的pathname就是，浏览器导航栏显示的路径的一部分。</span></span><br><span class="line">      <span class="comment">// 当Route设置为&lt;Route path='/Topics/:topicId' component=&#123;Topic&#125;/&gt;，</span></span><br><span class="line">      <span class="comment">// 并且路由匹配后，match对象会有，params属性，记录匹配的参数。</span></span><br><span class="line">      <span class="comment">// 如点击&lt;Link to='/Topics/rendering'&gt;rendering&lt;/Link&gt;后（此时location.pathname='/Topics/rendering'），</span></span><br><span class="line">      <span class="comment">// 此时match.params=&#123;topicId:rendering&#125;。</span></span><br><span class="line">      <span class="comment">// 如果不设置path props，则使用this.context.router.match的值,这样该Route对应的组件会渲染。</span></span><br><span class="line">      <span class="comment">// matchPath计算match对象。</span></span><br><span class="line">    <span class="keyword">return</span> path ? matchPath(pathname, &#123; path, strict, exact &#125;) : route.match</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; component, render, children &#125; = <span class="keyword">this</span>.props</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillReceiveProps(nextProps, nextContext) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      match: <span class="keyword">this</span>.computeMatch(nextProps, nextContext.router)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; match &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> &#123; children, component, render &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">const</span> &#123; history, route, staticContext &#125; = <span class="keyword">this</span>.context.router</span><br><span class="line">    <span class="keyword">const</span> location = <span class="keyword">this</span>.props.location || route.location</span><br><span class="line">    <span class="keyword">const</span> props = &#123; match, location, history, staticContext &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      component ? ( <span class="comment">// component prop gets first priority, only called if there's a match</span></span><br><span class="line">        match ? React.createElement(component, props) : <span class="literal">null</span></span><br><span class="line">      ) : render ? ( <span class="comment">// render prop is next, only called if there's a match</span></span><br><span class="line">        match ? render(props) : <span class="literal">null</span></span><br><span class="line">      ) : children ? ( <span class="comment">// children come last, always called</span></span><br><span class="line">        <span class="keyword">typeof</span> children === <span class="string">'function'</span> ? (</span><br><span class="line">          children(props)</span><br><span class="line">        ) : !<span class="built_in">Array</span>.isArray(children) || children.length ? ( <span class="comment">// Preact defaults to empty children array</span></span><br><span class="line">          React.Children.only(children)</span><br><span class="line">        ) : (</span><br><span class="line">          <span class="literal">null</span></span><br><span class="line">        )</span><br><span class="line">      ) : (</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从render函数可以看出，优先级顺序是component&gt;render&gt;children。并且children分支没有判断match再进行返回。<br>三目运算符：<br><code>a?b:c?d:e</code>,这行代码应该等同于<code>a?b:(c?d:e)</code>,两个三目运算符，优先级相同，优先级相同时，从右往左结合。<br>但是运算还是从左往右运算。结合和运算要区分开来。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expression1 ? sentence1 :</span><br><span class="line">expression2 ? sentence2 :</span><br><span class="line">expression3 ? sentence3 :</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>只要任意一个expressionN的判断为真，那么sentenceN立即执行，这个判断结束，后面的任何判断不再执行。而如果我们写成if-else<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expression1)&#123;</span><br><span class="line">    sentence1;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(expression2)&#123; </span><br><span class="line">  sentence2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(expression3)&#123;</span><br><span class="line">  sentence3;</span><br><span class="line">&#125; ...</span><br></pre></td></tr></table></figure></p><h2 id="matchPath-js"><a href="#matchPath-js" class="headerlink" title="matchPath.js"></a>matchPath.js</h2><p><code>matchPath(pathname, options = {})</code>返回match对象。用于计算match对象。<br>有使用到<code>path-to-regexp</code>库。<br><code>path-to-regexp</code>使用方法：<a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener">https://github.com/pillarjs/path-to-regexp</a><a href="https://npmjs.org/package/path-to-regexp" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/e0b90b90518e04240605b28051ebca3d1157fac5/687474703a2f2f696d672e736869656c64732e696f2f6e706d2f646d2f706174682d746f2d7265676578702e7376673f7374796c653d666c6174" alt="Downloads" data-canonical-src="http://img.shields.io/npm/dm/path-to-regexp.svg?style=flat" style="max-width:100%;"></a></p><ul><li><code>path</code> An Express-style string, an array of strings, or a regular expression.</li><li><code>keys</code> An array to be populated with the keys found in the path.</li><li><code>options</code><ul><li><code>sensitive</code> When true the route will be case sensitive. (default: false)</li><li><code>strict</code> When false the trailing slash is optional. (default: false)</li><li><code>end</code> When false the path will match at the beginning. (default: true)</li><li><code>delimiter</code> Set the default delimiter for repeat parameters. (default: ‘/‘)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = []</span><br><span class="line"><span class="keyword">var</span> re = pathToRegexp(<span class="string">'/foo/:bar'</span>, keys)</span><br><span class="line"><span class="comment">// re = /^\/foo\/([^\/]+?)\/?$/i</span></span><br><span class="line"><span class="comment">// keys = [&#123; name: 'bar', prefix: '/', delimiter: '/', optional: false, repeat: false, pattern: '[^\\/]+?' &#125;]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><code>RegExp.prototype.exec()</code>,返回结果result是一个数组，result[0]表示匹配的全部字符串，[1], …[n]括号中的分组捕获,index:    匹配到的字符位于原始字符串的基于0的索引值,input:原始字符串,<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec" target="_blank" rel="noopener">mdn exec</a></p><h1 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h1><p><code>Link</code>:作用是一个链接，点击链接触发<code>history.push</code>或者<code>history.replace</code>,会触发<code>Router</code>组件的<code>history.listen</code>添加的回调，调用<code>setState</code>触发组件更新，进一步<code>Route</code>组件重新匹配路由，渲染对应组件。</p><p>modifier keys：ctrl，alt，metaKey，shift。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    onClick: PropTypes.func,</span><br><span class="line">    target: PropTypes.string,</span><br><span class="line">    replace: PropTypes.bool,</span><br><span class="line">    to: PropTypes.oneOfType([</span><br><span class="line">      PropTypes.string,</span><br><span class="line">      PropTypes.object</span><br><span class="line">    ]).isRequired</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    replace: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    router: PropTypes.shape(&#123;</span><br><span class="line">      history: PropTypes.shape(&#123;</span><br><span class="line">        push: PropTypes.func.isRequired,</span><br><span class="line">        replace: PropTypes.func.isRequired,</span><br><span class="line">        createHref: PropTypes.func.isRequired</span><br><span class="line">      &#125;).isRequired</span><br><span class="line">    &#125;).isRequired</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.onClick)</span><br><span class="line">      <span class="keyword">this</span>.props.onClick(event)</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !event.defaultPrevented &amp;&amp; <span class="comment">// onClick prevented default</span></span><br><span class="line">      event.button === <span class="number">0</span> &amp;&amp; <span class="comment">// ignore right clicks</span></span><br><span class="line">      !<span class="keyword">this</span>.props.target &amp;&amp; <span class="comment">// let browser handle "target=_blank" etc.</span></span><br><span class="line">      !isModifiedEvent(event) <span class="comment">// ignore clicks with modifier keys</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      event.preventDefault()<span class="comment">//阻止默认行为</span></span><br><span class="line">      <span class="keyword">const</span> &#123; history &#125; = <span class="keyword">this</span>.context.router</span><br><span class="line">      <span class="keyword">const</span> &#123; replace, to &#125; = <span class="keyword">this</span>.props</span><br><span class="line">      <span class="comment">//history对象更新，触发Router组件中的history.listen事件，调用setState，触发组件更新，Route组件会重新进行路由匹配。</span></span><br><span class="line">      <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">        history.replace(to) </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        history.push(to)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; replace, to, ...props &#125; = <span class="keyword">this</span>.props <span class="comment">// eslint-disable-line no-unused-vars</span></span><br><span class="line">  <span class="comment">//const createHref = (location) =&gt;basename + createPath(location)</span></span><br><span class="line">    <span class="keyword">const</span> href = <span class="keyword">this</span>.context.router.history.createHref(</span><br><span class="line">      <span class="keyword">typeof</span> to === <span class="string">'string'</span> ? &#123; <span class="attr">pathname</span>: to &#125; : to</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;a &#123;...props&#125; onClick=&#123;this.handleClick&#125; href=&#123;href&#125;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Link</span><br></pre></td></tr></table></figure><h1 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h1><p><code>NavLink</code>:是对<code>Link</code>的封装，可以添加导航活动状态的样式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NavLink = (&#123;</span><br><span class="line">  to,</span><br><span class="line">  exact,</span><br><span class="line">  strict,</span><br><span class="line">  location,</span><br><span class="line">  activeClassName,</span><br><span class="line">  className,</span><br><span class="line">  activeStyle,</span><br><span class="line">  style,</span><br><span class="line">  isActive: getIsActive,</span><br><span class="line">  ...rest</span><br><span class="line">&#125;) =&gt; (</span><br><span class="line">  <span class="comment">//这里Route使用的是children进行渲染子组件，此时无论路由是否匹配，都会渲染Link.</span></span><br><span class="line">  <span class="comment">//注意Route的path和Link的to参数，只要Link别点击，该Route就会匹配，这时计算的match对象不为null,</span></span><br><span class="line">  <span class="comment">//match对象和location会被传入getIsActive函数，进行link是否active的判断，和进而重新渲染Link。</span></span><br><span class="line">  &lt;Route</span><br><span class="line">    path=&#123;<span class="keyword">typeof</span> to === <span class="string">'object'</span> ? to.pathname : to&#125;</span><br><span class="line">    exact=&#123;exact&#125;</span><br><span class="line">    strict=&#123;strict&#125;</span><br><span class="line">    location=&#123;location&#125;</span><br><span class="line">    children=&#123;(&#123; location, match &#125;) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> isActive = !!(getIsActive ? getIsActive(match, location) : match)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Link</span><br><span class="line">          to=&#123;to&#125;</span><br><span class="line">          className=&#123;isActive ? [ className, activeClassName ].filter(<span class="function"><span class="params">i</span> =&gt;</span> i).join(<span class="string">' '</span>) : className&#125;</span><br><span class="line">          style=&#123;isActive ? &#123; ...style, ...activeStyle &#125; : style&#125;</span><br><span class="line">          &#123;...rest&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">)</span><br><span class="line">NavLink.propTypes = &#123;</span><br><span class="line">  to: Link.propTypes.to,</span><br><span class="line">  exact: PropTypes.bool,</span><br><span class="line">  strict: PropTypes.bool,</span><br><span class="line">  location: PropTypes.object,</span><br><span class="line">  activeClassName: PropTypes.string,</span><br><span class="line">  className: PropTypes.string,</span><br><span class="line">  activeStyle: PropTypes.object,</span><br><span class="line">  style: PropTypes.object,</span><br><span class="line">  isActive: PropTypes.func</span><br><span class="line">&#125;</span><br><span class="line">NavLink.defaultProps = &#123;</span><br><span class="line">  activeClassName: <span class="string">'active'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面可以看出<code>NavLink</code>接受的props。接收<code>isActive</code>是一个函数,内部调用<code>getIsActive(match, location)</code>传入了<code>match</code>和<code>location</code>，让使用者来判定该链接是否为<code>active</code>状态,如果是<code>active</code>状态,会给链接添加使用者传入的样式。<br>可以像下面使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink </span><br><span class="line">  to=<span class="string">"/news"</span> </span><br><span class="line">  activeStyle=&#123;&#123;<span class="attr">fontSize</span>:<span class="string">'18px'</span>,<span class="attr">color</span>:<span class="string">'red'</span>&#125;&#125; </span><br><span class="line">  isActive=&#123;(match,location)=&gt;&#123;<span class="keyword">if</span>(match)<span class="keyword">return</span> <span class="literal">true</span>&#125;&#125;</span><br><span class="line"> &gt;News&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h1><p>重定向链接<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redirect</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    push: PropTypes.bool, <span class="comment">//表示是否要使用history.push改变history。</span></span><br><span class="line">    <span class="keyword">from</span>: PropTypes.string,<span class="comment">//表示从指定路径跳转到目的路径（location）,与Switch配合使用。</span></span><br><span class="line">    to: PropTypes.oneOfType([</span><br><span class="line">      PropTypes.string,</span><br><span class="line">      PropTypes.object</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    push: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    router: PropTypes.shape(&#123;</span><br><span class="line">      history: PropTypes.shape(&#123;</span><br><span class="line">        push: PropTypes.func.isRequired,</span><br><span class="line">        replace: PropTypes.func.isRequired</span><br><span class="line">      &#125;).isRequired,</span><br><span class="line">      staticContext: PropTypes.object</span><br><span class="line">    &#125;).isRequired</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isStatic() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.context.router &amp;&amp; <span class="keyword">this</span>.context.router.staticContext</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isStatic())</span><br><span class="line">      <span class="keyword">this</span>.perform()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isStatic())</span><br><span class="line">      <span class="keyword">this</span>.perform()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  perform() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; history &#125; = <span class="keyword">this</span>.context.router</span><br><span class="line">    <span class="keyword">const</span> &#123; push, to &#125; = <span class="keyword">this</span>.props</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (push) &#123;</span><br><span class="line">      history.push(to)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      history.replace(to)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h1><p><code>&lt;Switch&gt;</code>的所有孩子应该是<code>&lt;Route&gt;</code>或者<code>&lt;Redirect&gt;</code>。只有第一个匹配当前location的孩子会被渲染。</p><p><code>&lt;Route&gt;</code>使用<code>path</code>属性进行匹配，<code>&lt;Redirect&gt;</code>使用<code>from</code>属性进行匹配。如果<code>&lt;Route&gt;</code>没有<code>path</code>属性<br>或者<code>&lt;Redirect&gt;</code>没有<code>from</code>属性则总是匹配当前的location（与<code>history.location.pathname</code>比较）。</p><p>当 <code>&lt;Switch&gt;</code>包含一个<code>&lt;Redirect&gt;</code>时，这个<code>&lt;Redirect&gt;</code>像<code>&lt;Route&gt;</code>一样，可以设置的props增加了<code>path</code>、<code>exact</code>、<code>strict</code>，这些都会起作用，如果没有设置<code>path</code>,属性中的<code>from</code>,当做<code>path</code>使用。具体实现，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public API for rendering the first &lt;Route&gt; that matches.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switch</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    router: PropTypes.shape(&#123;</span><br><span class="line">      route: PropTypes.object.isRequired</span><br><span class="line">    &#125;).isRequired</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    children: PropTypes.node,</span><br><span class="line">    location: PropTypes.object</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    warning(</span><br><span class="line">      !(nextProps.location &amp;&amp; !<span class="keyword">this</span>.props.location),</span><br><span class="line">      <span class="string">'&lt;Switch&gt; elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    warning(</span><br><span class="line">      !(!nextProps.location &amp;&amp; <span class="keyword">this</span>.props.location),</span><br><span class="line">      <span class="string">'&lt;Switch&gt; elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.'</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; route &#125; = <span class="keyword">this</span>.context.router</span><br><span class="line">    <span class="keyword">const</span> &#123; children &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">const</span> location = <span class="keyword">this</span>.props.location || route.location</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> match, child</span><br><span class="line">    React.Children.forEach(children, element =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!React.isValidElement(element)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">path</span>: pathProp, exact, strict, <span class="keyword">from</span> &#125; = element.props</span><br><span class="line">      <span class="keyword">const</span> path = pathProp || <span class="keyword">from</span> <span class="comment">//&lt;Redirect from='/old-path' to='/new-path'/&gt;,只有指定路径（from）才跳转到to。</span></span><br><span class="line">      <span class="comment">//这里限制了渲染第一个匹配路由的Route或者Redirect。</span></span><br><span class="line">      <span class="keyword">if</span> (match == <span class="literal">null</span>) &#123;</span><br><span class="line">        child = element</span><br><span class="line">        match = path ? matchPath(location.pathname, &#123; path, exact, strict &#125;) : route.match</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//这里的cloneElement传入&#123; location, computedMatch: match &#125;是为&lt;Route&gt;使用的，对&lt;Redirect&gt;并不起作用。</span></span><br><span class="line">    <span class="keyword">return</span> match ? React.cloneElement(child, &#123; location, <span class="attr">computedMatch</span>: match &#125;) : <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h1><p>在一个组件内使用，当该组件要被卸载的时候会被调用，即导航到别处的时候会询问是否离开。<br>发下了一个问题：当离开的时候点击的否，不会刷新页面，但是在点击当前导航的时候，还会发出同样的询问，不知是否正常。<br>基本原因：通过<code>&lt;Prompt&gt;</code>设置了提示信息是全局的，只要没有取消提示信息，点击<code>&lt;Link&gt;</code>组件都会触发提示。<br>只有切换到其它导航，<code>&lt;Prompt&gt;</code>被卸载，设置的提示信息被取消，其它导航间切换不会有提示。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public API for prompting the user before navigating away</span></span><br><span class="line"><span class="comment"> * from a screen with a component.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prompt</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    when: PropTypes.bool,</span><br><span class="line">    message: PropTypes.oneOfType([</span><br><span class="line">      PropTypes.func,</span><br><span class="line">      PropTypes.string</span><br><span class="line">    ]).isRequired</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    when: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    router: PropTypes.shape(&#123;</span><br><span class="line">      history: PropTypes.shape(&#123;</span><br><span class="line">        block: PropTypes.func.isRequired</span><br><span class="line">      &#125;).isRequired</span><br><span class="line">    &#125;).isRequired</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  enable(message) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.unblock)</span><br><span class="line">      <span class="keyword">this</span>.unblock()</span><br><span class="line">      <span class="comment">//history.block(message)添加导航切换的提示信息，返回取消提示的方法。</span></span><br><span class="line">    <span class="keyword">this</span>.unblock = <span class="keyword">this</span>.context.router.history.block(message)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  disable() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.unblock) &#123;</span><br><span class="line">      <span class="comment">//取消导航切换提示。</span></span><br><span class="line">      <span class="keyword">this</span>.unblock()</span><br><span class="line">      <span class="keyword">this</span>.unblock = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当&lt;Prompt&gt;挂载的时候，设置导航切换前提示。</span></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.when)</span><br><span class="line">      <span class="keyword">this</span>.enable(<span class="keyword">this</span>.props.message)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextProps.when) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.props.when || <span class="keyword">this</span>.props.message !== nextProps.message)</span><br><span class="line">        <span class="keyword">this</span>.enable(nextProps.message)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.disable()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当&lt;Prompt&gt;卸载的时候,取消导航切换提示。</span></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.disable()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从<code>&lt;Prompt&gt;</code>设计可以看出，在<code>&lt;Prompt&gt;</code>将要挂载的时候调用了<code>history.block(message)</code>，这个操作使得在调用<code>history.push</code>或者<code>history.replace</code>（<code>&lt;Link&gt;</code>）的时候，改变浏览器本地location和history之前，会进行切换导航前的提示。<br>具体实现参见<code>history</code><a href="https://github.com/ReactTraining/history/blob/master/modules/createBrowserHistory.js#L267" target="_blank" rel="noopener">block</a><br><code>&lt;BrowserRouter&gt;</code>有个props是<code>getUserConfirmation</code>,它是<code>createHistory</code>暴露给用户的接口，可让用户可以自定义转移确认行为。<br>转移确认默认的行为是<code>history</code>库内部的<a href="https://github.com/ReactTraining/history/blob/master/modules/DOMUtils.js#L15" target="_blank" rel="noopener">getConfirmation</a>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getConfirmation = <span class="function">(<span class="params">message, callback</span>) =&gt;</span></span><br><span class="line">  callback(<span class="built_in">window</span>.confirm(message))</span><br></pre></td></tr></table></figure></p><h1 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h1><p>高阶组件。使用<code>withRouter</code>包裹的<code>Component</code>,每一次路由改变<code>Component</code>都会重新渲染。是因为<code>&lt;Route&gt;</code>渲染了属性：<code>{match,location,history}</code>。就像React-Redux的connect函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A public higher-order component to access the imperative API</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> withRouter = <span class="function">(<span class="params">Component</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> C = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; wrappedComponentRef, ...remainingProps &#125; = props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Route render=&#123;routeComponentProps =&gt; (</span><br><span class="line">        &lt;Component &#123;...remainingProps&#125; &#123;...routeComponentProps&#125; ref=&#123;wrappedComponentRef&#125;/&gt;</span><br><span class="line">      )&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  C.displayName = <span class="string">`withRouter(<span class="subst">$&#123;Component.displayName || Component.name&#125;</span>)`</span></span><br><span class="line">  C.WrappedComponent = Component</span><br><span class="line">  C.propTypes = &#123;</span><br><span class="line">    wrappedComponentRef: PropTypes.func</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hoistStatics(C, Component) <span class="comment">//该方法的作用是除了特殊属性外将Component上属性复制到C上。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h1><p>使用了<code>history/createHashHistory</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> createHistory <span class="keyword">from</span> <span class="string">'history/createHashHistory'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public API for a &lt;Router&gt; that uses window.location.hash.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashRouter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    basename: PropTypes.string,</span><br><span class="line">    getUserConfirmation: PropTypes.func,</span><br><span class="line">    hashType: PropTypes.oneOf([ <span class="string">'hashbang'</span>, <span class="string">'noslash'</span>, <span class="string">'slash'</span> ]),</span><br><span class="line">    children: PropTypes.node</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  history = createHistory(<span class="keyword">this</span>.props)</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Router history=&#123;this.history&#125; children=&#123;this.props.children&#125;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="StaticRouter"><a href="#StaticRouter" class="headerlink" title="StaticRouter"></a>StaticRouter</h1><p>用途：服务器端渲染。<br>用户在浏览器地址栏输入要访问的地址回车后，向服务器发出请求，服务器根据url进行解析。<br>但是服务器要能正确判断，请求的url是前端路由，还是请求的其它静态资源。<br>判断是前端路由后，执行服务器端渲染。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReactDOMServer.renderToString(</span><br><span class="line">    &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt;</span><br><span class="line">      &lt;App/&gt;</span><br><span class="line">    &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br></pre></td></tr></table></figure></p><p>在服务器端不会有用户点击<code>&lt;Link&gt;</code>以及前进后退。但是可能会有<code>&lt;Redirect&gt;</code>或者其它组件在<code>componentWillMount</code>中操作<code>history.push</code>或者<code>history.replace</code>。这样会改变<code>location</code>。要想渲染出想要的结果，服务器端会向浏览器发出重定向请求，这样浏览器会发送新的url请求,然后服务器端再次做出相应。<br>服务器如何才能发送正确的重定向请求呢？就是使用一个<code>staticContext</code>对象进行记录，就是传入<code>&lt;StaticRouter&gt;</code>的<code>context</code>对象。<br>在服务器端渲染完成后，这个对象只会记录，最后一次的<code>location</code>信息。<br>具体实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; addLeadingSlash, createPath, parsePath &#125; <span class="keyword">from</span> <span class="string">'history/PathUtils'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'./Router'</span></span><br><span class="line"><span class="comment">//规范化location</span></span><br><span class="line"><span class="keyword">const</span> normalizeLocation = <span class="function">(<span class="params">object</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname = <span class="string">'/'</span>, search = <span class="string">''</span>, hash = <span class="string">''</span> &#125; = object</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    pathname,</span><br><span class="line">    search: search === <span class="string">'?'</span> ? <span class="string">''</span> : search,</span><br><span class="line">    hash: hash === <span class="string">'#'</span> ? <span class="string">''</span> : hash</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加basename</span></span><br><span class="line"><span class="keyword">const</span> addBasename = <span class="function">(<span class="params">basename, location</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!basename)</span><br><span class="line">    <span class="keyword">return</span> location</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...location,</span><br><span class="line">    pathname: addLeadingSlash(basename) + location.pathname</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剥离basename</span></span><br><span class="line"><span class="keyword">const</span> stripBasename = <span class="function">(<span class="params">basename, location</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!basename)</span><br><span class="line">    <span class="keyword">return</span> location</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> base = addLeadingSlash(basename)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (location.pathname.indexOf(base) !== <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> location</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...location,</span><br><span class="line">    pathname: location.pathname.substr(base.length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建location</span></span><br><span class="line"><span class="keyword">const</span> createLocation = <span class="function">(<span class="params">location</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">typeof</span> location === <span class="string">'string'</span> ? parsePath(location) : normalizeLocation(location)</span><br><span class="line"><span class="comment">//创建URL，pathname+search+hash</span></span><br><span class="line"><span class="keyword">const</span> createURL = <span class="function">(<span class="params">location</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">typeof</span> location === <span class="string">'string'</span> ? location : createPath(location)</span><br><span class="line"><span class="comment">//一些方法不能再StaticRouter中设置。</span></span><br><span class="line"><span class="keyword">const</span> staticHandler = <span class="function">(<span class="params">methodName</span>) =&gt;</span> () =&gt; &#123;</span><br><span class="line">  invariant(</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    <span class="string">'You cannot %s with &lt;StaticRouter&gt;'</span>,</span><br><span class="line">    methodName</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空方法</span></span><br><span class="line"><span class="keyword">const</span> noop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public top-level API for a "static" &lt;Router&gt;, so-called because it</span></span><br><span class="line"><span class="comment"> * can't actually change the current location. Instead, it just records</span></span><br><span class="line"><span class="comment"> * location changes in a context object. Useful mainly in testing and</span></span><br><span class="line"><span class="comment"> * server-rendering scenarios.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticRouter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    basename: PropTypes.string,</span><br><span class="line">    context: PropTypes.object.isRequired,</span><br><span class="line">    location: PropTypes.oneOfType([</span><br><span class="line">      PropTypes.string,</span><br><span class="line">      PropTypes.object</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    basename: <span class="string">''</span>,</span><br><span class="line">    location: <span class="string">'/'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    router: PropTypes.object.isRequired</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//&lt;StaticRouter&gt;通过context向&lt;Router&gt;传递数据。向&lt;BrowserRouter&gt;、&lt;HashRouter&gt;、&lt;MemoryRouter&gt;都没有这样的操作。</span></span><br><span class="line"><span class="comment">//主要还是因为服务器端渲染的需要。</span></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      router: &#123;</span><br><span class="line">        staticContext: <span class="keyword">this</span>.props.context</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//使用箭头函数，绑定this对象。因为history对象会向子组件传递，要使得这里的this可以正确访问this.props。</span></span><br><span class="line">  createHref = <span class="function">(<span class="params">path</span>) =&gt;</span></span><br><span class="line">    addLeadingSlash(<span class="keyword">this</span>.props.basename + createURL(path))</span><br><span class="line"><span class="comment">//这里是history.push方法</span></span><br><span class="line">  handlePush = <span class="function">(<span class="params">location</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; basename, context &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    context.action = <span class="string">'PUSH'</span></span><br><span class="line">    context.location = addBasename(basename, createLocation(location))</span><br><span class="line">    context.url = createURL(context.location)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//这里是history.replace方法。可以看出这里的push和replace方法都是设置this.props.context对象。可以根据context.url判断是否需要重定向。</span></span><br><span class="line">  handleReplace = <span class="function">(<span class="params">location</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; basename, context &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    context.action = <span class="string">'REPLACE'</span></span><br><span class="line">    context.location = addBasename(basename, createLocation(location))</span><br><span class="line">    context.url = createURL(context.location)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleListen = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">    noop</span><br><span class="line"></span><br><span class="line">  handleBlock = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">    noop</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; basename, context, location, ...props &#125; = <span class="keyword">this</span>.props</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> history = &#123;</span><br><span class="line">      createHref: <span class="keyword">this</span>.createHref,</span><br><span class="line">      action: <span class="string">'POP'</span>,</span><br><span class="line">      location: stripBasename(basename, createLocation(location)),</span><br><span class="line">      push: <span class="keyword">this</span>.handlePush,</span><br><span class="line">      replace: <span class="keyword">this</span>.handleReplace,</span><br><span class="line">      go: staticHandler(<span class="string">'go'</span>),<span class="comment">//使用StaticRoute不可以使用go，goBack，goForward方法。</span></span><br><span class="line">      goBack: staticHandler(<span class="string">'goBack'</span>),</span><br><span class="line">      goForward: staticHandler(<span class="string">'goForward'</span>),</span><br><span class="line">      listen: <span class="keyword">this</span>.handleListen, <span class="comment">//listen和block都是空方法</span></span><br><span class="line">      block: <span class="keyword">this</span>.handleBlock</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;Router &#123;...props&#125; history=&#123;history&#125;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在测试服务器端渲染的时候发现了一个问题。<br>路由问题，如果静态资源使用了相对路径，静态资源访问出错。比如访问：<code>http://localhost:3000/topics/aaa</code>,<br>topics是设置的前端路由，这时加载相对路径的静态资源比如<code>./static/js/main.d23df278.js</code>,<br>客户端向服务器请求是路径会解析成<code>http://localhost:3000/topics/static/js/main.d23df278.js</code>,<br>这时就不能请求到正确的文件。要是使用绝对路径，就没有这个问题了。<code>/static/js/main.d23df278.js</code><br>会被解析成相对网站根目录的<code>http://localhost:3000/static/js/main.d23df278.js</code>。</p><h1 id="MemoryRouter"><a href="#MemoryRouter" class="headerlink" title="MemoryRouter"></a>MemoryRouter</h1><p>在内存中保存history（不从地址栏读取，不向地址栏写入）。用途：测试，native环境。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"><span class="keyword">import</span> createHistory <span class="keyword">from</span> <span class="string">'history/createMemoryHistory'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'./Router'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The public API for a &lt;Router&gt; that stores location in memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryRouter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    initialEntries: PropTypes.array,</span><br><span class="line">    initialIndex: PropTypes.number,</span><br><span class="line">    getUserConfirmation: PropTypes.func,</span><br><span class="line">    keyLength: PropTypes.number,</span><br><span class="line">    children: PropTypes.node</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  history = createHistory(<span class="keyword">this</span>.props)</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Router history=&#123;this.history&#125; children=&#123;this.props.children&#125;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default MemoryRouter</span><br></pre></td></tr></table></figure></p><p>上面可以看出，<code>&lt;MemoryRouter&gt;</code>使用<code>createMemoryHistory</code>构造的<code>history</code>，其它都一样，只有这么多。具体怎么实现要看<code>history</code>库的实现了。<br><code>createMemoryHistory</code>返回的<code>history</code>对象结构：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> history = &#123;</span><br><span class="line">    length: entries.length,</span><br><span class="line">    action: <span class="string">'POP'</span>,</span><br><span class="line">    location: entries[index],</span><br><span class="line">    index,  <span class="comment">//当前location索引。</span></span><br><span class="line">    entries,<span class="comment">//保存location信息的数组即history信息。</span></span><br><span class="line">    createHref,</span><br><span class="line">    push,</span><br><span class="line">    replace,</span><br><span class="line">    go,</span><br><span class="line">    goBack,</span><br><span class="line">    goForward,</span><br><span class="line">    canGo,</span><br><span class="line">    block,</span><br><span class="line">    listen</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><code>createBrowserHistory</code>返回的<code>history</code>对象结构：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> history = &#123;</span><br><span class="line">    length: globalHistory.length,</span><br><span class="line">    action: <span class="string">'POP'</span>,</span><br><span class="line">    location: initialLocation,</span><br><span class="line">    createHref,</span><br><span class="line">    push,</span><br><span class="line">    replace,</span><br><span class="line">    go,</span><br><span class="line">    goBack,</span><br><span class="line">    goForward,</span><br><span class="line">    block,</span><br><span class="line">    listen</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>react-router</code>机制：当URL更改时，它被<code>History</code> API的状态机制拦截，然后重新渲染整个视图。<br>react-router v4 中所有的控制都是通过组件形式。<br>在v4以前的版本中，称为静态路由，是通过配置的形式控制路由，路由和组件是分离的；<br>v4称为动态路由，在app的渲染过程中，动态的匹配路由，组件和路由可以嵌套使用。<br>没有看过v4以前的源码，只是使用过v3，因此不能进行深入的对比。<br>react-router源码并不多，设计的很精巧。<br><code>history</code>是<code>react-router</code>的重要依赖，想要更加深刻的理解，必须要对<code>history</code>有足够的认识。<br>有时间再系统的分析一下<code>history</code>源码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考链接&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://reacttraining.com/react-router/web/api/BrowserRouter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://reacttraining.com/react-router/web/api/BrowserRouter&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/ReactTraining/history&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ReactTraining/history&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;版本：react-router V4&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;history&quot;&gt;&lt;a href=&quot;#history&quot; class=&quot;headerlink&quot; title=&quot;history&quot;&gt;&lt;/a&gt;history&lt;/h1&gt;&lt;p&gt;react-router官方文档有说&lt;code&gt;history is mutable&lt;/code&gt;。&lt;br&gt;给的例子：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Comp&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  componentWillReceiveProps(nextProps) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// will be true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; locationChanged = nextProps.location !== &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.props.location&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// INCORRECT, will *always* be false because history is mutable.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; locationChanged = nextProps.history.location !== &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.props.history.location&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;Route component=&amp;#123;Comp&amp;#125;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;原因是：&lt;code&gt;&amp;lt;Route&amp;gt;&lt;/code&gt;向&lt;code&gt;Comp&lt;/code&gt;传入props包括&lt;code&gt;match, location, history, staticContext&lt;/code&gt;(见&lt;code&gt;&amp;lt;Route&amp;gt;&lt;/code&gt;分析),&lt;code&gt;history&lt;/code&gt;是从&lt;code&gt;context&lt;/code&gt;上下文中获取得到，一直是对同一个对象的引用，所以一直&lt;code&gt;nextProps.history.location === this.props.history.location&lt;/code&gt;，而&lt;code&gt;nextProps.location !== this.props.location&lt;/code&gt;，是因为在&lt;code&gt;history&lt;/code&gt;库里面&lt;code&gt;history.location&lt;/code&gt;的计算方式，是重新计算&lt;code&gt;location&lt;/code&gt;对象。&lt;code&gt;const location = createLocation(path, state, createKey(), history.location)&lt;/code&gt;。具体见&lt;a href=&quot;https://github.com/ReactTraining/history/blob/master/modules/LocationUtils.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ReactTraining/history/blob/master/modules/LocationUtils.js&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://fsysfq.top/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="react-router" scheme="http://fsysfq.top/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>react-analysis总结</title>
    <link href="http://fsysfq.top/2017/06/10/react-analysis%E6%80%BB%E7%BB%93/"/>
    <id>http://fsysfq.top/2017/06/10/react-analysis总结/</id>
    <published>2017-06-10T07:12:41.000Z</published>
    <updated>2018-07-07T13:18:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>① <a href="http://blog.csdn.net/u013510838/article/details/55669742" target="_blank" rel="noopener">http://blog.csdn.net/u013510838/article/details/55669742</a><br>② <a href="https://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one/" target="_blank" rel="noopener">https://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one/</a><br>③ <a href="https://zhuanlan.zhihu.com/p/20346379?columnSlug=purerender" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20346379?columnSlug=purerender</a><br>首先贴出我阅读源码时参考的链接。很感谢作者。<br>React源码规模十分庞大，开始阅读的时候不能直接陷进去，研究一些细节，而是要先把握整体的流程，对流程有基本了解后再沉下心仔细品味。这里推荐先去阅读上面的链接②，再去参考链接①。参考链接③讲了react  diff算法，可以参考<a href="mailto:react@0.14" target="_blank" rel="noopener">react@0.14</a>中对应的文件。</p></blockquote><p>​    建议看React@15的源码。我一开始阅读源码的时候，把React源码clone了下来，版本比较高在16.0.0-alpha.3以后，源码中没有使用相对路径，用的所谓的全局模块系统，都找不到北。后来就找教程，参考如何阅读。后来就找到了上面两个，也并没有提什么全局模块系统。后来根据参考链接①，将react版本切换到了<a href="mailto:React@16.0.0-alpha.3" target="_blank" rel="noopener">React@16.0.0-alpha.3</a>。然后就看是研究源代码了。只看代码并不直观，需要配合调试，才能更好地理解。使用官方提供的<code>create-react-app</code>脚手架，进行编码测试。后来发现默认使用的是<a href="mailto:React@15.5.4" target="_blank" rel="noopener">React@15.5.4</a>，不过16里面也有对应代码，并且我已经添加了好多注释，并不影响阅读，也就没有再切换版本，当看到<code>ReactDOMComponent</code>为元素注册事件的时候，就看不下去了，乖乖的直接看测试项目下的<code>node_modules</code>中的<code>react</code>和<code>react-dom</code>模块去了。</p><p>​    React@16这个版本，其实发生了很大的变化，React将要发布fiber特性。React fiber对以前React的核心算法做了全新的改版。不过<a href="mailto:React@16.0.0-alpha.3" target="_blank" rel="noopener">React@16.0.0-alpha.3</a>代码库中，以前的模块还都存在，可以阅读研究。</p><a id="more"></a><p>​    阅读React源码，首先对React源码中的基本概念有充分的理解。我想既然想研究React源码，肯定对已经对React有了充分的认识。如果有不明白的地方，<a href="https://facebook.github.io/react/docs/installation.html" target="_blank" rel="noopener">官方文档</a>是很好的资源。</p><h1 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h1><p>在代码中加debugger，console.log。在浏览器控制台调试。可以加在自己写的文件中，也可以加在<code>node_modules</code>中的<code>react</code>和<code>react-dom</code>模块源码中。</p><h1 id="React中的基本概念"><a href="#React中的基本概念" class="headerlink" title="React中的基本概念"></a>React中的基本概念</h1><ol><li><code>React Component</code>：用户自定义组件，以前是通过<code>React.createClass</code>创建自定义组件,现在es6语法是通过class 继承的语法创建自定义组件，自组件中可以定义生命周期函数等，自定义组件只是一个类或者说是一个构造函数，可以在JSX中声明式的使用，如<code>&lt;div&gt;&lt;MyConponent1/&gt;&lt;MyComponent2/&gt;&lt;/div&gt;</code>，这时并没有对自定义组件进行实例化。</li><li><code>ReactElement</code>：<code>ReactElement</code>是React对用户自定义组件和原生DOM的一个抽象元素，就像原生DOM元素（div、span）一样可以构成DOM树，通过<code>ReactElement</code>之间的组合抽象形成<code>Virtual DOM</code>树。无论是DOM元素还是用户自定义组件都会被转化为ReactElement。</li></ol><p>React以JSX形式书写，是要经过babel转义处理的。可以在<a href="http://babeljs.cn/repl/或者http://babeljs.io/这两个网站，进行观察测试。" target="_blank" rel="noopener">http://babeljs.cn/repl/或者http://babeljs.io/这两个网站，进行观察测试。</a></p><p>上面只是概念，并不直观，可以自己测试，在控制台中将React中的重要的数据结构打印出来。<code>var result=ReactDOM.render(&lt;App/&gt;,...)</code>调用返回结果result是自定义组件App的实例化对象。在阅读源码的过程中，可以进行参考理解。可以看看React内部是如何表达<code>Virtual DOM</code>的树形结构的。</p><p>昨天在掘金看到的一篇文章<a href="https://juejin.im/entry/592ea028a22b9d0057753349" target="_blank" rel="noopener">图解 React Virtual DOM</a>对理解<code>Virtual DOM</code>会有些帮助。</p><h1 id="React源码中关键词汇"><a href="#React源码中关键词汇" class="headerlink" title="React源码中关键词汇"></a>React源码中关键词汇</h1><ol><li><p><code>reconsiler</code>:调度者或者调和着，reconciliation（n. 和解；调和；和谐；甘愿） algorithm：可以理解为调度算法</p></li><li><p><code>publicInstance</code>：用户自定义组件实例化组件。</p></li><li><code>internalInstance</code>：ReactElement对应的内部实例，也可以说是用户自定义组件对应的内部实例。内部实例是<code>ReactCompositeComponent</code>、<code>ReactDOMComponent</code>等实例化对象。</li></ol><p><code>publicInstance</code>和<code>internalInstance</code>这两个对象是相互引用的。</p><p><code>App</code>实例就是<code>publicInstance</code>，<code>_reactInternalInstance</code>就是<code>App</code>引用的内部实例。</p><p><code>_reactInternalInstance</code>有个<code>_instance</code>属性，是对<code>App</code>实例的引用。</p><ol start="4"><li><p><code>context</code><br><code>contextType</code>:设置该属性的组件，则在该组件内部可以通过this.context获取到contex。<br><code>childContextTypes</code>:设置该属性的组件，可以设置向下传递context对象的属性的类型。<br><code>getChildContext()</code>：该函数设置可以向下传递的context对象属性。必须要在childContextTypes设置属性类型。<br>特点：只要在一个组件设置了context，则在其后代组件中都可以获取到。<br>​       如果后代组件也设置了context，向下传递的context是<code>Object.assign({}, currentContext, childContext);</code><br>​       <code>currentContext</code>:是从父组件传下来的Context（unmaskedContext）。<br>​       <code>childContext</code>:是当前组件设置的childContext。<br>当前组件对应的<code>internalInstance._context=currentContent</code><br>当前组件<code>publicInstance</code>只能根据<code>contextType</code>，从<code>currentContext</code>生成对应的<code>context</code>。</p></li><li><p><code>Transaction</code>：事务</p><p>React中挂载、更新等都是以事务形式进行。可以理解为：一个操作如果以事务形式执行，那么可以在这个操作执行前进行一些初始化工作（initial阶段），在操作执行后进行一些擦屁股操作（close阶段）。具体实现看源码。</p></li></ol><h1 id="React-Mount阶段"><a href="#React-Mount阶段" class="headerlink" title="React Mount阶段"></a>React Mount阶段</h1><p>大致流程：</p><ol><li>判断是否已经执行过ReactDOM.render()，如果是进行更新操作。否则执行3</li><li>判断是否是服务器端渲染，如果是进行标记。执行3</li><li>执行新组件的挂载操作。实例化组件，初始化批量挂载组件环境。 <code>ReactUpdates.batchedUpdates</code>,作用是：以事务形式进行，挂载操作，如果有setState类似更新组件操作，在close阶段进行事后处理。</li><li>将调度挂载阶段事务化。  <code>ReactReconcileTransaction</code> 即 ReactReconcile事务：显然，是将ReactReconcile这一过程的事务化。作用：①维护一个callback对列，在挂载完成后在事务的close阶段调用。当然还有其它作用。</li><li>递归挂载组件返回markup。 <code>ReactReconciler.mountComponent</code>顾名思义 React调和 挂载组件 ，调和的过程是React思想的精髓。diff过程融入其中。参见：<a href="https://facebook.github.io/react/docs/reconciliation.html" target="_blank" rel="noopener">reconciliation</a></li><li>并将markup插入container。这一步中，如果是服务器端渲染，进行校验和判断。</li><li>执行 <code>ReactReconcileTransaction</code>的close阶段。</li><li>执行 <code>ReactUpdates.batchedUpdates</code>的close阶段。</li></ol><p>这是我开始研究源码时，在<a href="https://www.processon.com上画的图，" target="_blank" rel="noopener">https://www.processon.com上画的图，</a><br><img src="http://www.processon.com/chart_image/591304bde4b0f320c44ff26f.png" alt="ReactMount阶段分析过程图"><br>很是庞大，操作很复杂，不画图的话会跳晕的。当中可能有些不准确的地方。</p><p>还有实例化ReactComponent的过程，还有React组件的树形结构。如图</p><p><img src="http://www.processon.com/chart_image/5915e122e4b0ef971ac9bb85.png" alt="InstantiateReactComponent"></p><h1 id="React-updating阶段"><a href="#React-updating阶段" class="headerlink" title="React updating阶段"></a>React updating阶段</h1><p>可以结合一开始给出的参考链接①③阅读源码。还有总结里面给出的连接可以参考。</p><h1 id="React的合成事件"><a href="#React的合成事件" class="headerlink" title="React的合成事件"></a>React的合成事件</h1><p>React实现了一套复杂的事件系统。可以结合一开始给出的参考链接①阅读源码。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>React源码很复杂，我也只是有了个大概的理解，还没能从更高的层次去理解其设计的原理及原因。</p><p>添加注释的代码参考<a href="https://github.com/sivkun/react-analysis" target="_blank" rel="noopener">https://github.com/sivkun/react-analysis</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;① &lt;a href=&quot;http://blog.csdn.net/u013510838/article/details/55669742&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u013510838/article/details/55669742&lt;/a&gt;&lt;br&gt;② &lt;a href=&quot;https://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one/&lt;/a&gt;&lt;br&gt;③ &lt;a href=&quot;https://zhuanlan.zhihu.com/p/20346379?columnSlug=purerender&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/20346379?columnSlug=purerender&lt;/a&gt;&lt;br&gt;首先贴出我阅读源码时参考的链接。很感谢作者。&lt;br&gt;React源码规模十分庞大，开始阅读的时候不能直接陷进去，研究一些细节，而是要先把握整体的流程，对流程有基本了解后再沉下心仔细品味。这里推荐先去阅读上面的链接②，再去参考链接①。参考链接③讲了react  diff算法，可以参考&lt;a href=&quot;mailto:react@0.14&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;react@0.14&lt;/a&gt;中对应的文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​    建议看React@15的源码。我一开始阅读源码的时候，把React源码clone了下来，版本比较高在16.0.0-alpha.3以后，源码中没有使用相对路径，用的所谓的全局模块系统，都找不到北。后来就找教程，参考如何阅读。后来就找到了上面两个，也并没有提什么全局模块系统。后来根据参考链接①，将react版本切换到了&lt;a href=&quot;mailto:React@16.0.0-alpha.3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React@16.0.0-alpha.3&lt;/a&gt;。然后就看是研究源代码了。只看代码并不直观，需要配合调试，才能更好地理解。使用官方提供的&lt;code&gt;create-react-app&lt;/code&gt;脚手架，进行编码测试。后来发现默认使用的是&lt;a href=&quot;mailto:React@15.5.4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React@15.5.4&lt;/a&gt;，不过16里面也有对应代码，并且我已经添加了好多注释，并不影响阅读，也就没有再切换版本，当看到&lt;code&gt;ReactDOMComponent&lt;/code&gt;为元素注册事件的时候，就看不下去了，乖乖的直接看测试项目下的&lt;code&gt;node_modules&lt;/code&gt;中的&lt;code&gt;react&lt;/code&gt;和&lt;code&gt;react-dom&lt;/code&gt;模块去了。&lt;/p&gt;
&lt;p&gt;​    React@16这个版本，其实发生了很大的变化，React将要发布fiber特性。React fiber对以前React的核心算法做了全新的改版。不过&lt;a href=&quot;mailto:React@16.0.0-alpha.3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React@16.0.0-alpha.3&lt;/a&gt;代码库中，以前的模块还都存在，可以阅读研究。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://fsysfq.top/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="react" scheme="http://fsysfq.top/tags/react/"/>
    
      <category term="源码，框架" scheme="http://fsysfq.top/tags/%E6%BA%90%E7%A0%81%EF%BC%8C%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>节流模式</title>
    <link href="http://fsysfq.top/2017/06/04/%E8%8A%82%E6%B5%81%E5%99%A8throttle/"/>
    <id>http://fsysfq.top/2017/06/04/节流器throttle/</id>
    <published>2017-06-04T10:13:13.000Z</published>
    <updated>2018-07-06T06:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>节流模式（Throttler）：对重复的业务逻辑进行节流控制，执行最后一次操作并取消其他操作，以提高性能。<br>用处：浏览器中的scroll、mouseover、mouseenter、mouseleave、resize等事件的处理函数被连续重复触发，很多情况下，只需要对最后一次触发做出反应，这时就要用到节流模式。<br><a id="more"></a><br>简单例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">isClear, fn, param</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="keyword">typeof</span> isClear === <span class="string">'boolean'</span>) &#123;</span></span><br><span class="line"><span class="undefined">        fn.__throttleID &amp;&amp; clearTimeout(fn.__throttleID);</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="undefined">        param = fn;</span></span><br><span class="line"><span class="undefined">        fn = isClear;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> p = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;</span></span><br><span class="line"><span class="javascript">          context: <span class="literal">null</span>,</span></span><br><span class="line"><span class="undefined">          args: [],</span></span><br><span class="line"><span class="undefined">          time: 300,</span></span><br><span class="line"><span class="undefined">        &#125;, param);</span></span><br><span class="line"><span class="javascript">        throttle(<span class="literal">true</span>, fn);</span></span><br><span class="line"><span class="javascript">        fn.__throttleID = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">          fn.apply(p.context, p.args);</span></span><br><span class="line"><span class="undefined">        &#125;, p.time);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">moveHandler</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'move:'</span>,e.offsetX,e.offsetY);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onmousemove=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">      throttle(moveHandler,&#123;args:[e]&#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>思想：节流器的核心思想是创建计时器，延迟回调函数执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;节流模式（Throttler）：对重复的业务逻辑进行节流控制，执行最后一次操作并取消其他操作，以提高性能。&lt;br&gt;用处：浏览器中的scroll、mouseover、mouseenter、mouseleave、resize等事件的处理函数被连续重复触发，很多情况下，只需要对最后一次触发做出反应，这时就要用到节流模式。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://fsysfq.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="节流模式" scheme="http://fsysfq.top/tags/%E8%8A%82%E6%B5%81%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>react-redux源码分析</title>
    <link href="http://fsysfq.top/2017/05/01/react-redux%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://fsysfq.top/2017/05/01/react-redux源码分析/</id>
    <published>2017-05-01T11:19:32.000Z</published>
    <updated>2018-07-06T06:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>阅读感想：</p><ol><li>阅读源码前，必须对项目对外暴露的API，有大致的了解。</li><li>有了上面的基础，开始从入口，进行阅读。</li><li>阅读常用的API实现。</li><li>阅读的时候，要猜。由功能猜实现，对源码进行理解。</li></ol><blockquote><p>本文是对<a href="mailto:react-redux@5.0.4" target="_blank" rel="noopener">react-redux@5.0.4</a>的源码分析,阅读中添加了注释的代码<a href="https://github.com/sivkun/react-redux-analysis" target="_blank" rel="noopener">react-redux-analysis</a></p></blockquote><p>react-redux的API参考 <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" target="_blank" rel="noopener">链接</a></p><p>react-redux在5.0中做出了很大改动。 <a href="https://github.com/reactjs/react-redux/pull/416" target="_blank" rel="noopener">请参考</a></p><p>作者为了react-redux在实际项目中可定制化，重写了<code>connect</code>,分成了很多模块组件。<br>让<code>connect</code>作为了<code>connectAdvanced</code>的门面（外观模式）。</p><p>更新后的文件结构如下：<br><img src="/2017/05/01/react-redux源码分析/react-redux结构.png" alt="react-redux文件结构"></p><a id="more"></a><h1 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h1><p>provider组件包裹整个APP，通过Props将store传入。使的通过connect()(component)生成的容器组件，可以获取到store。<br>Provider使用方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;MyRootComponent /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  rootEl</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure></p><p>如何实现？</p><p>Provider组件通过使用react提供的顶层API <code>context</code>特性实现。<br><code>getChildContext</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">store</span>: <span class="keyword">this</span>.store, <span class="attr">storeSubscription</span>: <span class="literal">null</span> &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><code>childContextTypes</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Provider.childContextTypes = &#123;</span><br><span class="line">  store: storeShape.isRequired,</span><br><span class="line">  storeSubscription: subscriptionShape</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，通过connect()(wrappedcomponent)生成的容器组件中，可以通过设置<code>contextTypes</code>,<br>在组件内部可以通过<code>this.context.store</code>获取到store,对状态进行操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Component.contextTypes = &#123;</span><br><span class="line">  store: storeShape.isRequired,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h1><p>首先通过react-redux的链接充分理解connect的使用。<br><code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</code><br>作用是，在Redux store和React Component之间建立起联系。<br><code>connect</code>方法是<code>connectAdvanced</code>的门面（外观模式）,为大多数情况下的使用，提供便利的API，<br>也就是说<code>connect</code>方法简化了<code>connectAdvanced</code>的API。<br><code>connect</code>的具体接口如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">connect(</span><br><span class="line">   mapStateToProps(state,ownProps)=&gt;stateProps:<span class="built_in">Object</span>, </span><br><span class="line">   mapDispatchToProps(dispatch, ownProps)=&gt;dispatchProps:<span class="built_in">Object</span>, </span><br><span class="line">   mergeProps(stateProps, dispatchProps, ownProps)=&gt;props:<span class="built_in">Object</span>,</span><br><span class="line">   options:<span class="built_in">Object</span></span><br><span class="line">  )=&gt;(</span><br><span class="line">    component</span><br><span class="line">  )=&gt;component</span><br></pre></td></tr></table></figure></p><h2 id="可以做出如下猜想判断："><a href="#可以做出如下猜想判断：" class="headerlink" title="可以做出如下猜想判断："></a>可以做出如下猜想判断：</h2><ol><li>使用该方法后，返回一个包裹原先定义的xxxComponent的新的newReactComponent</li><li>connect方法执行后返回<code>wrapWithConnect</code>函数，在其内部形成一个闭包，保存了传入的mapToProps(选择器)等信息。<br>并且执行该函数后，返回包裹后的newReactComponent，而该组件通过render原组件，形成对原组件的封装。</li><li>渲染页面需要store tree（通过<code>context</code>获取<code>provider</code>中的<code>store</code>）中的<code>state</code>片段，变更<code>state</code>需要<code>dispatch action</code>，这两处信息，就是在调用connect时，作为参数传入的<code>mapStateToProps</code>函数和<code>mapDispatchToProps</code>函数，这两个函数过滤<code>state</code>和<code>ownprops</code>后生成的<code>props</code>，connect包裹后形成的newReactComponent组件通过设置原组件的props属性传入信息到原组件。</li></ol><p><strong>选择器</strong><br>更多<a href="https://github.com/reactjs/reselect" target="_blank" rel="noopener">参考reselect</a><br><code>mapStateToProps</code><br>顾名思义该函作用是 state映射生成Props，可以看做是一个selector<br>react-redux内部调用该函数，并把state作为参数传入<br><code>mapDispatchToProps</code><br>顾名思义该函作用是 dispatch映射生成Props，可以看做是一个selector<br>在函数定义时，引用外部自定义action，在react-redux内部调用该函数，并把store.dispatch作为参数传入</p><p>以上都是通过react-rdux最常用的方式以及API可以分析出的结果。</p><h2 id="具体实现-connect-js"><a href="#具体实现-connect-js" class="headerlink" title="具体实现 connect.js"></a>具体实现 connect.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createConnect</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  connectHOC = connectAdvanced,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapStateToPropsFactories = defaultMapStateToPropsFactories,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,</span></span></span><br><span class="line"><span class="function"><span class="params">  mergePropsFactories = defaultMergePropsFactories,</span></span></span><br><span class="line"><span class="function"><span class="params">  selectorFactory = defaultSelectorFactory</span></span></span><br><span class="line"><span class="function"><span class="params">&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    mapStateToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    mapDispatchToProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    mergeProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      pure = true,</span></span></span><br><span class="line"><span class="function"><span class="params">      areStatesEqual = strictEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">      areOwnPropsEqual = shallowEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">      areStatePropsEqual = shallowEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">      areMergedPropsEqual = shallowEqual,</span></span></span><br><span class="line"><span class="function"><span class="params">      ...extraOptions</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125; = &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="comment">//结合selectorFactory.js中函数finalPropsSelectorFactory，</span></span><br><span class="line">    <span class="comment">//initXXX的signature是(dispatch,option)=&gt;mapXXXToProps(XXX,ownProps)=&gt;XXXProps，</span></span><br><span class="line">    <span class="comment">//initXXX执行后，就是初始化了参数的XXX函数。</span></span><br><span class="line">    <span class="comment">//可以给mapXXXToProps函数设置dependsOnOwnProps属性，表示是否使用ownProps属性</span></span><br><span class="line">    <span class="keyword">const</span> initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, <span class="string">'mapStateToProps'</span>)</span><br><span class="line">    <span class="keyword">const</span> initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, <span class="string">'mapDispatchToProps'</span>)</span><br><span class="line">    <span class="keyword">const</span> initMergeProps = match(mergeProps, mergePropsFactories, <span class="string">'mergeProps'</span>)</span><br><span class="line">    <span class="keyword">return</span> connectHOC(selectorFactory, &#123;</span><br><span class="line">      <span class="comment">// used in error messages</span></span><br><span class="line">      methodName: <span class="string">'connect'</span>,</span><br><span class="line">       <span class="comment">// used to compute Connect's displayName from the wrapped component's displayName.</span></span><br><span class="line">      getDisplayName: <span class="function"><span class="params">name</span> =&gt;</span> <span class="string">`Connect(<span class="subst">$&#123;name&#125;</span>)`</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes</span></span><br><span class="line">      shouldHandleStateChanges: <span class="built_in">Boolean</span>(mapStateToProps),</span><br><span class="line"></span><br><span class="line">      <span class="comment">// passed through to selectorFactory</span></span><br><span class="line">      initMapStateToProps,</span><br><span class="line">      initMapDispatchToProps,</span><br><span class="line">      initMergeProps,</span><br><span class="line">      pure,</span><br><span class="line">      areStatesEqual,</span><br><span class="line">      areOwnPropsEqual,</span><br><span class="line">      areStatePropsEqual,</span><br><span class="line">      areMergedPropsEqual,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// any extra options args can override defaults of connect or connectAdvanced</span></span><br><span class="line">      ...extraOptions</span><br><span class="line">    &#125;) <span class="comment">//结果返回wrapWithConnect(WrappedComponent)=&gt;newWrapedComponent</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createConnect()</span><br></pre></td></tr></table></figure><p>可以看出<code>connect</code>函数是通过<code>createConnect</code>函数创建。<br><code>createConnect</code>在声明的时候就提供了很多默认参数，内部的<code>connect</code>可以使用这些默认参数。<br><code>connect</code>在声明的时候也提供了很多默认参数，<code>mapStateToProps</code>,<code>mapDispatchToProps</code>,<code>mergeProps</code>,<code>extraOptions</code><br>这些参数是要在<code>connect</code>被调用的时候，由使用者提供的。当然也都可以省略。<br>执行<code>connect(...args)</code>最后返回的是<code>connectHOC(...args)</code>。 而<code>connectHOC = connectAdvanced</code>，<br>可知执行<code>connectAdvanced(...args)</code>返回函数<code>(wrappedcomponent)=&gt;newComponent</code>;<br>其实这个新组件就是connectAdvanced.js中定义的<code>Connect</code>组件（整合了wrappedComponent的props）</p><h2 id="具体实现connectAdvanced-js"><a href="#具体实现connectAdvanced-js" class="headerlink" title="具体实现connectAdvanced.js"></a>具体实现connectAdvanced.js</h2><p>首先看<code>connectAdvanced</code>的signature<code>(selectorFactory,{...options})=&gt;(YourComponent)=&gt;ConnectComponent</code>,<br>使用方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connectAdvanced(<span class="function">(<span class="params">dispatch, options</span>) =&gt;</span> (state, props) =&gt; (&#123;</span><br><span class="line">        thing: state.things[props.thingId],</span><br><span class="line">        saveThing: <span class="function"><span class="params">fields</span> =&gt;</span> dispatch(actionCreators.saveThing(props.thingId, fields)),</span><br><span class="line">      &#125;))(YourComponent)</span><br></pre></td></tr></table></figure><p>在connectAdvanced方法内部定义了要返回的ConnectComponent，构造函数部分代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ...</span></span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">      <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props, context)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.version = version</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.renderCount = <span class="number">0</span></span><br><span class="line">        <span class="comment">//获取store的方式：</span></span><br><span class="line">        <span class="comment">//1.通过props传递store，&lt;connectedComponent store=&#123;innerStore&#125;&gt;</span></span><br><span class="line">        <span class="comment">//2.通过context获取store，&lt;Provider store=&#123;outStore&#125;&gt;</span></span><br><span class="line">        <span class="comment">//通过props获取store的方式优先级更高</span></span><br><span class="line">        <span class="keyword">this</span>.store = props[storeKey] || context[storeKey]</span><br><span class="line">        <span class="keyword">this</span>.propsMode = <span class="built_in">Boolean</span>(props[storeKey])</span><br><span class="line">        <span class="keyword">this</span>.setWrappedInstance = <span class="keyword">this</span>.setWrappedInstance.bind(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        invariant(<span class="keyword">this</span>.store,</span><br><span class="line">          <span class="string">`Could not find "<span class="subst">$&#123;storeKey&#125;</span>" in either the context or props of `</span> +</span><br><span class="line">          <span class="string">`"<span class="subst">$&#123;displayName&#125;</span>". Either wrap the root component in a &lt;Provider&gt;, `</span> +</span><br><span class="line">          <span class="string">`or explicitly pass "<span class="subst">$&#123;storeKey&#125;</span>" as a prop to "<span class="subst">$&#123;displayName&#125;</span>".`</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment">//初始化selector，selector的作用是：通过过滤state和ownProps生成，生成wrappedComponent的props。</span></span><br><span class="line">        <span class="keyword">this</span>.initSelector()</span><br><span class="line">        <span class="comment">//初始化subscription，subscription作用：监听state和ownProps的变化，触发wrappedComponent更新。</span></span><br><span class="line">        <span class="keyword">this</span>.initSubscription()</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">//    ...</span></span><br><span class="line">  <span class="comment">//    ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="如何生成wrappedComponent组件的props的？"><a href="#如何生成wrappedComponent组件的props的？" class="headerlink" title="如何生成wrappedComponent组件的props的？"></a>如何生成wrappedComponent组件的props的？</h3><p>生成props主要是通过selector函数，在构造函数中通过<code>this.initSelector()</code>初始化了<code>this.selector</code>对象。<br>代码分析：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSelectorStateful</span>(<span class="params">sourceSelector, store</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// wrap the selector in an object that tracks its results between runs.</span></span><br><span class="line">  <span class="keyword">const</span> selector = &#123;</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> <span class="title">runComponentSelector</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//此处看出nextProps由sourceSelector函数传入state和props计算得来。</span></span><br><span class="line">        <span class="keyword">const</span> nextProps = sourceSelector(store.getState(), props)</span><br><span class="line">        <span class="keyword">if</span> (nextProps !== selector.props || selector.error) &#123;</span><br><span class="line">          selector.shouldComponentUpdate = <span class="literal">true</span></span><br><span class="line">          selector.props = nextProps</span><br><span class="line">          selector.error = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        selector.shouldComponentUpdate = <span class="literal">true</span></span><br><span class="line">        selector.error = error</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> selector</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  initSelector() &#123;</span><br><span class="line">    <span class="comment">//selectorFactory生成sourceSelector。</span></span><br><span class="line">    <span class="keyword">const</span> sourceSelector = selectorFactory(<span class="keyword">this</span>.store.dispatch, selectorFactoryOptions)</span><br><span class="line">    <span class="comment">//this.selector具有记忆功能，如果通过sourceSelector计算后的nextProps和现在的this.props不同，则说明组件需要更新。</span></span><br><span class="line">    <span class="keyword">this</span>.selector = makeSelectorStateful(sourceSelector, <span class="keyword">this</span>.store)</span><br><span class="line">    <span class="keyword">this</span>.selector.run(<span class="keyword">this</span>.props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//收到新的props时调用</span></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="keyword">this</span>.selector.run(nextProps)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通过this.selector.shouldComponentUpdate判断组件是否需要更新，优化性能。</span></span><br><span class="line">  shouldComponentUpdate() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.selector.shouldComponentUpdate</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>react生命周期<a href="https://facebook.github.io/react/docs/react-component.html" target="_blank" rel="noopener">参考</a><br>初始化挂载阶段</p><ul><li>constructor()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount()</li></ul><p>更新阶段</p><ul><li>componentWillReceiveProps()</li><li>shouldComponentUpdata()</li><li>componentWillUpdate()</li><li>render()</li><li>componentDidUpdate()</li></ul><p>卸载阶段</p><ul><li>componentWillUnmount()</li></ul><h3 id="返回的ConnectComponent是如何渲染wrappedComponent的？"><a href="#返回的ConnectComponent是如何渲染wrappedComponent的？" class="headerlink" title="返回的ConnectComponent是如何渲染wrappedComponent的？"></a>返回的<code>ConnectComponent</code>是如何渲染<code>wrappedComponent</code>的？</h3><p>上源码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> selector = <span class="keyword">this</span>.selector</span><br><span class="line">  selector.shouldComponentUpdate = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (selector.error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> selector.error</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(WrappedComponent, <span class="keyword">this</span>.addExtraProps(selector.props))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码可以看出，在<code>ConnectComponent</code>的<code>render</code>函数中，使用<code>createElement</code>创建了<code>WrappedComponent</code>也就是<code>YourComponent</code>，<br>并且添加了额外的属性<code>this.addExtraProps(selector.props)</code>。</p><h3 id="ConnectComponent是如何监听store变化，然后决定重新渲染的？"><a href="#ConnectComponent是如何监听store变化，然后决定重新渲染的？" class="headerlink" title="ConnectComponent是如何监听store变化，然后决定重新渲染的？"></a><code>ConnectComponent</code>是如何监听store变化，然后决定重新渲染的？</h3><p>我们知道当react组件的state或者props改变，组件就会重新渲染，<br>react提供的方法有<code>setState</code>和<code>forceUpdate</code>这两个方法。<br>可以按照这两个线索寻找。<br>主要代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.initSubscription()</span><br><span class="line">  &#125;</span><br><span class="line">  initSubscription() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!shouldHandleStateChanges) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// parentSub's source should match where store came from: props vs. context. A component</span></span><br><span class="line">    <span class="comment">// connected to the store via props shouldn't use subscription from context, or vice versa(反之亦然).</span></span><br><span class="line">     <span class="comment">//如果组件通过props连接store，则不应该从context获取subscription。</span></span><br><span class="line">    <span class="keyword">const</span> parentSub = (<span class="keyword">this</span>.propsMode ? <span class="keyword">this</span>.props : <span class="keyword">this</span>.context)[subscriptionKey]</span><br><span class="line">    <span class="keyword">this</span>.subscription = <span class="keyword">new</span> Subscription(<span class="keyword">this</span>.store, parentSub, <span class="keyword">this</span>.onStateChange.bind(<span class="keyword">this</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in</span></span><br><span class="line">    <span class="comment">// the middle of the notification loop, where `this.subscription` will then be null. An</span></span><br><span class="line">    <span class="comment">// extra null check every change can be avoided by copying the method onto `this` and then</span></span><br><span class="line">    <span class="comment">// replacing it with a no-op on unmount. This can probably be avoided if Subscription's</span></span><br><span class="line">    <span class="comment">// listeners logic is changed to not call listeners that have been unsubscribed in the</span></span><br><span class="line">    <span class="comment">// middle of the notification loop.</span></span><br><span class="line">    <span class="keyword">this</span>.notifyNestedSubs = <span class="keyword">this</span>.subscription.notifyNestedSubs.bind(<span class="keyword">this</span>.subscription)</span><br><span class="line">  &#125;</span><br><span class="line">  onStateChange() &#123;</span><br><span class="line">    <span class="keyword">this</span>.selector.run(<span class="keyword">this</span>.props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.selector.shouldComponentUpdate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.notifyNestedSubs()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.componentDidUpdate = <span class="keyword">this</span>.notifyNestedSubsOnComponentDidUpdate</span><br><span class="line">      <span class="keyword">this</span>.setState(dummyState)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中这段代码<code>this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this))</code><br>作用是<code>store</code>的变化，就会触发<code>onStateChange</code>，这个函数调用会触发<code>this.setState</code>。这样<code>ConnectComponent</code>组件更新，<br>触发该组件render，同时子组件<code>YourComponent</code>即<code>wrappedComponent</code>的更新也会被触发，<br>为了提高渲染效率， <code>ConnectComponent</code>使用了<code>shouldComponentUpdate</code>判断，是否执行render，<br>如果返回true，不用触发render，则子组件也不必更新。</p><h3 id="Component更新流程"><a href="#Component更新流程" class="headerlink" title="Component更新流程"></a>Component更新流程</h3><p>结合utils/Subscription.js源码，可以理解整个系统中组件的更新流程。<br>如图：<br><img src="/2017/05/01/react-redux源码分析/react-redux-subscription.png" alt="react-redux-subscription"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读感想：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;阅读源码前，必须对项目对外暴露的API，有大致的了解。&lt;/li&gt;
&lt;li&gt;有了上面的基础，开始从入口，进行阅读。&lt;/li&gt;
&lt;li&gt;阅读常用的API实现。&lt;/li&gt;
&lt;li&gt;阅读的时候，要猜。由功能猜实现，对源码进行理解。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;本文是对&lt;a href=&quot;mailto:react-redux@5.0.4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;react-redux@5.0.4&lt;/a&gt;的源码分析,阅读中添加了注释的代码&lt;a href=&quot;https://github.com/sivkun/react-redux-analysis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;react-redux-analysis&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;react-redux的API参考 &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;react-redux在5.0中做出了很大改动。 &lt;a href=&quot;https://github.com/reactjs/react-redux/pull/416&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;请参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者为了react-redux在实际项目中可定制化，重写了&lt;code&gt;connect&lt;/code&gt;,分成了很多模块组件。&lt;br&gt;让&lt;code&gt;connect&lt;/code&gt;作为了&lt;code&gt;connectAdvanced&lt;/code&gt;的门面（外观模式）。&lt;/p&gt;
&lt;p&gt;更新后的文件结构如下：&lt;br&gt;&lt;img src=&quot;/2017/05/01/react-redux源码分析/react-redux结构.png&quot; alt=&quot;react-redux文件结构&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://fsysfq.top/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="react-redux" scheme="http://fsysfq.top/tags/react-redux/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP</title>
    <link href="http://fsysfq.top/2017/04/28/TCPIP/"/>
    <id>http://fsysfq.top/2017/04/28/TCPIP/</id>
    <published>2017-04-28T07:05:53.000Z</published>
    <updated>2018-07-06T06:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP/IP层次模型中，每一层都会对上一层的数据加入包首部，包首部至少包含两个信息：一个是发送端和接收端的信息，另一个是上一层的协议类型。因为这些协议需要程序实现，要控制整个协议流程的运作，必定需要控制信息，因此就需要包的首部，其中包括了协议实现时用到的控制信息。<br><a id="more"></a></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>相关技术包括：MAC寻址、介质共享、非公有网络、分组交换、环路检测、VLAN（Virtual Local Area Network）等，也会涉及作为传输方式的数据链路，如以太网、WLAN（wireless Local Arrea Network）、PPP（Point to Point Protocol点对点协议），数据链路层也可以被视为网络传输中的最小单位。</p><p>FCS</p><p>CSMA：载波监听多路访问</p><p>ATM （Asynchronous Transfer Mode）</p><p>FDDI（Fiber Distributed Data）</p><p>共享介质型网络</p><p>非共享介质网络</p><p><strong>环路检测技术</strong></p><ul><li><p>生成树方式</p><p>生成树协议通过监测网络的结构、禁止某些端口的使用可以有效地消除环路。然而，该端口可以作为发生问题时可绕行的端口。</p><p>生成树方法有一个弊端，就是在发生故障切换网络时需要几十秒的时间。为了解决这个用时过长问题，在IEEE802.1W中定义了一个叫RSTP（Rapid Spanning Tree Protocol）的方法。该方法能将发生问题时的恢复时间缩短到几秒以内。</p></li><li><p>源路由发</p></li></ul><p><strong>VLAN</strong></p><p>如果采用VLAN技术的王巧，就不用实际修改网络布线，只需修改网络的结构即可。VLAN技术附加到网桥/2层交换机上，就可以切断所有VLAN间的通信，因此相比一般的网桥/2层交换机，VLAN  可以过滤多余的包，提高网络的负载效率。</p><p>异构的两个网段之间，就需要利用具有路由功能的交换机（如3层交换机），或在各段中间通过路由器的链接才能实现通信。</p><h2 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h2><p><strong>前导码</strong></p><table><thead><tr><th>8位字节</th><th></th><th></th><th></th><th></th><th></th><th></th><th style="text-align:center">SFD</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>10101010</td><td>10101010</td><td>10101010</td><td>10101010</td><td>10101010</td><td>10101010</td><td>10101010</td><td style="text-align:center">1010101</td><td style="text-align:center">从此往后是帧本体</td></tr></tbody></table><p>以太网帧前端有一个叫做前导码的部分，前导码有0/1交替数字组合而成，表示一个以太网帧的开始，也是对端网卡能够确保与其同步的标志，前导码末尾是一个叫做SFD（Start Frame Delimiter）的域。</p><pre><code>以太网帧本体的前端是以太网的首部，占14字节，分别是6个字节的目标MAC地址、6个字节源MAC地址以及2个字节的上层协议类型。</code></pre><p><strong>以太网帧体格式</strong></p><table><thead><tr><th>目标MAC地址</th><th>源MAC地址</th><th>类型</th><th>数据</th><th>FCS</th></tr></thead><tbody><tr><td>6字节</td><td>6字节</td><td>2字节</td><td>（46~1500字节）</td><td>4字节</td></tr></tbody></table><p><strong>IEEE802.3以太网帧体格式</strong></p><table><thead><tr><th>目标MAC地址</th><th>源MAC地址</th><th>帧长度</th><th>LLC</th><th>SNAP</th><th>数据</th><th>FCS</th></tr></thead><tbody><tr><td>6字节</td><td>6字节</td><td>2字节</td><td>3字节</td><td>5字节</td><td>38~1492字节</td><td>4字节</td></tr></tbody></table><p>FCS：Frame Check Sequence,用它可以检查帧是否有所损坏。在通信传输过程中如果出现电子噪音的干扰，可能会影响发送数据导致码位错乱，因此通过检查这个FCS字段的值可以将那些受到干扰的错误帧丢弃。</p><p>FCS中保存着整个帧除以生成多项式的余数。在接收端也用同样的方式计算，如果FCS的值相同，就判定所接受的帧没有差错。</p><p>IEEE802.3 Ethernet 与一般的以太网在帧的首部上稍有区别。</p><p>带有VLAN标记的交换机之间流动的以太网帧格式</p><table><thead><tr><th>目标MAC地址</th><th>源MAC地址</th><th>Vlan中被的追加字段</th><th>类型</th><th>数据</th><th>FCS</th></tr></thead><tbody><tr><td>6字节</td><td>6字节</td><td>4字节</td><td>2字节</td><td>（46~1500字节）</td><td>4字节</td></tr></tbody></table><p>Vlan中被的追加字段</p><table><thead><tr><th>类型</th><th>优先度</th><th>CFI</th><th>VLAN ID</th></tr></thead><tbody><tr><td>16比特（8100 16进制）</td><td>3比特</td><td>1比特0</td><td>12比特</td></tr></tbody></table><p>CFI:  Canonical Format Indicator，标准格式指示位，当进行源路由时值为1</p><h2 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h2><p>通过PPP建立连接时，通常需要进行用户名密码的验证，并且对通信的两端进行双向的验证。</p><p>在通过电脑进行拨号时，PPP已经在软件中实现。因此，那些插入或删除“0”的操作或FCS计算都交由CPU去处理。这也就是为什么人们常说PPP这种方式给计算机带来大量负荷的原因所在</p><h2 id="PPPoE"><a href="#PPPoE" class="headerlink" title="PPPoE"></a>PPPoE</h2><p>有些互联网结束服务商在以太网上利用PPPoE（PPP over Ethernet）提供PPP功能。</p><p>单纯的以太网没有验证的功能，也没有建立和断开连接的处理，因此无法按时计费。而如果采用PPPoE管理以太网连接，就可以利用PPP的验证等功能使各家ISP可以有效地管理终端用户的使用。</p><h1 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h1><p>TCP/IP的心脏是互联网层。这一层主要由IP和ICMP两个协议组成。</p><p>IP相当于OSI参考模型的第3层</p><p>网络层的主要作用是“实现端点之间的通信”。</p><p>网络层的下一层，数据链路层主要作用是在互连同一种数据链路的节点之间进行包的传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即时是在不同的数据链路上也能实现两端节点之间的数据包传输。</p><p>数据链路层提供直连两个设备之间的通信功能。预支相比，作为网络层的IP则负责在没有直连的两个网络之间进行通信传输。</p><h2 id="IP基础知识"><a href="#IP基础知识" class="headerlink" title="IP基础知识"></a>IP基础知识</h2><h3 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h3><p>​    路由控制是指将分组数据发送到最终目标地址的功能。</p><ul><li><p>发送数据至最终目标地址</p><p>Hop译为中文叫“跳”。它是指网络中的一个区间。IP包正是在网络中一个跳间被转发。因此IP路由也叫做多跳路由。在每一个区间内决定着包在下一跳被转发的路径。</p><p>数据链路实现某一区间（一跳）内的通信。而IP实现直至最终目标地址的通信（点对点）</p><blockquote><p>一跳的范围</p><p>一跳是指利用数据链路层以下分层的功能传输数据帧的一个区间。</p><p>以太网等数据链路中使用MAC地址传输数据帧。此时的一跳是指从源MAC地址到目标MAC地<br>址之间传输帧的区间。也就是说它是主机或路由器网卡不经其它路由器而能直接到达的相邻主<br>机或路由器网卡之间的一个区间。在一跳的这个区间内，电缆可以通过网桥或交换机集线器相<br>连，不会通过路由器或网关相连。</p></blockquote><p>​    多跳路由是指路由器或主机在转发IP数据包时只指定下一个路由器或主机，而不是将到最终目标地址为止的所有桐庐全都指定出来。因为每一个区间在转发IP数据包时会分别指定下一跳的操作，直至包达到最终目标地址。<br>​    “Ad Hoc”是指具有偶然性的、在各跳之间无计划传输的意思。尤其在谈到IP时经常会用到该词。</p><p>​    IP包被转发到途中的某个路由器时，实际上是装入数据链路层的数据帧以后再被送出。以以太网为例，目标MAC地址是下一个路由器的MAC地址。</p><ul><li>路由控制表</li></ul></li></ul><p>​        为了将数据包发给目标主机，所有主机都维护着一张路由表。该表记录IP数据在下一步应该发给哪个路由器。IP包将根据这个路由表在各个数据连路上传输。</p><h3 id="数据链路的抽象化"><a href="#数据链路的抽象化" class="headerlink" title="数据链路的抽象化"></a>数据链路的抽象化</h3><p>​    IP是实现多个数据链路之间通信的协议。数据链路根据种类的不同各有特点。对这些不同数据链路的相异特性进行抽象化也是IP的重要作用之一。数据链路的地址可以被抽象化为IP地址。因此，对IP的上一层来说，不论底层数据链路使用以太网还是无线LAN亦或是PPP，都将被一视同仁。</p><p>​    不同数据链路有个最大的区别，就是他们各自的最大传输单位（MTU：maximum Transmission Unit）不同。就好像人们在邮寄包裹或行李时有各自的大小限制一样。</p><p>​    为了解决这个问题，IP进行分片处理。是指将较大的IP包分成多个较小的IP包。分片的包到了对端目标地址以后会被组合起来传给上一层。即从IP的上层看，它完全可以忽略数据包在途中的各个数据链路上的MTU，而只需要按照源地址发送的长度接受数据包。IP就是以这种方式抽象化了数据链路层，使得从上层更不容易看到底层网络结构的细节。</p><h3 id="IP属于面向无连接型"><a href="#IP属于面向无连接型" class="headerlink" title="IP属于面向无连接型"></a>IP属于面向无连接型</h3><p>面向无连接的方式下可能会有很多冗余的通信。</p><p>​    为什么IP要采用面向无连接呢？</p><p>​    主要有两点原因：一时为了简化，而是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每一个连接本身就是一个相当繁琐的事情。此外，每一次通信之前都要事先建立连接，优惠降低处理速度。需要有连接时，可以委托上一层提供此服务。因此，IP为了事先简单化与高速化采用面向无连接的方式。</p><blockquote><p>为了提高可靠性，上一层的TCP采用面向有连接型。</p><p>​    IP提供尽力服务（Best Effort），意指“为了把数据包发送到最终目标地址，尽最大努力。”然而，它并不做“最终收到与否的验证”。IP数据包途中可能发生丢包、错位、以及数据量翻倍等问题。如果发送端的数据未能真正发送到对端目标主机会造成严重的问题。</p><p>​    因此提高通信的可靠性很重要。TCP就提供这种功能。如果说IP只负责将数据发给目标主机，那么TCP则负责保证对端主机确实接收到数据。</p><p>​    为什么不让IP具有可靠传输的能力，从而把两种协议合并到一起呢？</p><p>​    原因在于，如果一种协议规定所有功能和作用，那么该协议的具体实施和编程就会变得非常复杂，无法轻易实现。相比之下，按照网络分层，明确每层协议的作用和责任以后，针对每层具体的协议进行编程会更加有利于该协议的实现。</p><p>​    网络通信中如果能进行有效分层，就可以明确TCP与IP各自协议的最终目的，也有利于后续对这些协议进行扩展和性能上的优化。分层也简化了每个协议的具体实现。互联网能够发展到今天，与网络同喜你的分层密不可分。</p></blockquote><h2 id="IP地址的基础知识"><a href="#IP地址的基础知识" class="headerlink" title="IP地址的基础知识"></a>IP地址的基础知识</h2><p>​    在用TCP/IP通信时，用IP地址识别主机和路由器。为了保证正常通信，有必要为每一个设备配置正确的IP地址。在互联网通信中，全世界都必须设定正确的IP，否则，根本无法实现正常的通信。IP地址就像是TCP/IP通信的一块基石。</p><h3 id="IP地址的定义"><a href="#IP地址的定义" class="headerlink" title="IP地址的定义"></a>IP地址的定义</h3><p>​    IP地址由32位正整数表示，以每8位为一组，分成四组，每组以“.”分割开，再将每组书转换为十进制。2^32=4294967296 大约43亿。</p><p>​    实际上，每一台主机上的每一块网卡（NIC）都得设置IP地址。一个网卡可以设置多个IP地址。让43亿台计算机全部联网其实是不可能的。</p><p>根据一种可以更换IP地址的技术NAT，可连接计算机数超过43亿台。</p><h3 id="IP地址由网络和主机两部分标识组成"><a href="#IP地址由网络和主机两部分标识组成" class="headerlink" title="IP地址由网络和主机两部分标识组成"></a>IP地址由网络和主机两部分标识组成</h3><p>​    网络标识在数据链路的每一个段配置不同的值。网络标识必须保证相互连接的每一段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。</p><p>​    可以通过设置网络地址和主机</p><p>址，在相互连接的整个网络中保证每台主机IP地址都不会相互重叠。即IP地址具有了唯一性。</p><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><p>IP地址分为4个级别，分别为A类、B类、C类、D类。它根据IP地址中的第一位到第四位的比特列对网络标识和主机标识进行区分。</p><ul><li><p>A类地址</p><p>A类：以‘0’开头的资质。从第一位到第八位是他的网络标识。即0.0.0.0~127.0.0.0是A类的网络地址。A类地址的后24位相当于主机标识。因此一个网段内可容纳的主机地址上限为2^24-2=16777214个</p></li><li><p>B类地址</p><p>B类IP地址是前两位为‘10’的地址。从第一位到第十六位是他的网络标识。用十进制表示的话，128.0.0.1~191.255.0.0.B类地址的后16位相当于主机标识。因此，一个网段可容纳的主机地址上限为2^16-2=65534</p></li><li><p>C类</p><p>前三位“110”，1到24网络标识，192.168.0.0~239.255.255.255.0，容纳主机地址上限为2^8-2=254个。</p></li><li><p>D类</p><p>前四位“1110”的地址。1-32网络标识，十进制224.0.0.0~239.255.255.255是D类网络地址。D类没有主机标识，常用于多播。</p></li></ul><p><strong>关于分配IP主机地址的注意事项</strong></p><p>​    在分配IP地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为0或全部为1.因为全部为0表示对应的网络地址或IP地址不可获知的情况下才使用。而全部为1的主机地址通常作为广播地址。</p><h3 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h3><ul><li><p>两种广播</p><p>广播分为本地刚播和直接广播两种</p><p>在本网络内的广播叫做本地广播。例如网络地址为192.168.0.0/24的情况下，广播地址是192.168.0.255.因为这个广播地址的IP包会被路由器屏蔽，所以不会叨叨192.168.0.0/24意外的其它链路。</p><p>在不同网络间的广播叫做直接广播。例如网络地址为192.168.0.0/24的主机箱192.168.1.255/24的目标地址发送IP包。收到这个包的路由器，将数据转发给192.168.1.0/24，从而使得所有192.168.1.1~192.168.1.254的主机都能收到这个包。（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发）</p></li></ul><h3 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h3><p>多播是既可以穿透路由器，又可以实现只给那些必要的组发送数据包的技术</p><p>多播使用D类地址。</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>​    现在，一个IP地址的网络标识和主机标识已不再受限于改地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比A类、B类、C类更小粒度的网络。这种方式实际上就是将原来A类、B类C类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。</p><p>​    引入子网以后，一个IP地址就有了两种识别码。一是IP地址本身，另一个是表示网络部的子网掩码。</p><p>​    IP 地址    172.   20.  100.  52</p><p>​    子网掩码 255. 255.  255.  192</p><p>​    网络地址 172.  20.  100.  0</p><p>​    子网掩码 255. 255. 255.  192</p><p>​    广播地址 172.  20. 100. 63</p><p>​    子网掩码 255. 255. 255. 192</p><p>另一种表示方式：</p><p>​    IP地址 172.20.100.52  /26</p><p>​    网络地址 172.20.100.0  /26</p><p>​    广播地址 172.20.100.63  /26</p><h3 id="全局地址与私有地址"><a href="#全局地址与私有地址" class="headerlink" title="全局地址与私有地址"></a>全局地址与私有地址</h3><p>私有网络的IP地址</p><p>10.0.0.0~10.255.255.255 （10/8）A类</p><p>172.16.0.0~172.31.255.255（172.16/12）B类</p><p>192.168.0.0~192.168.255.255(192.168/16) C类</p><p>包含在这个范围内的IP地址都属于私有IP,在此之外的IP地址称为全局IP</p><p>私有IP最在没有计划连接互联网，而只用于互联网之外的网络。然而，当一种能够互换私有IP与全局IP的NAT技术诞生以后，配有私有地址的主机与配有全局地址的互联网主机实现了通信。全局地址基本上要在整个互联网范围内保持唯一，但私有地址不需要。只要在同一个域里保证唯一即可。</p><h2 id="路由控制-1"><a href="#路由控制-1" class="headerlink" title="路由控制"></a>路由控制</h2><p>IP数据报要想发送到目标地址，需要有路由控制的机制。通信的主机和路由器都必须持有一张路由控制表，才能进行数据包的发送。</p><p>路由控制表形成方式：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。该表是由一个叫做“路由协议”的协议制作而成。</p><h3 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h3><p>​    路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</p><p>​    <strong>默认路由</strong></p><p>​    默认路由是指路由表中任何一个地址都能与之匹配的记录，一般标记为0.0.0.0/0或default。这里的0.0.0.0/0并不是指IP地址是0.0.0.0。由于后面是“/0”,所以并没有标识IP地址。它只是为了避免人门误以为0.0.0.0是IP地址。有时默认路由也被标记为default，但是在计算机内部和路由协议的发送过程中还是以0.0.0.0/0进行处理</p><p>​    <strong>主机路由</strong></p><p>​    “IP地址/32”也被称为主机路由。例如，192.168.153.15/32就是一种主机路由。它的意思是整个IP地址的所有位都将参加路由。进行主机路由，意味着要基于主机上网卡上配置的IP地址本身，而不是基于地址的网络地址部分进行路由。</p><p>​    <strong>环回地址</strong></p><p>​    环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。计算机使用一个特殊的IP地址127.0.0.1作为环回地址。使用这个IP或主机名时，数据包不会流向网络。</p><h3 id="路由控制表的聚合"><a href="#路由控制表的聚合" class="headerlink" title="路由控制表的聚合"></a>路由控制表的聚合</h3><p>​    利用网络地址的比特分布可以有效地进行分层配置。对内即使有多个子网掩码，对外呈现出的也是同一个网络地址。这样可以更好地构建网络，通过路由信息聚合可以有小弟减少路由表的条目。</p><h2 id="IP分割处理与再构成处理"><a href="#IP分割处理与再构成处理" class="headerlink" title="IP分割处理与再构成处理"></a>IP分割处理与再构成处理</h2><p>数据链路不同，最大传输单元（MTU）则相异。鉴于IP属于数据链路上一层，它必须首先与不同数据链路的MTU大小。IP抽象化了底层的数据链路。</p><p>以太网的默认MTU是1500字节，因此4342字节的IP数据包无法在一个帧中发送完成。这时，路由器将此IP数据包划分成3个分片进行发送。而这种分片处理只要路由器认为有必要，会周而复始地进行。</p><p>​    经过分片后的IP数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</p><p>​    现实中无法保证IP数据报是否经由同一个路径传送。因此途中即时等待片刻，数据包也有可能无法到达目的地。此外，拆分之后的每个分片也有可能会途中丢失。在目标主机上进行分片的重组时，可能有一部分包会延迟到达。因此，一般会从第一数据报的分片到达的那一刻起等待约30秒再进行处理。</p><p>​    IP首部中的“片偏移”字段表示分片之后每个分片在用户数据中的相对位置和该分片之后是否还有后续其它分片。</p><h3 id="路径MTU发现"><a href="#路径MTU发现" class="headerlink" title="路径MTU发现"></a>路径MTU发现</h3><p>路径MTU（Path MTU）是指从发送端主机到接收端主机之间不需要分片时最大MTU的大小。即路径中存在的所有数据链路中最小的MTU。</p><h2 id="IPv4首部"><a href="#IPv4首部" class="headerlink" title="IPv4首部"></a>IPv4首部</h2><p>​    通过IP进行通信时，需要在数据的前面加入IP首部信息。IP首部中包含着用于IP协议进行发包控制时所有的必要信息。了解IP首部结构，也就能够对IP所提供的功能有一个详细的把握。</p><p><img src="/2017/04/28/TCPIP/IPv4首部.png" alt="IPv4首部"></p><ul><li><p>版本</p><p>由4比特构成，表示标识IP首部的版本号。IPv4的版本号即为4，因此在这个字段上的值也是“4”</p></li><li><p>首部长度（IHL：Internet Header Length）</p><p>由4比特构成，标明IP首部的大小，单位为4字节（32比特）。对于没有可选项的IP包，首部长度则设置为“5”。也就是说，当没有可选项时，IP首部的长度为20字节（4*5=20）</p></li><li><p>区分服务（TOS：Type Of Service）</p><p>由8比特构成，用来表明服务质量。每一位的具体含义如下：</p></li></ul><table><thead><tr><th>比特</th><th>含义</th></tr></thead><tbody><tr><td>0 1 2</td><td>优先度（这三位的值区间0~7,0到7表示优先度从低到高）</td></tr><tr><td>3</td><td>最低延迟</td></tr><tr><td>4</td><td>最大吞吐</td></tr><tr><td>5</td><td>最大可靠性</td></tr><tr><td>6</td><td>最小代价</td></tr><tr><td>（3~6）</td><td>最大安全</td></tr><tr><td>7</td><td>未定义</td></tr></tbody></table><p>  ​    这几个值通常由应用指定。但是目前几乎所有的网络都无视这几个字段。实现TOS控制极其复杂。但是现在已经有人提出将TOS字段本身再划分为DSCP和ECN两个字段的建议</p><ul><li><p>DSCP段与ECN段</p><p>DSCP（Differential Service Codepoint，差分服务代码点），现在统称DiffServ，用来进行质量控制。</p><p>ECN（Explicit Congestion Notification，显示拥塞通告）用来报告网络拥堵情况。</p></li></ul><ul><li>总长度（Total Length）</li></ul><p>  表示IP首部与数据部分结合起来的总字节数。该字段长16比特。因此IP包的最大长度为2^16=65535</p><ul><li><p>标识（ID：Identification）</p><p>16比特，用于分片重组。同一个分片的标识值相同，不同分别片的标识值不同。通常，发送一个IP包，它的值也逐渐递增。此外，即时ID相同，如果目标地址、原地址或协议不同的话，也会被认为是不同的分片。</p></li></ul><ul><li><p>标志（Flags）</p><p>由3比特构成，表示包被分片的相关信息。</p></li></ul><table><thead><tr><th>比特</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>未使用。现在必须是0</td></tr><tr><td>1</td><td>指示是否进行分片，值为0可以分片，1不能分片</td></tr><tr><td>2</td><td>包被分片的情况下，表示是否为最后一个包，值为0表示是最后一个分片的包，1表示分片中段的包</td></tr></tbody></table><ul><li><p>片偏移（FO：Fragment Offset）</p><p>由13比特构成，用来标识被分片的每一个分段相对于原始数据的位置。第一个分片对应的值为0。由于FO域占13位，因此最多可以表示2^13=8192个相对位置。单位为8字节，因此最大可表示原始数据8*8192=65536字节的位置。</p></li><li><p>生存时间（TTL：Time To Live）</p><p>由8比特构成，它最初的意思是以秒为单位记录当前包在网络上应该生存的期限。然而，在实际中它是指可以中转多少个路由器的意思。每经过一个路由器，TTL会减少1，直到变成0则丢弃该包。</p></li><li><p>协议（Protocol）</p><p>由8比特构成，表示IP首部的下一个首部隶属于哪个协议。</p></li><li><p>首部校验和（Header Checksum）</p><p>由16比特构成，也叫IP首部校验和。该字段值校验数据报的首部，不校验数据部分。</p></li><li><p>源地址（Source Address）</p><p>32比特，表示发送端IP地址</p></li><li><p>目标地址（Destination  Address)</p></li><li><p>可选项（Options）</p><p>长度可变，通常只在进行实验或诊断时使用。该字段包含如下几点信息:</p><ol><li>安全级别</li><li>源路径</li><li>路径记录</li><li>时间戳</li></ol></li><li><p>填充</p><p>也称为填充物。在有可选项的情况下，首部长度可能不是32比特的整数倍。为此，通过向字段填充0，调整位32比特的整数倍。</p></li><li><p>数据（Data）</p><p>存入数据。将IP上层协议的首部也作为数据进行处理。</p></li></ul><h1 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h1><p>​    IP旨在让最终目标主机收到数据包，但是在这一过程中仅仅有IP是无法实现通信的。必须还有能够解析主机名称和MAC地址的功能，以及数据包在发送过程中异常情况处理的功能。还会涉及IP必不可少的其他功能。</p><p>​    IP的辅助技术，具体包括DNS、ARP、ICMP、ICMPv6、DHCP、NAT等。还包括如：IP隧道、IP多播、IP任播、质量控制（Qos）以及网络阻塞的显示通知和Mobile IP技术。</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。</p><p>nslookup  域名  进行查询IP地址</p><p>根域名服务器IP地址相关的最新情况可以参考 <a href="http://www.internic.net/zones/named.root" target="_blank" rel="noopener">http://www.internic.net/zones/named.root</a></p><ul><li><p>解析器（Resolver）</p><p>进行DNS查询的主机和软件叫做DNS解析器。用户使用的工作站或个人电脑都属于解析器。一个解析器至少要注册一个以上域名服务器的IP地址。通常，它至少包括组织内部的域名服务器的IP地址。</p></li></ul><h3 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h3><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>​    只要确定了IP地址，就可以向这个目标地址发送IP数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个IP地址所对应的MAC地址。</p><p>​    ARP（Address Resolution Protocol）：是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不再同一链路上时，可以通过ARP查找下一跳路由器的MAC地址。不过ARP只 适用于IPv4，不能用于IPv6.IPv6中可以用ICMPv6代替ARP发送邻居探索消息。</p><h3 id="ARP的工作机制"><a href="#ARP的工作机制" class="headerlink" title="ARP的工作机制"></a>ARP的工作机制</h3><p>ARP是借助ARP请求与ARP响应两种类型的包确定MAC地址的。</p><p>假定主机A向同一链路上的主机B发送IP包，主机A的IP地址为172.20.1.1，主机B的IP地址为172.20.1.2，他们互不知道对方的MAC地址。</p><p>​    主机A为了获得主机B的MAC地址，起初要广播发送一个ARP请求包。这个包中包含了想要了解其MAC地址的主机的IP地址。由于广播的包可以被同一个链路上所有的主机或路由器接受，因此ARP的请求包也就会被这同一个连路上所有的主机和路由器进行解析。如果ARP请求包中的目标IP地址和自己的IP地址一致，那么这个节点就将自己的MAC地址塞入ARP响应包返回给主机A. 通常获取到MAC地址后会缓存一段时间。</p><p>arp -a  获取IP和MAC对应关系</p><p>​    根据ARP可以动态地进行地址解析，因此，在TCP/IP的网络构造和网络通信中无需实现知道MAC地址究竟是什么，只要有IP地址即可。</p><h3 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h3><p>​    RARP（Reverse Address Resolution Protocol）是将ARP反过来，从MAC地址定位IP地址的一种协议。例如将打印机服务器等小型切入是设备接入到网络时就经常会得到。</p><p>​    对于使用嵌入式设备时，会遇到没有任何输入接口或无法通过DCHP动态获取IP地址的情况。就可以使用RARP。为此，需要架设一台RARP服务器，从而在这个服务器上注册设备的MAC地址及其IP地址。然后再将这个设备接入到网络，插电启动设备时，该设备会发送一条“我的MAC地址是—，请告诉我，我的IP地址应该是什么”的请求信息。RARP服务器接收到这个消息后返回类似于“MAC为—的设备，IP地址为—-”的信息给这个设备。而设备就根据从RARP服务器所收到的应答信息设置自己的IP地址。</p><h3 id="代理ARP"><a href="#代理ARP" class="headerlink" title="代理ARP"></a>代理ARP</h3><p>通常ARP包会被路由器隔离，但是采用代理ARP的路由器可以将ARP请求转发给邻近的网段。由此，两个以上网段的节点之间可以像在同一个网段中一样进行通信。</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>ICMP的主要功能包括，确认IP包是否成功送达目标地址，通知在发送过程中IP包被丢弃的具体原因，改善网络设置等。</p><p>在IP通信中如果某个IP包因为某种原因未能到达目标地址，那么这个具体的原因将由ICMP负责通知。</p><p>ICMP的消息大致可以分为两类：（1）通知出错原因的错误消息。（2）另一类是用于诊断的查询消息。</p><table><thead><tr><th>类型（十进制）</th><th>内容</th></tr></thead><tbody><tr><td>0</td><td>回送应答（Echo Reply）</td></tr><tr><td>3</td><td>目标不可达（Destination UNreachable）</td></tr><tr><td>4</td><td>原点抑制（Source Quench）</td></tr><tr><td>5</td><td>重定向或改变路由（Redirect）</td></tr><tr><td>8</td><td>回送请求（Echo Request）</td></tr><tr><td>9</td><td>路由请求（Router Advertisement）</td></tr><tr><td>10</td><td>路由请求（Router Solicitation）</td></tr><tr><td>11</td><td>超时（TIme Exceeded）</td></tr><tr><td>17</td><td>地址子网请求（Address Mask Request）</td></tr><tr><td>18</td><td>地址子网应答（Address Mask Reply）</td></tr></tbody></table><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>为了实现自动设置IP地址、统一管理IP地址分配，就产生了DHCP（Dynamic Host Configuration Protocol）协议。设备即插即用</p><p>使用DHCP之前，首先要架设一台DHCP服务器（很多时候由路由器充当）。然后将DHCP所要分配的IP地址设置到服务器上 。此外还需要将响应的子网掩码、路由控制信息以及DNS服务器的地址等设置到服务器上。</p><p>为了检查所要分配的IP地址以及分配了的IP地址是否可用，DHCP服务器或DHCP客户端必须具备以下功能：</p><ul><li><p>DHCP服务器</p><p>在分配IP地址前发送ICMP回送请求包（ping），确认没有返回应答。</p></li><li><p>DHCP客户端</p><p>针对DHCP那里获取的IP地址发送ARP请求包，确认没有返回应答。</p><p>在获得IP地址之前在做这种事先处理可能会耗一点时间，但是可以安全地进行IP地址分配</p></li></ul><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在链接互联网时转而使用全局IP地址的技术。出转换IP地址外，还出现了可以转换TCP、UDP端口号的NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局IP地址与多个主机的通信。</p><p>​    在NAT（NAPT）路由器的内部，有一张自动生成的用来转换地址表。</p><p><img src="/2017/04/28/TCPIP/NAPT.png" alt="NAPT"></p><h3 id="NAT的潜在问题"><a href="#NAT的潜在问题" class="headerlink" title="NAT的潜在问题"></a>NAT的潜在问题</h3><p>由于NAT（NATP）都依赖于自己的转换表，因此会有以下几点限制：</p><ul><li>无法从NAT的外部向内部服务器建立连接</li><li>转换表的生成与转换操作都会产生一定的开销</li><li>通信过程中一旦NAT遇到异常需重新启动时，所有的TCP连接都将被重置。</li><li>即时备置两台NAT做容灾备份，TCP连接还是会被断开。</li></ul><h3 id="解决NAT的潜在问题与NAT穿越"><a href="#解决NAT的潜在问题与NAT穿越" class="headerlink" title="解决NAT的潜在问题与NAT穿越"></a>解决NAT的潜在问题与NAT穿越</h3><ol><li><p>改用IPv6</p></li><li><p>即使是在一个没有NAT的环境里，根据所制作的应用，用户可以完全忽略NAT的存在而进行通信。在NAT内测（私有IP地址的一边）主机上运行的应用为了生成NAT转换表，需要先发送一个虚拟的网络包给NAT的外侧。而NAT并不知道这个虚拟包究竟是什么，还是会照样读取包首部中的内容并自动生成一个转换表。这是，如果转换表构造合理，那么还能实现NAT外侧的主机与内测的主机建立连接进行通信。此外，应用还可以与NAT路由器进行通信生成NAT表，并通过一定的方法将NAT路由器上附属的全局IP地址传给应用。</p><p>如此一来，NAT外侧与内测可以进行通信，这种现象叫做“NAT穿越”。于是NAT哪个“无法从NAT外部向内部服务器建立连接”的问题也就迎刃而解了。</p></li></ol><h2 id="IP隧道、IP多播、IP任播"><a href="#IP隧道、IP多播、IP任播" class="headerlink" title="IP隧道、IP多播、IP任播"></a>IP隧道、IP多播、IP任播</h2><p><strong>IP隧道</strong></p><p>一般情况下，紧接着IP首部的是TCP或UDP的首部。然而，现在应用当中“IP首部后面还是IP首部”或者“IP首部的后面是IPv6的首部”等情况与日俱增。这种在网络层的首部后面继续追加网络层首部的通信方法就做“IP隧道”。</p><p><img src="/2017/04/28/TCPIP/IP隧道.png" alt="IP隧道"></p><p><strong>IP多播</strong></p><p><img src="/2017/04/28/TCPIP/IGMP（MLD）多播.png" alt="IGMP（MLD）多播"></p><p><strong>IP任播</strong></p><p>IP任播是指为哪些提供同一种服务的服务器配置同一个IP地址，并与最近的服务器进行通信的一种方法。选择哪个服务器由路由协议的类型和设置方法决定。</p><p>IP任播的应用中最有名的当属DNS根域名服务器。</p><p>IP任播机制，它无法保证将第一个包和第二个包发送给同一个主机。这在面向非连接的UDP发出请求而无需应答的情况下没有问题，但是对面向连接的TCP通信或在UDP中要求通过连续的多个包进行通信的情况，就显得力不从心了。</p><p><img src="/2017/04/28/TCPIP/IP任播.png" alt="IP任播"></p><h1 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h1><p>​    在TCP/IP中能够实现传输层功能的、具有代表性的协议是TCP和UDP</p><ul><li><p>TCP</p><p>​    TCP是面向连接的、可靠的刘协议。流就是指不间断的数据结构，你可以把它想象成排水管道中的水流。当应用程序采用TCP发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。例如：在发送端应用程序发送了10次100字节的消息，那么在接收端，应用程序有可能会受到一个1000字节连续不间断的数据。因此在TCP通信中，发送端应用可以在自己所要发送的消息中设置一个表示长度或间隔的字段信息。</p><p>​    TCP为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”，“拥塞控制”、提高网络利用率等众多功能。</p></li><li><p>UDP</p><p>​    UDP是不具有可靠传输性的数据包协议。细微的处理它会交给上层的应用去完成。在UDP的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p></li></ul><h2 id="TCP与UDP区分"><a href="#TCP与UDP区分" class="headerlink" title="TCP与UDP区分"></a>TCP与UDP区分</h2><p>​    TCP用于在传输层有必要实现可靠传输的情况。</p><p>​    UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。如IP电话，广播。。</p><p>​    TCP和UDP应该根据应用的目的按需使用。</p><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>​    端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p><p>​    TCP/IP或UDP/IP通信中通常采用5个信息来识别一个通信：源IP地址、目标IP地址、协议号、源端口号、目标端口号。只要其中某一项不同，则被认为是其它通信。</p><p>​    数据到达IP层后，会先检查IP首部中的协议号，再传给响应协议的模块。如果是TCP则传给TCP模块、如果是UDP则传给UDP模块去做端口号的处理。即使是同一个端口号，由于传输协议是各自独立地进行处理，因此相互之间不会受到影响。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP（User Datagram Protocol）</p><p>​    UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种极致。</p><p>UDP常用于以下几个方面：</p><ul><li>包总量较少的通信（DNS、SNMP等）</li><li>视频、音频等多媒体通信（即时通信）</li><li>限定于LAN等特定网络中的应用通信</li><li>广播通信（广播、多播）</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>​    UDP是一种没有复杂控制，提供面向无连接通信服务的一种协议。换句话说它将部分控制转移给应用程序去处理，自己却只提供作为传输层协议的最基本功能。</p><p>​    TCP与UDP区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发充值，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</p><p>序列号与确认应答号</p><p>重发超时</p><p>连接管理</p><h2 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h2><p>UDP首部由源端口号，目标端口号，包长和校验和组成</p><p><img src="/2017/04/28/TCPIP/UDP首部.png" alt="UDP首部"></p><ul><li><p>源端口号（Source Port）</p><p>​    表示发送端端口号，16位，可选，没有源端口号的时候该字段的值设置为0，可用于不需要返回的通信中。</p></li><li><p>目标端口号（Destination Port）</p><p>​    16位</p></li><li><p>包长度（Length）</p><p>​    保存UDP首部的长度和数据的长度之和。单位为字节（8位字节）</p></li><li><p>校验和（Checksun）</p><p>​    校验和是为了提供可靠地UDP首部和数据而设计。</p></li></ul><h2 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h2><p><img src="/2017/04/28/TCPIP/TCP首部.png" alt="TCP首部"></p><p>​    TCP中没有表示包长度和数据长度的字段。可由IP层获知TCP的包长由，TCP的包长可知数据的长度</p><ul><li><p>源端口号（Source Port）</p><p>发送端端口号，字段长16位</p></li><li><p>目标端口号（Destination Port）</p><p>表示接收端端口号，字段长度16位</p></li><li><p>序列号（Sequence Number）</p><p>​    字段长32位，也叫序号，是指发送数据的位置。每发送一次数据就累加一次该数据字节数的大小。序列号不会从0或1开始，而是在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机。然后再将每转发过去的字节数累加到初始值上表示数据的位置。此外，在建立连接和断开连接时发送的SYN包和FIN包虽然并不懈怠数据，但是也会作为一个字节增加对应的序列号。</p></li><li><p>确认应答号（Acknowledgement Number）</p><p>​    确认应答号字段长度32位。是指下一次应该收到的数据的序列号。实际上，它是指已收到确认应答号减一为止的数据。</p><blockquote><p> 发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。</p></blockquote></li><li><p>数据偏移（Data Offset）</p><p>​    该字段表示TCP所传输的数据部分应该从TCP包的哪个位开始计算，当然也可以把它看做TCP首部的长度。该字段长度长4位，单位为4字节（即32位）。不包括选项字段的话，TCP首部为20字节长，因此数据偏移字段可以设置为5，反之，如果该字段的值为5，那说明从TCP包的最开始到20字节位置都是TCP首部，余下的部分为TCP数据。</p></li><li><p>保留（Reserved）</p><p>​    该字段主要是为了以后扩展时使用，其长度为4位。一般设置为0，但即使收到的包在该字段不为0，此包也不会被丢弃。</p></li><li><p>控制位（Control Flag）</p><p>​    字段长为8，每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标志也叫做控制位。当他们对应位上的值为1时，具体含义如下：</p><p><img src="/2017/04/28/TCPIP/TCP首部控制位.png" alt="TCP首部控制位"></p><ul><li><p>CWR（Congestion Window Reduced）</p><p>CWR标志与后面的ECE标志都用于IP首部的ECN字段。ECE标志位1时，则通知对方已将拥塞窗口缩小。</p></li><li><p>ECE（ECN-Echo）</p><p>置为1会通知通信对方，从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时将TCP首部中的ECE设置为1.</p></li><li><p>URG（Urgent Flag）</p><p>该位为1时，表示包中有需要紧急处理的数据。对于需要紧急处理的数据，会在后面的紧急指针中再进行解释。</p></li><li><p>ACK（Acknowledgement Flag）</p><p>该位为1时，确认应答的字段变为有效。TCP规定除了最初建立连接时的SYN包之外该位必须设置为1.</p></li><li><p>PSH（Push Flag）</p><p>该位为1时，表示需要将受到的数据立刻传给上层应用协议。PSH为0时，则不需要立即上传而是先进行缓存。</p></li><li><p>RST（Reset Flag）</p><p>该位为1时，表示TCP连接中出现异常必须强制断开连接。例如，一个没有被使用的端口即使发来连接请求，也无法进行通信。此时就可以返回一个TST设置为1的包。此外，程序宕掉或切断电源等原因导致主机重启的情况下，由于所有的链接信息将全部被初始化，所有原有的TCP通信也将不能继续进行。这种情况下，如果通信对方发送一个设置为1的RST包，就会使通信强制断开连接。 </p></li><li><p>SYN（Synchronize Flag）</p><p>用于建立连接。SYN为1表示希望建立连接，并在其序列号的字段进行序列号初始值的设定。</p></li><li><p>FIN(Fin Flag)</p><p>该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方在主机之间就可以相互交换FIN位置为1的TCP段。每个主机又对对方的FIN包进行确认应答以后就可以断开连接。不过，主机收到FIN设置为1的TCP段以后不必马上回复一个FIN包，而是可以等到缓冲区中的所有数据都因已成功发送而被自动删除之后再发。</p></li><li><p>窗口大小（Window Size）</p><p>该字段长16位，用于通知从相同TCP首部的确认应答号所指位置开始能够接收的数据大小（8位字节）。TCP不允许发送超过此处所表示大小的数据。不过，如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小。但这个数据必须是1个字节。</p></li><li><p>校验和（Checksum）</p><p><img src="/2017/04/28/TCPIP/TCP_Checksum伪首部.png" alt="TCP_Checksum伪首部"></p></li></ul><p>TCP的校验和和与UDP相似，区别在于TCP的校验和无法关闭。</p></li><li><p>紧急指针（Urgent Pointer）</p><p>该字段长为16位。只有在URG控制位为1时有效。该字段的数值表示本报文字段中紧急数据的指针。正确来讲，从数据部分的首位到紧急指针所指示的位置位置为紧急数据。因此也可以说紧急指针指出了紧急数据的末尾在报文段中的位置。此外，紧急指针也用作表示数据流分段的标志。</p></li><li><p>选项（Options）</p><p>该字段用于提高TCP的传输性能。因为根据数据偏移（首部长度）进行控制，所以其长度对打为40字节。</p></li></ul><h1 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h1><h2 id="路由控制的定义"><a href="#路由控制的定义" class="headerlink" title="路由控制的定义"></a>路由控制的定义</h2><h3 id="IP地址与路由控制-1"><a href="#IP地址与路由控制-1" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h3><p>​    互联网是由路由器连接的网络组合而成的。为了能让数据包正确地到达目标主机，路由器必须在途中进行正确地转发。</p><p>​    路由器根据路由控制表转发数据包。它根据所收到的数据包中目标主机的IP地址与路由控制表的比较得出下一个应该接收的路由器。因此，这个过程中路由控制表的记录一定要正确无误。但凡出现错误，数据包就有可能无法到达目标主机。</p><h3 id="静态路由与动态路由"><a href="#静态路由与动态路由" class="headerlink" title="静态路由与动态路由"></a>静态路由与动态路由</h3><p>静态路由是指事先设置好路由器和主机中并将路由信息固定的一种方法。</p><p>动态路由是指让路由协议在运行过程中自动地设置路由控制信息的一种方法。</p><h3 id="动态路由的基础"><a href="#动态路由的基础" class="headerlink" title="动态路由的基础"></a>动态路由的基础</h3><p>动态路由会给相邻路由器发送自己已知的网络连接信息，而这些信息又像接力一样一次传递给其它路由器，直至整个网络都了解时，路由控制表也就制作完成了，此时就可以正确转发IP数据包了。</p><h2 id="路由控制范围"><a href="#路由控制范围" class="headerlink" title="路由控制范围"></a>路由控制范围</h2><p><img src="/2017/04/28/TCPIP/EGP与IGP.png" alt="EGP与IGP"></p><p>​    自治系统（路由选择域）内部动态路由采用的协议是域内路由协议（IGP）。而自治系统之间的路由控制采用的是域间路由协议（EGP）</p><p>路由协议大致分为两大类。一类是外部网关协议EGP，另一类是内部网关协议IGP（Interior Gateway Protocol）</p><p>IP地址分为网络部分和主机部分，他们有各自的分工。EGP与IGP的关系与IP地址网络部分与主机部分的关系有相似之处。就像根据IP地址中的网络部分在网络之间进行路由选择、根据主机部分在链路内部进行主机识别一样，可以根据EGP在区域网络之间（或ISP之间）进行路由选择，也可以根据IGP在区域网络内部（或ISP内部）进行主机识别。</p><p>​    IGP中还可以使用RIP（Routing Information Protocol，路由信息协议）、RIP2、OSPF（Open Shortest Path First，开放式最短路径优先）等众多协议。与之相对，EGP使用的是BGP（Border Gateway Protocol，边界网关协议）协议。</p><h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><p>​    路由控制中最具代表的算法：（1）距离向量（Distance-Vector）算法和链路状态（Link-State）算法</p><h3 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h3><p>​    距离向量算法是指根据距离和方向决定目标网络或目标主机位置的一种方法。路由器之间可以互换目标网络的方向及距离的相关信息，并以这些信息为基础制作路由控制表。处理简单，但是由于只有距离和方向的信息，所以网络结构复杂时，在获得稳定的路由信息之前需要消耗一定时间，也极易发生路由循环等问题。</p><p><img src="/2017/04/28/TCPIP/距离向量.png" alt="距离向量"></p><h3 id="链路状态算法"><a href="#链路状态算法" class="headerlink" title="链路状态算法"></a>链路状态算法</h3><p>​    链路状态算法是路由器在了解网络整体连接状态的基础上生成路由控制表的一种方法。该方法中，每个路由器必须保持同样的信息才能进行正确的路由选择。为了实现，链路状态算法付出的代价就是如何从网络代理获取路由信息表，这个过程相当复杂，特别是在一个规模巨大而又复杂的网络结构中，管理和处理代理信息需要高速CPU处理能力和大量的内存。</p><h3 id="主要路由协议"><a href="#主要路由协议" class="headerlink" title="主要路由协议"></a>主要路由协议</h3><table><thead><tr><th>路由协议名</th><th>下一层协议</th><th>方式</th><th>适用范围</th><th>循环检测</th></tr></thead><tbody><tr><td>RIP</td><td>UDP</td><td>距离向量</td><td>域内</td><td>不可以</td></tr><tr><td>RIP2</td><td>UDP</td><td>距离向量</td><td>域内</td><td>不可以</td></tr><tr><td>OSFP</td><td>IP</td><td>链路状态</td><td>域内</td><td>可以</td></tr><tr><td>EGP</td><td>IP</td><td>距离向量</td><td>对外链接</td><td>不可以</td></tr><tr><td>BGP</td><td>TCP</td><td>路径向量</td><td>对外链接</td><td>可以</td></tr></tbody></table><h2 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h2><p>RIP（Routing Information Protocol）是距离向量型的一种路由协议，广泛用于LAN，被BSD UNIX作为标准而提供的routed采用了RIP，因此RIP得到了迅速的普及。</p><p><img src="/2017/04/28/TCPIP/RIP.png" alt="RIP"></p><p><img src="/2017/04/28/TCPIP/RIP与子网掩码.png" alt="RIP与子网掩码"></p><p>RIP2</p><p>它是RIP的第二版，是对RIP的改良版，它们工作机制基本相同，不过有如下几个新的特点。</p><ul><li><p>使用多播</p><p>RIP中当路由器之间交换路由信息时采用广播的形式，然而RIP2中改用了多播。这样不仅减少了网络流量，还缩小了对无关主机的影响。</p></li><li><p>支持子网掩码</p><p>与OSPF类似的，RIP2支持在其交换机的路由信息中加入子网掩码信息</p></li><li><p>路由选择域</p><p>与OSPF的区域类似，在同一个网络中可以使用逻辑上独立的多个RIP</p></li><li><p>外部路由标志</p><p>通常用于把从BGP等获取的路由控制信息通过RIP传递给AS内。</p></li><li><p>身份验证密钥</p><p>与OSPF一样，RIP包中携带密码，只有在自己能够识别这个密码时才接受数据，否则忽略这个RIP包。</p></li></ul><h2 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h2><p>​    OSPF（Open Shortest Path First）是根据OSI的IS-IS协议二提出的一种链路状态性路由协议。由于采用链路状态类型，所以即使网络中有环路，也能够进行稳定的路由控制。<img src="/2017/04/28/TCPIP/OSPF_由链路状态确定路由.png" alt="OSPF_由链路状态确定路由"></p><p>​    RIP的路由选择，要求途中所经过的路由器个数越少越好。与之相比，OSPF可以给每一条链路赋予一个权重（也可以叫做代价），并始终选择一个权重最小的路径作为最终路由。也就是说OSPF以每个连路上的代价为度量标准，始终选择一个总的代价最小的一条路径。</p><p><img src="/2017/04/28/TCPIP/网络权重与路由选择.png" alt="网络权重与路由选择"></p><h3 id="OSPF工作原理概述"><a href="#OSPF工作原理概述" class="headerlink" title="OSPF工作原理概述"></a>OSPF工作原理概述</h3><p><img src="/2017/04/28/TCPIP/Users\fuqua\Desktop\复习参考书\笔记\TCPIP\OSPF中根据链路状态生成路由控制表.png" alt="OSPF中根据链路状态生成路由控制表"></p><h3 id="将区域分层化进行细分"><a href="#将区域分层化进行细分" class="headerlink" title="将区域分层化进行细分"></a>将区域分层化进行细分</h3><p>​    链路状态型路由协议的潜在问题在于，当网络规模越来越大时，表示链路状态的拓扑数据库就变得越来越大，路由控制信息的计算就越困难。OSPF为了减少计算负荷，一如了区域的概念。</p><p>​    区域指将连接在一起的网络和主机划分成小组，使一个自治系统（AS）内可以拥有多个区域。不过具有多个区域的自治系统必须要有一个主干区域（Backbone Area），并且所有其他却与必须都与这个主干区域相连接。</p><p><img src="/2017/04/28/TCPIP/OSPF的路由器种类.png" alt="OSPF的路由器种类"></p><h2 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h2><p>BGP（Border Gateway Protocol），边界网关协议是连接不同组织机构（或者说连接不同自治系统）的一种协议。因此它属于外部网关协议（EGP）。具体划分，他主要用于ISP之间相连接的部分。只有BGP、RIP和OSPF共同进行路由控制，才能够进行整个互联网的路由控制。</p><h3 id="BGP与AS号"><a href="#BGP与AS号" class="headerlink" title="BGP与AS号"></a>BGP与AS号</h3><p>​    在RIP和OSPF中利用IP的网络地址部分进行着路由控制，然而BGP则需要放眼整个互联网进行路由控制。BGP的最终路由控制表由网络地址和下一站的路由器组来表示，不过它会根据所要经过的AS个数进行路由控制。</p><p><img src="/2017/04/28/TCPIP/BGP使用AS号管理网络信息.png" alt="BGP使用AS号管理网络信息"></p><h3 id="BGP是路径向量协议"><a href="#BGP是路径向量协议" class="headerlink" title="BGP是路径向量协议"></a>BGP是路径向量协议</h3><p>​    在AS路径信息访问列表中不仅包含转发方向和距离，还涵盖了途径所有AS的编号。因此它不是一个距离向量型协议。此外，对网络构造仅用一元化表示，因此也不属于链路状态型协议。向BGP这种根据所要经过的路径信息访问列表进行路由控制的协议属于路径向量（Path Vector）型协议。作为距离向量型的RIP协议，因为无法检测环路，所有可能发生无线计数问题。而路径向量型由于能够检测出环路，避免了无线计数的问题，所以网络更容易进入一个稳定的状态。同时它还有支持策略路由的优势。</p><p>​    路由控制是跨越整个互联网的分布式系统</p><p>​    分布式系统是指多个系统协同完成一个特定任务的系统。互联网中的路由控制，以网络内所有路由器都持有正确的路由信息为基础。使这些路由器的信息保持准确的协议就是路由协议。没有这些路由协议的协同工作，就无法进行互联网上正确的路由控制。总之，路由协议散布于整个互联网的各个角落，是支持互联网正常运行的一个巨大的分布式系统。</p><h2 id="MPLS"><a href="#MPLS" class="headerlink" title="MPLS"></a>MPLS</h2><h1 id="应用协议"><a href="#应用协议" class="headerlink" title="应用协议"></a>应用协议</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP/IP层次模型中，每一层都会对上一层的数据加入包首部，包首部至少包含两个信息：一个是发送端和接收端的信息，另一个是上一层的协议类型。因为这些协议需要程序实现，要控制整个协议流程的运作，必定需要控制信息，因此就需要包的首部，其中包括了协议实现时用到的控制信息。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="协议" scheme="http://fsysfq.top/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="TCPIP" scheme="http://fsysfq.top/tags/TCPIP/"/>
    
  </entry>
  
  <entry>
    <title>http协议</title>
    <link href="http://fsysfq.top/2017/03/22/http%E5%8D%8F%E8%AE%AE/"/>
    <id>http://fsysfq.top/2017/03/22/http协议/</id>
    <published>2017-03-22T07:09:41.000Z</published>
    <updated>2018-07-08T07:58:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>可以<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener">参考</a>，以及《图解HTTP》,进行学习</p></blockquote><p>绝对URI格式<br><code>http://user:pass@www.example.com:80/dir/index.html/uid=1#ch1</code><br>http:或https:等协议方案名获取访问资源是要指定协议类型。不区分字母大小写，最后附一个冒号(:)</p><p><code>http://</code>:协议方案名<br><code>user:pass</code>:登录信息（认证）（可选）<br><code>www.example.com</code>：服务器地址<br><code>80</code>:服务器端口号<br><code>/dir/index.html</code>:带层次的文件路径<br><code>uid</code>：查询字符串<br><code>ch1</code>:片段标识符</p><p><code>RFC</code>:Request for Comments 征求修正意见书<br>通常，应用程序会遵照RFC确定的标准实现。可以说，RFC是互联网的设计文档，要是不按照RFC标准执行，就有可能导致无法通信的状况。</p><p>请求报文的构成<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST(方法)  /form/entry(URI)  HTTP/<span class="number">1.1</span>(协议版本) </span><br><span class="line"></span><br><span class="line"><span class="comment">//请求首部字段</span></span><br><span class="line">Host: example.com</span><br><span class="line">Connection:keep-alive</span><br><span class="line">Content-Type:appllication/x-www-form-urlencoded</span><br><span class="line">Content-Length:<span class="number">16</span></span><br><span class="line"><span class="comment">//请求首部字段结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内容实体</span></span><br><span class="line">name=sfqq&amp;age=<span class="number">25</span></span><br></pre></td></tr></table></figure></p><p>响应报文：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK(状态码的原因短语)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>: Wed, <span class="number">22</span> Mar <span class="number">2017</span> <span class="number">07</span>:<span class="number">42</span>:<span class="number">52</span> GMT</span><br><span class="line">Content-Length:<span class="number">455</span></span><br><span class="line">Content-Type:text/html</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p><p>HTTP是一种不保存状态的协议，HTTP协议自身不对请求和响应之间的通信状态进行保存。这是为了更快的处理大量事务，确保协议可伸缩性，而特意把HTTP协议设计成如此简单。但为了事项期望的保持状态的功能，于是引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态了。<br><a id="more"></a></p><p>HTTP/1.0和HTTP/1.1支持的方法</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">说明</th><th style="text-align:left">支持的HTTP协议版本</th></tr></thead><tbody><tr><td style="text-align:left">GET</td><td style="text-align:left">获取资源</td><td style="text-align:left">1.0、1.1</td></tr><tr><td style="text-align:left">POST</td><td style="text-align:left">传输实体主体</td><td style="text-align:left">1.0、1.1</td></tr><tr><td style="text-align:left">PUT</td><td style="text-align:left">传输文件</td><td style="text-align:left">1.0、1.1</td></tr><tr><td style="text-align:left">HEAD</td><td style="text-align:left">获得报文首部</td><td style="text-align:left">1.0、1.1</td></tr><tr><td style="text-align:left">DELETE</td><td style="text-align:left">删除文件</td><td style="text-align:left">1.0、1.1</td></tr><tr><td style="text-align:left">OPTIONS</td><td style="text-align:left">询问支持的方法</td><td style="text-align:left">1.1</td></tr><tr><td style="text-align:left">TRACE</td><td style="text-align:left">追踪路径</td><td style="text-align:left">1.1</td></tr><tr><td style="text-align:left">CONNECT</td><td style="text-align:left">要求用隧道协议连接代理</td><td style="text-align:left">1.1</td></tr><tr><td style="text-align:left">LINK</td><td style="text-align:left">简历和资源之间的联系</td><td style="text-align:left">1.0</td></tr><tr><td style="text-align:left">UNLINK</td><td style="text-align:left">断开连接关系</td><td style="text-align:left">1.0</td></tr></tbody></table><p><code>持久链接keep-alive</code><br>http协议的初始版本中，没进行一次HTTP通信就要断开一次客户端和服务器的TCP链接。<br>当页面复杂时，一个html页面中含有其他资源，因此每次的请求都会造成TCP连接的建立和断开，增加通信量的开销。<br>为了解决这个问题。http/1.1和一部分http/1.0想出了持久链接，特点是，只要任意一段没有明确提出断开连接，则保持TCP连接状态。<br>在HTTP/1.1中，所有的连接默认都是持久链接，但在HTTP/1.0内并未标准化。毫无疑问，除了服务器端，客户端也需要支持持久链接。</p><p><code>管线化pipelining</code><br>持久链接是的多数请求以管线化方式发送成为可能。从前发送请求后需要等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p><h1 id="http报文内的http信息"><a href="#http报文内的http信息" class="headerlink" title="http报文内的http信息"></a>http报文内的http信息</h1><p>用于HTTP协议交互的信息被称为HTTP报文。</p><h2 id="请求报文及响应报文的结构"><a href="#请求报文及响应报文的结构" class="headerlink" title="请求报文及响应报文的结构"></a>请求报文及响应报文的结构</h2><ol><li>请求报文</li></ol><ul><li>报文首部<br>  具体：请求行、请求首部字段、通用首部字段、实体首部字段、其它</li><li>空行（CR+LF）</li><li>报文主体</li></ul><ol start="2"><li>响应报文</li></ol><ul><li>报文首部<br>  具体：状态行、响应首部字段、通用首部字段、实体首部字段、其它</li><li>空行（CR+LF）</li><li>报文主体</li></ul><p>请求行：包含用于请求的方法，请求URI和HTTP版本<br>状态行：包含表明响应结果的状态码，原因短语和HTTP版本。<br>首部字段：包含便是请求和响应的各种条件和属性的各类首部。<br>其它：可能包含HTTP的RFC里未定义的首部（Cookie等）</p><h2 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h2><p>http在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。编码的操作需要计算机来完成，因此会消耗更多的CPU等资源。</p><h3 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="headerlink" title="报文主体和实体主体的差异"></a>报文主体和实体主体的差异</h3><ul><li>报文（message）<br> 是HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输</li><li><p>实体（entity）<br> 作为请求或响应的有限载荷数据被传输，其内容由实体首部和实体主体组成。</p><p>HTTP报文的主体用于传输请求或响应的实体主体。<br>同城报文主体等于实体主体。只有当（传输中进行编码）操作时，（实体主体的内容发生变化），才导致他和报文主体产生差异。</p></li></ul><p>内容编码致命应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接受并负责解码。<br>常用内容编码格式：gzip（GNU zip），compress（unix系统的标准压缩），deflate（zlib），identity（不进行编码）</p><h3 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h3><p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求的页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。<br>这种把实体分块的功能成为分块传输编码（Chunked transfer coding）</p><h2 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h2><pre><code>发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了MIME（Multipurpose Internet Mail Extensions，多用途因特</code></pre><p>网邮件扩展）机制。它允许邮件处理文本、图片、视频、等多各不同类型的数据。<br>相应地，HTTP协议中也采纳了多部分对象集合（Multipart），发送的一份报文内可含有多类型实体。通常是在图片或文本文件上传时使用。</p><ul><li>multipart/form-data 在web表单文件上传时使用</li><li>multipart/byteranges<br>状态码206（partial content，部分内容）响应报文包含了多个范围的内容时使用。</li></ul><p>一份报文中含有多类型实体，在报文实体中，每个类型实体，要使用某种标记分割标识哪种类型的实体。 在报文首部使用boundary来指定字符串来划分多部分集合指明各类实体。多部分对象集合的每个部分类型中，都可以含有首部字段。</p><h2 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h2><pre><code>断点续传。对一份10000字节大小的资源，如果适用范围请求，可以只请求5001~10000字节的资源。</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求</span></span><br><span class="line">GET /tip.jpg HTTP/<span class="number">1.1</span></span><br><span class="line">Host:www.example.com</span><br><span class="line">Range:bytes = <span class="number">5001</span><span class="number">-10000</span></span><br><span class="line"><span class="comment">//响应</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">206</span> Partial Content</span><br><span class="line"><span class="built_in">Date</span>:Wed, <span class="number">22</span> Mar <span class="number">2017</span> <span class="number">07</span>:<span class="number">42</span>:<span class="number">52</span> GMT</span><br><span class="line">Content-Range:bytes <span class="number">5001</span><span class="number">-10000</span>/<span class="number">10000</span></span><br><span class="line">Content-Length:<span class="number">5000</span></span><br><span class="line">Content-Type:image/jpeg</span><br></pre></td></tr></table></figure><ul><li>从5001字节后的全部<br><code>Range:bytes=5001-</code></li><li>从一开始到3000字节和5000-7000字节的多重范围<br><code>Range:bytes=-3000,5000-7000</code><br>如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。</li></ul><h2 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h2><pre><code>同一个web网站有可能存在多份相同内容的页面。比如英文版和中文版的web页面，他们内容虽然相同，但使用的语言却不同。</code></pre><p>当浏览器的默认语言为英文或中文，访问相同的URI的web页面时，则会显示对应的英文版或中文版的web页面。这种机制为内容协商。<br>内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供客户端最为合适的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断基准。<br>请求头：Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language<br>内容协商技术三种类型：</p><ul><li>服务器驱动协商<br>  由服务器端进行内容协商。以请求的首部字段为参考，在服务器端处理</li><li>客户端驱动协商<br>  由客户端进行内容协商，用户从浏览器显示的可选列表中手动选择。</li><li>透明协商<br>  是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</li></ul><h1 id="返回结果的HTTP状态码"><a href="#返回结果的HTTP状态码" class="headerlink" title="返回结果的HTTP状态码"></a>返回结果的HTTP状态码</h1><pre><code>状态码的职责就是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了</code></pre><p>错误。<br>状态码的类别</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">类别</th><th style="text-align:left">原因短语</th></tr></thead><tbody><tr><td style="text-align:left">1xx</td><td style="text-align:left">Informational(信息性状态码)</td><td style="text-align:left">接受的请求正在处理</td></tr><tr><td style="text-align:left">2XX</td><td style="text-align:left">Success(成功状态码)</td><td style="text-align:left">请求处理完毕</td></tr><tr><td style="text-align:left">3XX</td><td style="text-align:left">Redirection（重定向状态码）</td><td style="text-align:left">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:left">4XX</td><td style="text-align:left">ClientError（客户端错误状态码）</td><td style="text-align:left">服务器无法处理请求</td></tr><tr><td style="text-align:left">5XX</td><td style="text-align:left">ServerError（服务器端错误状态码）</td><td style="text-align:left">服务器处理请求出错</td></tr></tbody></table><p>200 请求成功<br>204 No Content 请求处理成功，但没有资源可返回。<br>206 Partial Content 对资源某一部分请求。<br>301 Moved Permanently 永久性重定向<br>302 Found 临时性重定向<br>303 see other<br>    该状态码便是由于请求对应的资源存在着另一个URI，应使用GET方法重定向获取请求的资源，303状态码和302Found状态码有着相同的功能，<br>但303状态码明确便是客户端应当采用GET方法获取资源，这点与302状态码有区别。<br>    当301/302/303响应状态码返回时，几乎所有的浏览器都会把POST改为GET，并删除请求报文内的主体，之后请求会自动再次发送。<br>301/302标准是禁止将POST方法改变为GET方法的，但实际上使用时大家都这么做了。<br>304 Not Modified<br>    该状态码表示客户端发送附带条件的请求（指请求报文还包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，布包好任何响应的<br>主体<br>部分。304虽然别划分在3XX类别中，但是和重定向没有关系。<br>307 Temporary Redirect 临时重定向<br> 该状态码与302 Found有着相同的含义。307会遵照浏览器标准，不会从POST变为GET。但是，对于处理响应时的行为，每种浏览器有可能<br> 出现不同的情况。<br>400 Bad Request<br>该状态码便是报文中存在语法错误。浏览器回想200OK一样对待该状态码。<br>401 Unauthorized<br>403 Forbidden<br>404 Not Found<br>500 Internal Server Error<br>503 Service Unavailable</p><h1 id="与HTTP协作的Web服务器"><a href="#与HTTP协作的Web服务器" class="headerlink" title="与HTTP协作的Web服务器"></a>与HTTP协作的Web服务器</h1><pre><code>一台Web服务器可搭建多个独立域名的Web站点，也可作为通信路径上的中转服务器提升传输效率。</code></pre><h2 id="通信数据转发程序：代理、网管、隧道"><a href="#通信数据转发程序：代理、网管、隧道" class="headerlink" title="通信数据转发程序：代理、网管、隧道"></a>通信数据转发程序：代理、网管、隧道</h2><ul><li><p>代理：<br>  代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端‘中间人’的角色，接收由客户端发送的请求并转发给服务器，同时接收服务器<br>  返回的响应并转发给客户端。</p></li><li><p>网关<br>  网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的服务器一样对请求进行处理。有时客户端可能都不会察觉，自己通信目标是一个网关。</p></li><li>隧道<br>  隧道是在相隔甚远的客户端和服务器两者之间进行中转，并支持双方通信连接的应用程序。</li></ul><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><pre><code>代理服务器的基本行为就是接收客户端发送的请求后转发给其它服务器。</code></pre><p>使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，阻止内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。<br>代理有多重使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。</p><ul><li>缓存代理<br>代理转发响应时，缓存代理会预先将资源的副本保存在代理服务器上。当代理再次接收到相同资源的请求时，就可以不从原服务器那里获取资源。而是将之前缓存的资源作为响应返回。</li><li>透明代理<br>转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理。反之称为非透明代理。<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3>利用网关可以由HTTP请求转化为其它协议通信。</li></ul><h2 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h2><pre><code>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对资源服务器的访问，因此也就节省了通信流量和通信时间。</code></pre><p>缓存服务器是代理服务器的一种。<br>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同<br>的请求了。</p><h3 id="缓存的有效期限"><a href="#缓存的有效期限" class="headerlink" title="缓存的有效期限"></a>缓存的有效期限</h3><pre><code>即便缓存服务器内有缓存，也不能保证每次都会返回对资源的请求。因为这关系到被缓存资源的有效性问题。</code></pre><p>即时存在缓存，也会因为客户端的要求、缓存的有效期等因素，向原服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务<br>器上获取‘新’资源。</p><h3 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h3><pre><code>缓存不紧可以存在于缓存服务器内，还可以存在客户端浏览器中。以IE为例，客户端缓存称为临时网络文件。</code></pre><p>浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。当判定缓存过期后，<br>会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求资源。</p><h1 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h1><p> 在报文众多的字段中，HTTP首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖HTTP报文相关的内容信息。</p><h2 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h2><p>HTTP首部字段传递重要的信息</p><h3 id="HTTP首部字段结构"><a href="#HTTP首部字段结构" class="headerlink" title="HTTP首部字段结构"></a>HTTP首部字段结构</h3><p><code>首部字段名：字段值</code></p><ul><li>若HTTP首部字段重复了会如何？<br>  这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有的优先处理第一次出现的首部字段，有的有限处理最后出现的首部字段等。<h3 id="4中HTTP首部字段类型"><a href="#4中HTTP首部字段类型" class="headerlink" title="4中HTTP首部字段类型"></a>4中HTTP首部字段类型</h3></li></ul><ol><li>通用首部字段（general header fields）<br>请求报文和响应报文两方都会使用的首部。</li><li>请求首部字段（request header fields）</li><li>响应首部字段（response headerfields）</li><li>实体首部字段（entity header fields）</li></ol><p>HTTP/1.1和非HTTP/1.1首部<br>非HTTP/1.1首部字段：Cookie、Set-Cookie和Content-Disposition等</p><h3 id="End-to-End-首部和-Hop-by-hop首部"><a href="#End-to-End-首部和-Hop-by-hop首部" class="headerlink" title="End-to-End 首部和 Hop-by-hop首部"></a>End-to-End 首部和 Hop-by-hop首部</h3><ul><li>端到端首部<br>  该类首部会转发给请求/响应对应的最终接收目标，切必须保存在由缓存生成的响应中，另外规定它必须被转发</li><li>逐跳首部<br>  该类首部只对单次转发有效，会因通过缓存或代理而不再转发。在HTTP/1.1和之后版本中，如果使用hop-to-hop首部，需提供Connection首<br>  部字段。有如下逐跳首部字段：</li></ul><ol><li>Connection</li><li>Keep-Alive</li><li>Proxy-Authenticate</li><li>Proxy-Authorization</li><li>Trailer</li><li>TE</li><li>Transfer-Encoding</li><li>Upgrade<h2 id="HTTP-1-1通用首部字段"><a href="#HTTP-1-1通用首部字段" class="headerlink" title="HTTP/1.1通用首部字段"></a>HTTP/1.1通用首部字段</h2><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3> 通过指定该字段，可以操作缓存的工作机制。<br>指令格式，例如：<br><code>Cache-Control:private,max-age=0,no-cache</code><br>缓存请求指定：</li></ol><table><thead><tr><th style="text-align:left">指令</th><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">no-cache</td><td style="text-align:left">无</td><td style="text-align:left">强制向源服务器再次验证</td></tr><tr><td style="text-align:left">no-store</td><td style="text-align:left">无</td><td style="text-align:left">不缓存请求或响应的任何内容</td></tr><tr><td style="text-align:left">max-age=[秒]</td><td style="text-align:left">必须</td><td style="text-align:left">响应的最大Age值</td></tr><tr><td style="text-align:left">max-stale(=[秒])</td><td style="text-align:left">可省略</td><td style="text-align:left">接受已经过期的响应</td></tr><tr><td style="text-align:left">min-fresh=[秒]</td><td style="text-align:left">必须</td><td style="text-align:left">期望在指定时间内的响应仍然有效</td></tr><tr><td style="text-align:left">no-transform</td><td style="text-align:left">无</td><td style="text-align:left">代理不可改变媒体类型</td></tr><tr><td style="text-align:left">only-if-cached</td><td style="text-align:left">无</td><td style="text-align:left">从缓存获取资源</td></tr><tr><td style="text-align:left">cache-extension</td><td style="text-align:left">-</td><td style="text-align:left">新指令标记（token）</td></tr></tbody></table><p>缓存响应指令</p><table><thead><tr><th style="text-align:left">指令</th><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">public</td><td style="text-align:left">无</td><td style="text-align:left">可向任一方提供响应的缓存</td></tr><tr><td style="text-align:left">private</td><td style="text-align:left">可省略</td><td style="text-align:left">仅向特定用户返回响应</td></tr><tr><td style="text-align:left">no-cache</td><td style="text-align:left">可省略</td><td style="text-align:left">缓存前必须先确认其有效性</td></tr><tr><td style="text-align:left">no-store</td><td style="text-align:left">无</td><td style="text-align:left">不缓存请求或响应的任何内容</td></tr><tr><td style="text-align:left">no-transform</td><td style="text-align:left">无</td><td style="text-align:left">代理不可更改媒体类型</td></tr><tr><td style="text-align:left">must-revalidate</td><td style="text-align:left">无</td><td style="text-align:left">可缓存必须向源服务器进行确认</td></tr><tr><td style="text-align:left">proxy-revalidate</td><td style="text-align:left">无</td><td style="text-align:left">要求中间缓存服务器对缓存的响应有效性再进行确认</td></tr><tr><td style="text-align:left">max-age=[秒]</td><td style="text-align:left">必须</td><td style="text-align:left">响应的最大Age值</td></tr><tr><td style="text-align:left">s-maxage=[秒]</td><td style="text-align:left">必须</td><td style="text-align:left">公共缓存服务器响应的最大Age值</td></tr><tr><td style="text-align:left">cache-extension</td><td style="text-align:left">-</td><td style="text-align:left">新指令标记（token）</td></tr></tbody></table><p><strong>表示是否能缓存的指令</strong><br>public指令<br><code>Cache-Control:public</code>,表示其它用户可以利用缓存<br>private指令<br><code>Cache-Control:private</code>,表示缓存服务器会对特定用户提供资源缓存的服务，对于其它用户发来的请求，代理服务器则不会返回缓存。<br>no-cache指令<br><code>Cache-Control:no-cache</code>，表示不缓存过期的资源，缓存会向源服务器进行有效性确认后处理资源。<br><strong>控制可执行缓存的对象的指令</strong><br>no-store指令<br><code>Cache-Control:no-store</code>,暗示请求或响应中包含机密信息，不进行缓存。<br><strong>指定缓存期限和认证的指令</strong><br>s-maxage指令<br><code>Cache-Control:s-maxage=604800</code>（单位：秒）一周<br>    该指令的功能和max-age指令相同，它们的不同点是s-maxage指令只适用于供多为用户使用的公共缓存服务器。也就是说对于向同一用户重复<br>返回响应服务器来说，这个指令没有任何作用。当使用s-maxage指令后，则直接忽略对Expires首部字段及max-age指令的处理。<br>max-age指令<br><code>Cache-Control:max-age=604800</code><br>    客户端发送的请求中包含max-age指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接受缓存的资源。另外，当<br>max-age=0，那么缓存服务器通常需要将请求转发给源服务器。<br>    服务器返回的响应中包含max-age时，缓存服务器将不对资源的有效性再做确认，而max-age数值代表资源保存为缓存的最长时间。<br>    应用HTTP/1.1版本的缓存服务器遇到同时存在Expires首部字段的情况时，会优先处理max-age指令，而忽略掉Expires首部字段。<br>而HTTP/1.0版本的缓存服务器的情况却相反，max-age指令会被忽略。<br>min-fresh指令<br><code>Cache-Control:min-fresh=60</code><br>    客户端询问缓存服务器，再过60秒这个资源还是新的吗（过期了吗）？不是的话，则不能用缓存做响应。<br>max-stale指令<br><code>Cache-Control:max-stale=3600</code><br>使用max-stale可只是缓存资源，即时过期也照常接受。</p><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><pre><code>两个作用：</code></pre><ul><li><p>控制不再转发给代理的首部字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端发送请求</span></span><br><span class="line">    GET / HTTP/<span class="number">1.1</span></span><br><span class="line">    Upgrade: HTTP/<span class="number">1.1</span></span><br><span class="line">    Connection:Upgrade</span><br><span class="line"><span class="comment">//经过一个代理转发后</span></span><br><span class="line">    GET / HTTP/<span class="number">1.1</span></span><br><span class="line"><span class="comment">//首部字段Upgrade被删除后再转发</span></span><br></pre></td></tr></table></figure></li><li><p>管理持久链接<br><code>Connection:close</code><br>HTTP/1.1默认链接都是持久化链接。为此，客户端会在持久化链接上连续发送请求。当服务器端向明确断开连接时，则指定Connection首部字段为Close。<br><code>Connection:Keep-Alive</code><br>HTTP/1.1之前的HTTP版本的默认链接都是非持久链接。为此想在旧版本的HTTP协议上维持持续连接，则需要指定Connection首部字段值为Keep-Alive.</p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>首部字段Date标明创建HTTP报文的日期和时间。</p><h3 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h3><p>  首部字段Trailer会事先说明咋报文主体后记录了哪些首部字段。该首部子弹壳应用在HTTP/1.1版本分块传输编码时。</p><h3 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h3><p>  首部字段Transfer-Encoding规定了传输报文主体时采用的编码方式。<br>  HTTP/1.1的传输编码方式仅对分块传输编码有效</p><h3 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h3><p>  使用首部字段via是为了追踪客户端与服务器端之间的请求和响应报文的传输路径。<br>  是偶不字段Via不紧用于追踪报文的转发，还可以避免请求回环的发生。所以必须在经过代理是附加该首部字段内容。</p><h2 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h2><p>  请求首部子弹是从客户端往服务器端发送请求报文所使用的字段，用于补充请求的附加信息，客户端信息，对响应内容相关的优先级等内容。</p><h3 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h3><p><code>Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</code><br>Accept首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的优先级。可以使用type/subtype这种形式，一次指定多种媒体类型。<br>例子：</p></li><li>文本文件<br>text/html,text/plain,text/css…<br>application/xhtml+xml,application/xml…</li><li>图片文件<br>image/jpeg,image/gif,image/png…</li><li>视频文件<br>video/mpeg,video/quicktime…</li><li>应用程序使用的二进制文件<br>application/octet-stream,application/zip…</li></ul><p>若想要给显示的媒体类型增加优先级，则使用q=来二外表示权重值，用分号（;）进行分割。</p><h3 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h3><p><code>Accept-Charset:iso-8859-5,unicode-1-1;q=0.8</code><br>该字段可用来通知服务器用户代理支持的字符集及字符集的相对有限顺序。另外可一次性指定多种字符集。与首部字段Accept相同的是可用权重<br>q值来表示相对优先级。<br>    该首部字段应用于内容协商机制的服务器驱动协商。</p><h3 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h3><p><code>Accept-Encoding:gzip,deflate</code><br>Accept-Encoding首部告知服务器用户代理支持的内容编码及内容编码的优先级顺序，可一次性指定多种内容编码。</p><h3 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h3><p><code>Accept-Language:zh-cn,zh;q=0.7,en-us,en;q=0.3</code><br>客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版，则请求返回英文版响应。</p><h3 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h3><p><code>Authorization:Basic ddsfkdasfldasfkasdf=</code><br>    首部字段Authorization是用来告诉服务器，用户代理的认证信息。</p><h3 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h3><p><code>Expect:100-continue</code><br>客户端使用首部字段Expect来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望做出回应而发生错误时，会返回状态码417 Expectation Failed</p><h3 id="From"><a href="#From" class="headerlink" title="From"></a>From</h3><pre><code>首部字段From用来告知服务器使用用户代理的用户的电子邮件地址。</code></pre><h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p><code>Host: www.example.com</code><br>首部字段Host会会告知服务器，请求的资源所处的互联网主机名和端口号。Host首部字段在HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段。首部字段Host和以单台服务器分配多个域名的虚拟主机的工作主机有着很密切的关联，这是首部字段Host必须存在的意义。虚拟主机运行在同一个IP上，因此使用首部字段Host加以区分。</p><h3 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h3><p>形如If-XXX这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。<br><code>If-Match:&#39;123456&#39;</code><br>发送请求含有If-Match，服务器端接收到请求后，If-Match的值和实体标记比对，如果值相等返回200OK，如果不相等返回412（Precondition Failed）实体标记（ETag）是与特定资源关联的确定值。资源更新后ETag也会随之更新。<br>还可以使用星号（*）指定If-Match的字段值。针对这种情况，服务器将会忽略ETag的值，只要资源存在就会处理请求。</p><h3 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h3><p><code>If-Modified-Since:Fri, 24 Mar 2017 07:22:58 GMT</code><br>如果在If-Modified-Since字段指定的日期时间后，资源发生了更新，服务器则会接受请求<br>对请求做出相应返回200OK，否则表示资源未更新，返回304 Not Modified。<br>获取资源的更新日期时间，可通过确认首部字段Last-Modified来确定。</p><p><img src="http协议/If-Modified-Since.png" alt="If-Modified-Since"></p><h3 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If_None_Match"></a>If_None_Match</h3><p>​    只有在If-None-Match的字段值与Etag值不一致时，可处理该请求。与If-Match首部字段的作用相反。</p><h3 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h3><p>​    If-Range字段值若是跟ETag值或更新的日期时间匹配一致，那么久作为范围请求处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br><span class="line">If-Range:&quot;123456&quot;</span><br><span class="line">Range:bytes=5001-10000</span><br><span class="line">//响应，如果服务器端index.html实体标记（ETag）为123456</span><br><span class="line">206 Partial Content</span><br><span class="line">Content-Range:bytes 5001-10000/10000</span><br><span class="line">Content-Length:5000</span><br><span class="line">//响应。若不一致，则忽略范围请求，返回全部资源</span><br><span class="line">200 OK</span><br><span class="line">ETag:&quot;567890&quot;</span><br><span class="line">//如果不使用首部字段If-Range则需要进行两次处理</span><br><span class="line">GET /</span><br><span class="line">If-Match:&quot;123456&quot;</span><br><span class="line">Range:5001-10000</span><br><span class="line">//响应</span><br><span class="line">412 Precondition Failed</span><br><span class="line">GET /</span><br><span class="line">//响应</span><br><span class="line">200 OK</span><br><span class="line">ETag:&quot;567890&quot;</span><br></pre></td></tr></table></figure><h3 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h3><p><code>If-Unmodified-Since:Thu,03 Jul 2017 00:00:00 GMT</code></p><p>​    首部字段If-UnModified-Since和If-Modified-Since作用相反。它的作用是告知服务器，指定的资源请求只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间之后发生了更新，则以状态码412 Precondition Failed作为响应返回。</p><h3 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h3><p>​    通过TRACE方法或OPTIONS方法，发送包含首部字段Max-Forwards请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器再往下一个服务器转发请求之前，Max-Forwards的值减1后重新复制。当服务器接收到Max-Forwards值为0的请求时，则不再转发，而是直接返回响应。</p><p>​    使用HTTP协议通信时，请求可能经过代理等多台服务器。途中，如果代理服务器有与某些原因导致请求转发失败，客户端也就等不到服务器返回的响应了。对此，我们无从可知。（代理可能产生循环）</p><p>​    可以灵活使用Max-Forwards，针对以上问题产生的原因展开调查。由于Max-Forwards字段值为0时，服务器就会立即返回响应，因此我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握。</p><h3 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h3><p><code>Proxy-Authorization:Basic dGlOdkdlJdfdd8</code></p><p>​    接受到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization的请求，以告知服务器认证所需的信息。这个行为和客户端与服务器之间的HTTP访问相类似的，客户端与服务器之间的认证，使用首部字段Authorization可起到相同作用。</p><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p><code>Range:bytes=5001-10000</code></p><p>​    对于只需获取部分资源的范围的请求，包含首部子弹Range即可告知服务器资源的指定范围。</p><h3 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / </span><br><span class="line">Referer:http://www.example.com/index.php</span><br><span class="line">//只要查看Referer就知道请求的URI是从哪个Web页面发起的。</span><br></pre></td></tr></table></figure><p>客户端一般会发送Referer首部字段给服务器，但当直接在浏览器的气质蓝输入URI，或处于安全性的考虑时，也可以不发送该首部字段。因为原始资源URI的查询字符串可能包含有ID和密码等信息，如果发送，可能导致保密信息泄露。</p><p>Referer的正确拼写应该是Referrer，不知为何大家一直沿用这个错误的拼写。</p><h3 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h3><p><code>TE:gzip,deflate;q=0.5</code></p><p>该字段告知服务器客户端能够处理响应的传输编码方式以及相对优先级。和Accept-Encoding的功能很像，但是用于传输编码。</p><h3 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h3><p>首部字段User-Agent会创建请求的浏览器和用户代理名称信息传达给服务器。</p><h2 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h2><p>​    响应首部字段是由服务器端向客户端返回响应报文中所使用的的字段，用于补充响应的附加信息，服务器信息，以及对客户端的附加要求信息等</p><h3 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h3><p>​    该字段是用来告知服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。可指定的字段值有两种，可处理范围请求时指定其为bytes，反之则指定其为none。</p><h3 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h3><p><code>Age:600</code>：如果是缓存服务器的响应，表示：这个缓存向源服务器确认过，现在已经过去了10分钟。</p><p>​    首部字段Age能告知客户端，源服务器在多久前创建了响应。字段值得单位为妙。若创建该响应的服务器是缓存服务器，Age值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段Age。</p><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>​    ETag实体标识。可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的ETag值。当资源更新时，ETag值也需要更新。生成ETag时，并没有统一的算法规则，而仅仅是由服务器来分配。</p><p>​    资源被缓存时，就会被分配唯一性标识。仅凭URI指定缓存的资源是相当困难的。</p><p><strong>强ETag值和弱ETag值</strong></p><p><strong>强ETag</strong></p><p>强Etag值，不论实体发生多么细微的变化都会改变其值</p><p><code>ETag:&quot;usagi-1234&quot;</code></p><p><strong>弱ETag值</strong></p><p>弱ETag值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变ETag值。这时，会在字段值最开始处附加W/</p><p><code>ETag:W/&quot;usagi-1234&quot;</code></p><h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p>​    使用首部字段Location可以将响应接收方引导至某个请求URI位置不同的资源。基本上，该字段会配合3XX：Redirection的响应提供重定向的URI。几乎所有的浏览器在接收到包含首部字段Location的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p><h3 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h3><p><code>Proxy-Authenticate: Basic realm=&quot;usagidesign Auth&quot;</code></p><p>​    首部字段Proxy-Authenticate会把代理服务器所要求的认证信息发送给客户端。它与客户端和服务器之间（WWW-Authorization）的HTTP认证访问的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。</p><h3 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h3><p><code>Retry-After:120</code></p><p>​    首部字段Retry-After告知客户端应该在多久之后再次发送请求。主要配合状态码503 Service Unavailable，或3XXRedirect响应一起使用。字段值可以指定为具体的日期时间，也可以使创建响应后的数秒。</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p><code>Server:Apache/2.2.17(Unix)</code></p><p>​    首部字段Server告知客户端当前服务器上安装的HTTP服务器应用程序的信息。不会单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。</p><p><code>Server:Apache/2.2.6(Unix)PHP/5.2.5</code> </p><h3 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*GET /Sample.html      |    |GET /Sample.html     |     |  |</span><br><span class="line">*Accept-Language:en-us |---&gt;|Accept-Language:en-us|----&gt;|------------&gt; | 源服务器</span><br><span class="line">*客户端   || 代理服务器  |     |&lt;------------|</span><br><span class="line">*  Vary：Accept-Language</span><br><span class="line">* Vary：Accept-Language，告知代理服务器，只能对具有相同语言的请求返回Sample.html缓存，反之需要重新从源服</span><br><span class="line">* 务器获取资源。</span><br><span class="line">**/</span><br></pre></td></tr></table></figure><h3 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h3><p><code>WWW-Authenticate:Basic realm=&quot;Usagidesign Auth&quot;</code>用于HTTP认证</p><h2 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h2><p>实体首部字段是包含在请求报文和响应报文中的实体部分使用的首部，用于补充内容的更新时间等于实体相关的信息。</p><h3 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h3><p><code>Allow:GET,HEAD</code></p><p>该字段用于通知客户端服务器能够支持Request-URI指定资源的所有HTTP方法。当服务器收到不支持的HTTP方法时，会以状态码405Method Not Allowed作为响应返回。与此同时，还会把所有能支持的HTTP方法写入首部字段Allow后返回。</p><h3 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h3><p><code>Content-Encoding:gzip</code></p><p>​    该首部字段，告知客户端服务器对实体的主题部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。</p><p>主要编码方式：gzip、compress、deflate、identity</p><h3 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h3><p><code>Content-Language:zh-CN</code></p><h3 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h3><p><code>Content-Length:15000</code></p><p>对实体主体进行内容编码传输时，不能再使用Content-Length首部字段。</p><h3 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h3><p><code>content-Location:http://www.example.com/index-zh.html</code></p><p>访问<code>http://www.example.com/</code>时候,返回真正的URI内容<code>http://www.example.com/index-zh.html</code>.</p><p>Content-Location给出与报文主题部分相对应的URI。</p><h3 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h3><p><code>Content-MD5:dfasdfsdfasdfsdfsadfasfasdfasdf==</code></p><p>​    服务器端会对报文主体进行MD5算法，然后进行Base64编码，客户端会对接收到报文主体执行相同的操作（MD5，base64），然后与首部字段Content-MD5的字段值比较。用于检测报文主体在传输过程中是否保持完整，以及确认传输到达。</p><p>如果传输过程中遭到恶意攻击，并同时对Content-MD5和报文主体进行修改，客户端无法意识到，遭到了攻击。</p><h3 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h3><p><code>Content-Range:bytes 5001-10000/10000</code></p><p>针对范围请求，返回响应时使用首部字段Content-Range</p><h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><p><code>content-Type:text/html;charset=UTF-8</code></p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires:Thu, 06 Apr 2017 06:53:50 GMT</code></p><p>​    首部字段<code>Expires</code>会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段Expires的响应后，会以缓存来应答请求，在Expires字段指定的时间前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。源服务器不希望缓存服务器对资源缓存时，最好在Expires字段内写入与首部字段Data相同的时间值。</p><p>​    但是，当首部字段Cache-Control有指定max-age指令时，比起首部字段Expires,会有限处理max-age指令。</p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p><code>Last-Modified:Thu, 06 Apr 2017 01:36:47 GMT</code></p><p>​    该首部字段指明资源最终修改的时间。一般来说，这个值就是Request-URI指定的资源被修改的时间。但是类似使用CGI脚本进行动态数据处理时，该值会有可能编程数据最终修改时的时间。</p><h2 id="为Cookie服务的首部字段"><a href="#为Cookie服务的首部字段" class="headerlink" title="为Cookie服务的首部字段"></a>为Cookie服务的首部字段</h2><p>​    管理服务器与客户端之间状态的Cookie，虽然没有被编入标准化HTTP/1.1的RFC2616中，但是在web网站方面得到了广发的应用。</p><p>​    Cookie的工作机制是用户识别及状态管理。web网站为了管理用户的状态会通过web浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该web网站时，可以通过通信方式取回之前发放的Cookie。调用Cookie时，由于可校验Cookie的有效期，以及发送方的域、路径、协议等信息，所以正规发布的Cookie内数据不会因来自其他web站点和攻击者的攻击而泄露。</p><p>​    目前使用最广泛的cookie标准却不是RFC中定义的任何一个。而是在网景公司制定的标准上进行扩展后的产物。</p><table><thead><tr><th style="text-align:left">首部字段名</th><th>说明</th><th>首部类型</th></tr></thead><tbody><tr><td style="text-align:left">Set-Cookie</td><td>开始状态管理所使用的Cookie信息</td><td>响应首部字段</td></tr><tr><td style="text-align:left">Cookie</td><td>服务器接收到的Cookie信息</td><td>请求首部字段</td></tr></tbody></table><h3 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h3><p><code>Set-Cookie:status=enable;expires=Thu, 06 Apr 2017 01:36:47 GMT;path=/;domain=.example.com</code></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>NAME=VAlUE</td><td>赋予Cookie的名称和值</td></tr><tr><td>expires=date</td><td>Cookie的有效期（若不明确制定则默认为浏览器关闭前为止）</td></tr><tr><td>path=PATH</td><td>将服务器上的文件目录作为Cookie的适用对象</td></tr><tr><td>domain=域名</td><td>作为Cookie适用对象的域名（默认为创建的Cookie的服务器的域名）</td></tr><tr><td>secure</td><td>仅在HTTPS安全通信时才会发送Cookie</td></tr><tr><td>HttpOnly</td><td>加以限制，使Cookie不能被JavaScript脚本访问</td></tr></tbody></table><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p><code>Cookie:status=enable</code></p><h2 id="其它首部字段"><a href="#其它首部字段" class="headerlink" title="其它首部字段"></a>其它首部字段</h2><p>HTTP首部字段是可以自行扩展的。所以在web服务器和浏览器的应用上，会出现各种非标准的首部字段。</p><h3 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h3><p><code>C-Frame-Options:DENY</code></p><p>​    属于响应首部字段，用于控制网站内容在其他Web网站的Frame标签内的显示问题。其主要目的是为了防止 <strong>点击劫持攻击</strong>。</p><p><code>点击劫持</code>是一种视觉上的欺骗手段，攻击者使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作，此时用户在不知情的情况下点击了透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上。</p><p>可以的取值：DENY：拒绝，SAMEORIGIN：仅同源域名下的页面。</p><h3 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h3><p>响应首部，它是针对跨站脚本攻击的一种策略，用于控制浏览器XSS防护机制的开关。</p><p>值：0：将XSS过滤设置成无效状态。1：将XSS过滤设置成有效状态。</p><h3 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h3><p>请求首部。DNT：Do Not Track，拒绝个人信息被收集，是表示拒绝精准广告追踪的一种方法。</p><p>0：同意被追踪 1：拒绝被追踪</p><h3 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h3><p>响应首部，可以让web网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。</p><h1 id="确保web安全的HTTPS"><a href="#确保web安全的HTTPS" class="headerlink" title="确保web安全的HTTPS"></a>确保web安全的HTTPS</h1><h2 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h2><p>主要不足：</p><ul><li>通信使用明文，内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改</li></ul><h3 id="通信使用明文可能会被窃听"><a href="#通信使用明文可能会被窃听" class="headerlink" title="通信使用明文可能会被窃听"></a>通信使用明文可能会被窃听</h3><ul><li><p>TCP/IP是可能被窃听的网络</p><p>按照TCP/IP协议族的工作机制，通信内容在所有的通信线路上都由可能遭到窥视</p></li><li><p>加密处理防止窃听</p><p>防止窃听保护信息，最为普及的就是加密技术</p><p>（1）通信的加密</p><p>HTTP通过和SSL（Secure Socket Layer,安全套接层）或TLS（Transport Layer Security，安全传输协议）的组合使用，加密HTTP的通信内容。使用SSL简历安全通信路线后，就可以在这条路上进行HTTP通信了，成为HTTPS。</p><p>（2）内容的加密</p></li></ul><h3 id="不验证通信方的身份就可能遭遇伪装"><a href="#不验证通信方的身份就可能遭遇伪装" class="headerlink" title="不验证通信方的身份就可能遭遇伪装"></a>不验证通信方的身份就可能遭遇伪装</h3><p>服务器只要接收到请求，不管对方是谁都会返回一个响应。</p><p>​    虽然使用HTTP协议无法确认通信方，但如果使用SSL则可以。SSL不紧提供加密处理，而且使用了一种被称为整数的手段，可用于确定方。</p><h3 id="收到的内容可能有误"><a href="#收到的内容可能有误" class="headerlink" title="收到的内容可能有误"></a>收到的内容可能有误</h3><p>中间人攻击（Man-in-the-Middle attack，MITM）</p><h2 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+加密+认证+完整性保护=HTTPS"></a>HTTP+加密+认证+完整性保护=HTTPS</h2><h3 id="HTTP加上加密处理和认证以及完整性保护后既是HTTPS"><a href="#HTTP加上加密处理和认证以及完整性保护后既是HTTPS" class="headerlink" title="HTTP加上加密处理和认证以及完整性保护后既是HTTPS"></a>HTTP加上加密处理和认证以及完整性保护后既是HTTPS</h3><h3 id="HTTPS是身披SSL外壳的HTTP"><a href="#HTTPS是身披SSL外壳的HTTP" class="headerlink" title="HTTPS是身披SSL外壳的HTTP"></a>HTTPS是身披SSL外壳的HTTP</h3><p>通常，HTTP直接和TCP通信。当使用SSL是，怎演变成先和SSL通信，再由SSL和TCP通信。</p><h3 id="相互交换密钥的公开密钥加密技术"><a href="#相互交换密钥的公开密钥加密技术" class="headerlink" title="相互交换密钥的公开密钥加密技术"></a>相互交换密钥的公开密钥加密技术</h3><p>共享密钥加密：加密和解密用同一个密钥的方式，也称为对称密钥加密。</p><p>公开密钥加密使用一堆非对称的密钥，一把叫做私有密钥，另一把叫做公开密钥。</p><p>HTTPS采用混合加密机制，先使用非对称密钥加解密，建立通信，交换共享密钥，然后使用共享密钥通信。</p><h3 id="证明公开密钥正确性的证书"><a href="#证明公开密钥正确性的证书" class="headerlink" title="证明公开密钥正确性的证书"></a>证明公开密钥正确性的证书</h3><p>公开密钥加密方式存在一些问题。那就是无法证明公开密钥本身货真价实的公开密钥。为了解决这个问题，可以使用由数字证书认证机构和其相关机关颁发的公开密钥证书。</p><p>流程：</p><p>（1）需要认证的<code>服务器A</code>把自己的公开密钥登录至数字证书认证机构，进行认证。</p><p>（2）数字证书认证机构用自己的私有密钥，向需要认证的<code>服务器A</code>的公开密钥签署数字签名并颁发公钥证书（公钥证书：包括 公钥和认证机构的签名）</p><p>（3）客户端拿到要访问的<code>服务器A</code>的公钥证书后，使用数字证书认证机构的公开密钥（数字证书认证机构的公开密钥已经事先植入到了浏览器里），验证公钥证书上的数字签名是该认证机构颁发的，以确认<code>服务器A</code>的公开密钥的真实性。</p><p>（4）使用服务器的公开密钥对报文加密后发送</p><p>（5）服务器使用私有密钥对报文解密。</p><ul><li><p>用以确认客户端的客户端证书</p><p>HTTPS中还可以使用客户端证书，以客户端证书进行客户端认证，证明服务器正在通信的对方时钟是预料之内的客户端。现在，客户端证书多用于，支持客户端证书支出费用的业务。例如，银行的网上银行，这登录网银时，不紧要求用户确认输入的ID和密码，还会要求用户的客户端证书，以确认用户是否是特定的终端访问网银，但是不能证明用户本人的真是有效性。</p></li><li><p>认证机构信誉第一</p><p>如果认证机构遭受攻击，那就jj了。</p></li><li><p>自由认证机构颁发的证书称为自签名证书</p><p>如果使用OpenSSL这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。但是该服务器证书在互联网上似乎没有什么帮助。</p></li></ul><h3 id="HTTPS的安全通信机制"><a href="#HTTPS的安全通信机制" class="headerlink" title="HTTPS的安全通信机制"></a>HTTPS的安全通信机制</h3><p>通信步骤：</p><ol><li>客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的的加密算法及密钥长度等）</li><li>服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li><li>之后服务器发送Certificate报文。报文中包含公开私钥证书。</li><li>最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。</li><li>SSL第一次握手结束后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种称为Pre-master secret 的随机密码串。该报文已用步骤3中的公开密钥进行加密。</li><li>接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密</li><li>客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能成功，要以服务器是否能够正确解密该该报文作为判定标准</li><li>服务器同样发送Change Cipher Spec报文</li><li>服务器同样发送Finished报文</li><li>服务器和客户端的Finished报文交换完毕后，SSL连接诶就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。</li><li>应用层协议通信，即发送HTTP响应。</li><li>最后由客户端断开连接。断开连接时，发送close_notify报文。这步之后再发送TCP FIN报文来关闭与TCP的通信。</li></ol><p>上述流程中，应用层发送数据时会附加一种叫做MAC（Message Authentication Code）的报文摘要。MAC能够查知报文是否遭到篡改，从而保证报文的完整性。</p><p><img src="./http协议/HTTPS过程.png" alt="HTTPS流程"></p><p>SSL和TLS</p><p>HTTPS使用SSL和TLS两个协议</p><p>HTTPS也存在一些问题就是当使用SSL时，它的处理速度会变慢。一种是通信满，另一种是指大量消耗CPU及内存等资源。</p><h1 id="确认访问用户身份的认证"><a href="#确认访问用户身份的认证" class="headerlink" title="确认访问用户身份的认证"></a>确认访问用户身份的认证</h1>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;可以&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考&lt;/a&gt;，以及《图解HTTP》,进行学习&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;绝对URI格式&lt;br&gt;&lt;code&gt;http://user:pass@www.example.com:80/dir/index.html/uid=1#ch1&lt;/code&gt;&lt;br&gt;http:或https:等协议方案名获取访问资源是要指定协议类型。不区分字母大小写，最后附一个冒号(:)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://&lt;/code&gt;:协议方案名&lt;br&gt;&lt;code&gt;user:pass&lt;/code&gt;:登录信息（认证）（可选）&lt;br&gt;&lt;code&gt;www.example.com&lt;/code&gt;：服务器地址&lt;br&gt;&lt;code&gt;80&lt;/code&gt;:服务器端口号&lt;br&gt;&lt;code&gt;/dir/index.html&lt;/code&gt;:带层次的文件路径&lt;br&gt;&lt;code&gt;uid&lt;/code&gt;：查询字符串&lt;br&gt;&lt;code&gt;ch1&lt;/code&gt;:片段标识符&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RFC&lt;/code&gt;:Request for Comments 征求修正意见书&lt;br&gt;通常，应用程序会遵照RFC确定的标准实现。可以说，RFC是互联网的设计文档，要是不按照RFC标准执行，就有可能导致无法通信的状况。&lt;/p&gt;
&lt;p&gt;请求报文的构成&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;POST(方法)  /form/entry(URI)  HTTP/&lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt;(协议版本) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//请求首部字段&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Host: example.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Connection:keep-alive&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Content-Type:appllication/x-www-form-urlencoded&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Content-Length:&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//请求首部字段结束&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//内容实体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;name=sfqq&amp;amp;age=&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;响应报文：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;HTTP/&lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt; OK(状态码的原因短语)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;: Wed, &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt; Mar &lt;span class=&quot;number&quot;&gt;2017&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;07&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;52&lt;/span&gt; GMT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Content-Length:&lt;span class=&quot;number&quot;&gt;455&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Content-Type:text/html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//主体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;HTTP是一种不保存状态的协议，HTTP协议自身不对请求和响应之间的通信状态进行保存。这是为了更快的处理大量事务，确保协议可伸缩性，而特意把HTTP协议设计成如此简单。但为了事项期望的保持状态的功能，于是引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态了。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="协议" scheme="http://fsysfq.top/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="http" scheme="http://fsysfq.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>JS clientWidth offsetWidth offsetLeft clientX offsetX等差异</title>
    <link href="http://fsysfq.top/2017/03/17/JS-clientWidth-offsetWidth-offsetLeft-clientX-offsetX%E7%AD%89%E5%B7%AE%E5%BC%82/"/>
    <id>http://fsysfq.top/2017/03/17/JS-clientWidth-offsetWidth-offsetLeft-clientX-offsetX等差异/</id>
    <published>2017-03-17T11:41:21.000Z</published>
    <updated>2018-07-07T13:18:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/03/17/JS-clientWidth-offsetWidth-offsetLeft-clientX-offsetX等差异/element.jpg" alt="element"></p><table><thead><tr><th>属性/方法</th><th>描述</th></tr></thead><tbody><tr><td>element.clientHeight</td><td>返回元素可见高度</td></tr><tr><td>element.clientWidth</td><td>返回元素的可见宽度</td></tr><tr><td>element.offsetHeight</td><td>返回元素的高度</td></tr><tr><td>element.offsetWidth</td><td>返回元素宽度</td></tr><tr><td>element.offsetLeft</td><td>返回元素的水平偏移位置</td></tr><tr><td>element.offsetParent</td><td>返回元素的偏移容器</td></tr><tr><td>element.offsetTop</td><td>返回元素的垂直偏移位置</td></tr><tr><td>element.scrollHeight</td><td>返回元素的整体高度。</td></tr><tr><td>element.scrollLeft</td><td>返回元素左边缘与视图之间的距离。</td></tr><tr><td>element.scrollTop</td><td>返回元素上边缘与视图之间的距离。</td></tr><tr><td>element.scrollWidth</td><td>返回元素的整体宽度。</td></tr><tr><td>event.clientX</td><td>返回当事件被触发时，鼠标指针的水平坐标。（相对浏览器）</td></tr><tr><td>event.clientY</td><td>返回当事件被触发时，鼠标指针的垂直坐标。（相对浏览器）</td></tr><tr><td>event.pageX</td><td>返回当事件被触发时，鼠标指针的水平坐标。（相对文档，非标准但广泛支持，IE&lt;9无）</td></tr><tr><td>event.pageY</td><td>返回当事件被触发时，鼠标指针的垂直坐标。（相对文档，非标准但广泛支持，IE&lt;9无）</td></tr><tr><td>event.screenX</td><td>返回当某个事件被触发时，鼠标指针的水平坐标。(相对屏幕)</td></tr><tr><td>event.screenY</td><td>返回当某个事件被触发时，鼠标指针的垂直坐标。（相对屏幕）</td></tr><tr><td>event.offsetX</td><td>发生事件的地点在事件源元素的坐标系统中的 x 坐标(相对于鼠标点击的元素)</td></tr><tr><td>event.offsetY</td><td>发生事件的地点在事件源元素的坐标系统中的 y 坐标(相对于鼠标点击的元素)</td></tr></tbody></table><p><img src="/2017/03/17/JS-clientWidth-offsetWidth-offsetLeft-clientX-offsetX等差异/event.png" alt="event"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2017/03/17/JS-clientWidth-offsetWidth-offsetLeft-clientX-offsetX等差异/element.jpg&quot; alt=&quot;element&quot;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属
      
    
    </summary>
    
      <category term="技术" scheme="http://fsysfq.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js" scheme="http://fsysfq.top/tags/js/"/>
    
      <category term="DOM" scheme="http://fsysfq.top/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>JS OffsetParent属性深入解析</title>
    <link href="http://fsysfq.top/2017/03/17/JS-OffsetParent%E5%B1%9E%E6%80%A7%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
    <id>http://fsysfq.top/2017/03/17/JS-OffsetParent属性深入解析/</id>
    <published>2017-03-17T10:12:52.000Z</published>
    <updated>2018-07-06T06:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.jb51.net/article/45555.htm" target="_blank" rel="noopener">参考</a></p><p>offsetParent属性返回一个对象的引用，这个对象是距离调用offsetParent的元素最近的（在包含层次中最靠近的），并且是已进行过CSS定位的容器元素。 如果这个容器元素未进行CSS定位, 则offsetParent属性的取值为根元素(在标准兼容模式下为html元素；在怪异呈现模式下为body元素)的引用。 当容器元素的style.display 被设置为 “none”时（译注：IE和Opera除外），offsetParent属性 返回 null。<br>语法：<br>parentObj = element.offsetParent<br>变量：<br> parentObj 是一个元素的引用，当前元素的偏移量在其中计算。<br>主要结论：</p><ul><li><p>当某个元素及其DOM结构层次中元素都未进行CSS定位时(absolute或者relative)[或者某个元素进行CSS定位时而DOM结构层次中元素都未进行CSS定位时],则这个元素的offsetParent属性的取值为根元素。更确切地说，这个元素的各种偏移量计算（offsetTop、offsetLeft等）的参照物为Body元素。(其实无论时标准兼容模式还是怪异模式，根元素都为Body元素)</p></li><li><p>当某个元素的父元素进行了CSS定位时（absolute或者relative），则这个元素的offsetParent属性的取值为其父元素。更确切地说，这个元素的各种偏移量计算（offsetTop、offsetLeft等）的参照物为其父元素</p></li><li><p>当某个元素及其父元素都未进行CSS定位时（absolute或者relative），则这个元素的offsetParent属性的取值为在DOM结构层次中距离其最近，并且已进行了CSS定位的元素。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.jb51.net/article/45555.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;offsetParent属性返回一个对象的引用，这个对象是距离调用offsetParen
      
    
    </summary>
    
    
      <category term="js" scheme="http://fsysfq.top/tags/js/"/>
    
      <category term="css" scheme="http://fsysfq.top/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>redux学习笔记</title>
    <link href="http://fsysfq.top/2017/03/10/redux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://fsysfq.top/2017/03/10/redux学习笔记/</id>
    <published>2017-03-10T07:09:45.000Z</published>
    <updated>2018-07-06T06:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><blockquote><p><a href="http://redux.js.org/?q=#" target="_blank" rel="noopener">http://redux.js.org/?q=#</a><br>入门参考：<br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html</a></p></blockquote><h2 id="设计思想："><a href="#设计思想：" class="headerlink" title="设计思想："></a>设计思想：</h2><blockquote><ol><li>Web 应用是一个状态机，视图和状态是一一对应的。</li><li>所有的状态，保存在一个对象里面</li></ol></blockquote><h2 id="基本概念和API"><a href="#基本概念和API" class="headerlink" title="基本概念和API"></a>基本概念和API</h2><ol><li><p>Store<br>Store就是保存数据的地方，可以把它看成一个容器。整个应用只能有一个Store。<br>Redux提供<code>createStore</code>这个函数，用来生成Store。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store=createStore(fn);</span><br></pre></td></tr></table></figure><p><code>createStore</code>函数接受另一函数作为参数，返回生成的Store对象      </p><a id="more"></a></li><li><p>State<br><code>Store</code>对象包含所有数据。如果想要得到某个时间点的数据，就要对Store生成快照。这种时点的数据集合，就叫做State。<br>当前时刻的State，可以通过store.getState()拿到。  </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line"><span class="keyword">const</span> state = store.getState();</span><br></pre></td></tr></table></figure><p>Redux规定，一个state对应一个view。只要state相同，view就相同。你知道state就知道view是什么样，反之亦然。</p></li><li><p>Action<br>State的变化导致view的变化。但是用户接触不到state，只能接触到view。所以，state的变化必须是view导致的。<br>action就是view发出的通知，表示state应该要发生变化了。<br>action就是一个对象。其中的<code>type</code>属性是必须的，表示action的名称。其他属性可以自由设置，社区有一个<a href="https://github.com/acdlite/flux-standard-action" target="_blank" rel="noopener">规范</a>可以参考</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> action=&#123;</span><br><span class="line">  type:<span class="string">"ADD_TODO"</span>,</span><br><span class="line">  payload:<span class="string">'learn Redux'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。   </p></li><li><p>Action Creator<br>View 要发送多少消息，就会有多少种Action。可以定义一个函数生成Action，这个函数就叫Action Creator。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">'添加 TODO'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    type:ADD_TODO,</span><br><span class="line">    payload:text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> action = addTodo(<span class="string">'Learn Redux'</span>);</span><br></pre></td></tr></table></figure><p><code>addTodo</code>函数就是一个Action Creator。  </p></li><li><p>store.dispatch()<br>store.dispatch() 是view 发出的唯一方法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type:<span class="string">'ADD_TODO'</span>,</span><br><span class="line">  payload:<span class="string">'Learn Redux'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>store.dispatch</code>接受一个Action对象作为参数，将它发送出去。<br>结合Action Creator ，这段代码可以改写如下：<br><code>store.dispatch(addTodo(&#39;learn Redux&#39;))</code></p></li><li><p>Reducer<br>store 收到Action 以后，必须给出一个新的state ，这样view才会发生变化。这种state的计算过程就叫做Reducer。<br>Reducer是一个函数，它接受Action 和当前 State 作为参数，返回一个新的state。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> new_state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个应用的初始状态，可以作为State的默认值。如下例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState ,action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + action.payload;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> state = reducer(<span class="number">1</span>, &#123;</span><br><span class="line">  type:<span class="string">'ADD'</span>,</span><br><span class="line">  payload:<span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，reducer函数收到名为ADD的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。<br>实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。</p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br></pre></td></tr></table></figure><p>上面代码中，createStore接受Reducer作为参数，生成一个新的Store。以后每当store.dispatch发送过来一个新的action，就会自动调用Reducer，得到新的state。<br>为什么这个函数叫做Reducer？因为他可以作为数组的reduce方法的参数。请看下面的例子，一系列action对象按照顺序作为一个数组。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = [</span><br><span class="line">  &#123;<span class="attr">type</span>:<span class="string">'ADD'</span>,<span class="attr">payload</span>:<span class="number">0</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">type</span>:<span class="string">'ADD'</span>,<span class="attr">payload</span>:<span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">type</span>:<span class="string">'ADD'</span>,<span class="attr">payload</span>:<span class="number">2</span>&#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> total = actions.reduce(reducer,<span class="number">0</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>上面代码中，数组actions表示依次有三个 Action，分别是加0、加1和加2。数组的reduce方法接受 Reducer 函数作为参数，就可以直接得到最终的状态3。</p><ol start="7"><li><p>纯函数<br>Reducer函数最重要特征是，他是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。<br>纯函数是函数编程的概念，必须遵守以下约束。</p><blockquote><p>不得改写参数<br>不能调用系统 I/O 的API<br>不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果</p></blockquote></li></ol><p>由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//state是一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,&#123; thingToChange &#125;);</span><br><span class="line">  <span class="comment">//或者</span></span><br><span class="line">  <span class="keyword">return</span> &#123;...state,...newState&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//state 是一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state,action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...state,newItem];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象</p><ol start="8"><li><p>store.subscribe()<br>store 允许使用store.subscribe方法设置监听函数，一旦state发生变化，就自动执行这个函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">store.subscribe(listener);</span><br></pre></td></tr></table></figure><p>显然，只要把view的更新函数（对于React项目，就是组件的render方法或setState方法）放入listen，就会实现view的自动渲染。<br>store.subscribe方法返回一个函数，调用这个函数就可以解除监听。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unsubscribe = store.subscribe(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">unsubscribe();</span><br></pre></td></tr></table></figure></li></ol><h1 id="Store的实现。"><a href="#Store的实现。" class="headerlink" title="Store的实现。"></a>Store的实现。</h1><p>  store提供了三个方法。</p><blockquote><p>store.getState()<br>store.dispatch()<br>store.subscribe()</p></blockquote>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">let</span> &#123;subscribe,dispatch,getState&#125; = createStore(reducer);</span><br></pre></td></tr></table></figure><p>createStore方法还可以接受第二个参数，表示 State 的最初状态。这通常是服务器给出的。</p><p><code>let store = createStore(todoApp, window.STATE_FROM_SERVER)</code></p><p>上面代码中，window.STATE_FROM_SERVER就是整个应用的状态初始值。注意，如果提供了这个参数，它会覆盖 Reducer 函数的默认初始值。<br>下面是createStore方法的一个简单实现，可以了解一下 Store 是怎么生成的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">let</span> listeners=[];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getState=<span class="function"><span class="params">()</span> =&gt;</span> state;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    state = reducer(state,action);</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">    listeners.push(listener);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      listeners = listeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !==listener);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dispatch(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;getState,dispatch,subscribe&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reducer的拆分"><a href="#Reducer的拆分" class="headerlink" title="Reducer的拆分"></a>Reducer的拆分</h1><p>  <code>Reducer函数负责生成state</code>。由于整个应用只有一个state对象，包含所有数据，对于大型应用来说，这个state必然十分庞大，导致Reducer函数也十分庞大。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chatReducer = <span class="function">(<span class="params">state = defaultState, action = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, payload &#125; = action;</span><br><span class="line">  <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_CHAT:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,&#123;</span><br><span class="line">        chatLog:state.chatLog.concat(payload)</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">case</span> CHANGE_STATUS:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,&#123;</span><br><span class="line">        statusMessage:payload</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">case</span> CHANGE_USERNAME:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,&#123;</span><br><span class="line">        userName:payload</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">default</span>:<span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面代码中，三种 Action 分别改变 State 的三个属性。   </p><blockquote><p>ADD_CHAT：chatLog属性<br>CHANGE_STATUS：statusMessage属性<br>CHANGE_USERNAME：userName属性<br>这三个属性之间没有联系，这提示我们可以把 Reducer 函数拆分。不同的函数负责处理不同属性，最终把它们合并成一个大的 Reducer 即可。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chatReducer = <span class="function">(<span class="params">state = defaultState,action = &#123;&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    chatLog:chatLog(state.chatLog,action),</span><br><span class="line">    statusMessage:statusMessage(state.statusMessage,action),</span><br><span class="line">    userName:userName(state.userName,action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，Reducer 函数被拆成了三个小函数，每一个负责生成对应的属性。<br>这样一拆，Reducer 就易读易写多了。而且，这种拆分与 React 应用的结构相吻合：一个 React 根组件由很多子组件构成。这就是说，子组件与子 Reducer 完全可以对应。<br>Redux 提供了一个<code>combineReducers</code>方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> chatReducer = combineReducers(</span><br><span class="line">  chatLog,</span><br><span class="line">  statusMessage,</span><br><span class="line">  userName</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> todoApp;</span><br></pre></td></tr></table></figure><p>上面的代码通过<code>combineReducers</code>方法将三个子 Reducer 合并成一个大的函数。<br>这种写法有一个前提，就是 State 的属性名必须与子 Reducer 同名。如果不同名，就要采用下面的写法。<br><code>只要视图发来一个action，sotre会调用每一个子reducer，每一个子reducer只会更新其对应的store的属性</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  a: doSomethingWithA,</span><br><span class="line">  b: processB,</span><br><span class="line">  c: c</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    a: doSomethingWithA(state.a, action),</span><br><span class="line">    b: processB(state.b, action),</span><br><span class="line">    c: c(state.c, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是<code>combineReducer</code>的简单实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combineReducers = <span class="function"><span class="params">reducers</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">state = &#123;&#125;,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(reducers).reduce(</span><br><span class="line">      (nextState,key) =&gt; &#123;</span><br><span class="line">        nextState[key] = reducers[key]( state[key] , action);</span><br><span class="line">        <span class="keyword">return</span> newxtState;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;&#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以吧所有的子Reducer放在一个文件里，然后统一引入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> reducers <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(reducers)</span><br></pre></td></tr></table></figure><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>  Redux的工作流程梳理：<br>  <a href="./Redux-flow.png">Redux Flow</a></p><p>首先，用户发出 Action。</p><p><code>store.dispatch(action);</code></p><p>然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。</p><p><code>let nextState = todoApp(previousState, action);</code></p><p>State 一旦有变化，Store 就会调用监听函数。</p><p>// 设置监听函数<br><code>store.subscribe(listener);</code></p><p>listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listerner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newState = store.getState();</span><br><span class="line">  component.setState(newState);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redux-入门教程（二）：中间件与异步操作"><a href="#Redux-入门教程（二）：中间件与异步操作" class="headerlink" title="Redux 入门教程（二）：中间件与异步操作"></a>Redux 入门教程（二）：中间件与异步操作</h1><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html</a></p></blockquote><pre><code>一个关键问题没有解决：异步操作怎么办？Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。</code></pre><p>怎么才能 Reducer 在异步操作结束后自动执行呢？这就要用到新的工具：中间件（middleware）。</p><h2 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h2><p>  为了理解中间件，让我们站在框架作者的角度思考问题：如果要添加功能，你会在哪个环节添加？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Reducer:纯函数，只承担计算State的功能，不适合承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。</span><br><span class="line"><span class="number">2.</span> View：与State 一一对应，可以看做State的视觉层，也不适合承担其他功能。</span><br><span class="line"><span class="number">3.</span> Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</span><br></pre></td></tr></table></figure><p>想来想去，只有发送Action的这个步骤，即<code>store.dispatch()</code>方法，可以添加功能。举例来说，要添加日志功能，把Action和State打印出来，<br>可以对<code>store.dispatch</code>进行如下改造。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> next = store.dispatch;</span><br><span class="line">store.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'dispatching'</span>,action);</span><br><span class="line">  next(action);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>,store.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中间件的用法"><a href="#中间件的用法" class="headerlink" title="中间件的用法"></a>中间件的用法</h2><p>本教程不涉及如何编写中间件，因为常用的中间件都有现成的，只要引用别人写好的模块即可。<br>比如，上一节的日志中间件，就有现成的<a href="https://github.com/evgenyrodionov/redux-logger" target="_blank" rel="noopener">redux-logger</a>模块。这里只介绍怎么使用中间件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;applyMiddleware,createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> createLogger <span class="keyword">from</span> <span class="string">'redux-logger'</span>;</span><br><span class="line"><span class="keyword">const</span> logger = createLogger();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>redux-logger</code>提供一个生成器<code>createLogger</code>,可以生成日志中间件<code>logger</code>。然后，将它放在<code>applyMiddleware</code>方法中，传入<code>createStore</code>方法，<br>就完成了<code>store.dispatch()</code>的功能增强。<br>这里有两点需要注意：</p><ol><li><code>createStore</code> 方法可以结接收整个应用的初始状态作为参数，那样的话，<code>applyMiddleware</code>就是第三个参数了。</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  initial_state,</span><br><span class="line">  applyMiddleware(logger)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="2"><li>中间件的次序有讲究</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> store = createStore(</span><br><span class="line">   reducer,</span><br><span class="line">   applyMiddleware(thunk,promise,logger)</span><br><span class="line"> )</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上面代码中，`</span>applyMiddleware<span class="string">`方法的三个参数，就是三个中间件。有的中间件有次序要求，使用前要查一下文档。比如，`</span>logger<span class="string">`就一定要放在最后，否则输出结果会不正确。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## applyMiddlewares()</span></span><br><span class="line"><span class="string">看到这里，你可能会问，`</span>applyMiddlewares<span class="string">`这个方法到底是干什么的？</span></span><br><span class="line"><span class="string">它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。下面是它的源码。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applayMiddleware</span>(<span class="params">...middlewares</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">createStore</span>) =&gt;</span> (reducer,preloadedState,enhancer)=&gt;&#123;</span><br><span class="line">    <span class="keyword">var</span> store = createStore(reducer,preloadedState,enhancer);</span><br><span class="line">    <span class="keyword">var</span> dispatch = store.dispatch;</span><br><span class="line">    <span class="keyword">var</span> chain = [];</span><br><span class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">      getState:store.getState,</span><br><span class="line">      dispatch:<span class="function">(<span class="params">action</span>)=&gt;</span>dispatch(action)</span><br><span class="line">    &#125;;</span><br><span class="line">    chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI));</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;...store,dispatch&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，所有中间件被放进了一个数组chain，然后嵌套执行，最后执行store.dispatch。可以看到，中间件内部（middlewareAPI）可以拿到getState和dispatch这两个方法。</p><h2 id="异步操作的基本思路"><a href="#异步操作的基本思路" class="headerlink" title="异步操作的基本思路"></a>异步操作的基本思路</h2><p>理解了中间件以后，就可以处理异步操作了。<br>同步操作只要发出一种Action即可，异步操作的差别就是他要出三种Action。</p><blockquote><ul><li>操作发起时的 Action</li><li>操作成功时的 Action</li><li>操作失败时的 Action<br>以向服务器获取数据为例，三种Action可以两种不同的写法。</li></ul></blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法一： 名相同，参数不同</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'FETCH_POSTS'</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'FETCH_POSTS'</span>, <span class="attr">status</span>: <span class="string">'error'</span>, <span class="attr">error</span>: <span class="string">'Oops'</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'FETCH_POSTS'</span>, <span class="attr">status</span>: <span class="string">'success'</span>, <span class="attr">response</span>: &#123; ... &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法二： 名称不同</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'FETCH_POSTS_REQUEST'</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'FETCH_POSTS_FAILURE'</span>, <span class="attr">error</span>:<span class="string">"Oops"</span>&#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'FETCH_POSTS_SUCCESS'</span>, <span class="attr">response</span>: &#123;...&#125;&#125;</span><br></pre></td></tr></table></figure><p>除了Action种类不同，异步操作的State也要进行改造，反应不同的操作状态。下面是State的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> state = &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  isFetching:<span class="literal">true</span>,</span><br><span class="line">  didInvalidate:<span class="literal">true</span>,</span><br><span class="line">  lastUpdated:<span class="string">'xxxxxx'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，State属性isFetching表示是否在抓取数据。didInvalidate表示数据是否过时，lastUpdate表示上一次更新时间。<br>现在，整个异步操作的思路就很清楚了。</p><ul><li>操作开始时，发出一个Action，触发State更新为“正在操作”状态，view重新渲染。</li><li>操作结束后，再送出一个Action，触发State更新为‘操作结束’状态，view再一次重新渲染。</li></ul><h2 id="redux-thunk-中间件"><a href="#redux-thunk-中间件" class="headerlink" title="redux-thunk 中间件"></a>redux-thunk 中间件</h2><p>异步操作至少要送出两个Action：用户触发第一个Action，这跟同步操作一样，没有问题。如何才能在操作结束时，系统自动送出第二个Action呢？<br>奥妙就在Action creator中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncApp</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch, selectedPost &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    dispatch(fetchPosts(selectedPost));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个异步组件的例子。加载成功后（componentDidMount方法），它送出了（dispatch方法）一个Action，向服务器要求数据<br><code>fetchPosts(selectedSubreddit)</code>。这里fetchPosts就是Action Creator。<br>下面就是fetchPosts的代码，关键之处就在里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Async Action  Example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fetch <span class="keyword">from</span> <span class="string">'isomorphic-fetch'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchFriends</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;<span class="attr">type</span>: <span class="string">"FETCH_FRIENDS"</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">'http://localhost/api/friends'</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">      .then(<span class="function"><span class="params">json</span> =&gt;</span>&#123;</span><br><span class="line">        dispatch(&#123;<span class="attr">type</span>: <span class="string">'RECEIVE_FRIENDS'</span>,<span class="attr">payload</span>:json&#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPosts = <span class="function"><span class="params">postTitle</span> =&gt;</span> (dispatch,getState)=&gt;&#123;</span><br><span class="line">  dispatch(requestPosts(postTitle));</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">`/some/API/<span class="subst">$&#123;postTitle&#125;</span>.json`</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function"><span class="params">json</span> =&gt;</span> dispatch(recervePosts(postTitle,json));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用方法一</span></span><br><span class="line">store.dispatch(fetchPosts(<span class="string">'reactjs'</span>))</span><br><span class="line"><span class="comment">//使用方法二</span></span><br><span class="line">store.dispatch(fetchPosts(<span class="string">'reactjs'</span>)).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>fetchPosts</code>是一个Action Creator（动作生成器），返回一个函数。这个函数执行后，先发出一个Action（<code>requestPosts(postTitle)</code>）,<br>然后进行异步操作，拿到结果后，先将结果转化为JSON格式，然后再发出一个Action（<code>receivePosts(postTitle,json)</code>）。</p><ol><li>fetchPosts返回了一个函数，而普通Action Creator默认返回一个对象。</li><li>返回的函数的参数是dispatch和getState这两个Redux方法，普通的Action Creator的参数是Action内容</li><li>返回的函数中，先发出一个Action（requestPosts(postTitle)），表示操作开始。</li><li><p>异步操作结束后，再发出一个Action（receivePost(postTitle,json)）,表示操作结束。<br>这样的处理，就解决了自动发送第二个Action 的问题。但是又带来了一个新的问题，Action是由store.dispatch发送的。而store.dispatch方法正常情况下，<br>参数只能是对象，而不能是函数。这时，就要使用中间件<a href="https://github.com/gaearon/redux-thunk" target="_blank" rel="noopener">redux-thunk</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> &#123;createStore, applyMiddleware&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"> <span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span></span><br><span class="line"> <span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Note: this  api requires redux@&gt;=3.1.0</span></span><br><span class="line"> <span class="keyword">const</span> store= createStore(</span><br><span class="line">   reducer,</span><br><span class="line">   applyMiddleware(thunk)</span><br><span class="line"> )</span><br></pre></td></tr></table></figure></li></ol><p>上面代码使用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。<br>因此，异步操作的第一种解决方案就是，写出一个返回函数的 Action Creator，然后使用redux-thunk中间件改造store.dispatch。</p><h2 id="redux-promise中间件"><a href="#redux-promise中间件" class="headerlink" title="redux-promise中间件"></a>redux-promise中间件</h2><p> 既然Action Creator可以返回函数，当然也可以返回其它值。另一种异步操作的解决方案，就是让Action Creator 返回一个Promise对象。<br> 这就需要使用redux-promise中间件。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> promiseMiddleware <span class="keyword">from</span> <span class="string">'redux-promise'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(promiseMiddleware)</span><br><span class="line">) ;</span><br></pre></td></tr></table></figure><p> 这个中间件是的<code>store.dispatch</code>方法可以接受Promise对象作为参数。这时，Action Creator有两种写法。<br> 写法一，返回值是一个Promise对象。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPosts = <span class="function">(<span class="params">dispatch, postTitle</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  dispatch(requestPosts(postTitle));</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">`/some/API/<span class="subst">$&#123;postTitle&#125;</span>.json`</span>)</span><br><span class="line">     .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">       type: <span class="string">'FETCH_POSTS'</span>,</span><br><span class="line">       payload: response.json()</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 写法二，Action对象的payload属性是一个Promise对象。这需要从<code>redux-actions</code>模块引入createAction方法，并且写法也要变成下面这样。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createAction &#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch , selectedPost &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="comment">//发出同步Action</span></span><br><span class="line">    dispatch(requestPosts(selectedPost));</span><br><span class="line">    <span class="comment">//发出异步Action</span></span><br><span class="line">    dispatch(createAction(</span><br><span class="line">      <span class="string">'FETCH_PSOTS'</span>,</span><br><span class="line">      fetch(<span class="string">`/some/API/<span class="subst">$&#123;postTitle&#125;</span>.json`</span>)</span><br><span class="line">         .then(<span class="function"><span class="params">response</span>=&gt;</span>response.json())</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面代码中，第二个<code>dispatch</code>方法发出的是异步Action，只有等到操作结束，这个Action才会实际发出。<br> 注意，createAction的 第二个参数必须是一个Promise对象。<br> 看一下<code>redux-promise</code>的<a href="https://github.com/acdlite/redux-promise/blob/master/src/index.js" target="_blank" rel="noopener">源码</a>，就会明白它内部是如何操作的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">promiseMiddleware</span>(<span class="params">&#123; dispatch &#125;</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(!isFSA(action))&#123;</span><br><span class="line">      <span class="keyword">return</span> isPromise(action)</span><br><span class="line">        ? action.then(dispatch)</span><br><span class="line">        : next(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isPromise(action.payload)</span><br><span class="line">      ? action.payload.then(</span><br><span class="line">        result =&gt; dispatch(&#123;...action,<span class="attr">payload</span>: result &#125;),</span><br><span class="line">        error =&gt;&#123;</span><br><span class="line">          dispatch(&#123;...action,<span class="attr">payoad</span>:error,<span class="attr">error</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">      : next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，如果Action本身是一个Promise，它resolve以后的值应该是一个Action，会被<br><code>dispatch</code>方法送出（<code>action.then(dispatch)</code>）,但reject以后不会有任何动作；如果Action对象<br>的<code>payload</code>属性是一个Promise对象，那么无论resolve和reject，dispatch方法都会发出Action。<br>中间件和异步操作，就介绍到这里。</p><h1 id="React-Redux-的用法"><a href="#React-Redux-的用法" class="headerlink" title="React-Redux 的用法"></a>React-Redux 的用法</h1><blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html</a></p></blockquote><h2 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI组件</h2><p>React-Redux将所有组件分成两大类：UI组件（presentational component）和容器组件（container component）</p><p>UI组件有以下几个特征。</p><ul><li>只负责UI的呈现，不带有任何业务组件</li><li>没有状态（即不使用this.state这个变量）</li><li>所有数据都由参数（this.props）提供</li><li><p>不使用任何Redux的API</p><p>下面就是一个UI组件的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Title=<span class="function"><span class="params">value</span> =&gt;</span> &lt;h1&gt;&#123;value&#125;&lt;<span class="regexp">/h1&gt;;</span></span><br></pre></td></tr></table></figure><p>因为不含有状态，UI组件又称为“纯组件”，即纯函数一样，纯粹由参数决定它的值。</p></li></ul><p>##容器组件<br>容器组件特征恰恰相反</p><ul><li>负责管理数据和业务逻辑，不负责 UI 的呈现。</li><li>带有内部状态state</li><li>使用Redux的API</li></ul><p>总之，UI组件负责UI的呈现，容器组件负责管理数据和逻辑。<br>如果一个组件既有UI又有业务逻辑，则将它拆分成下面的结构：外面是一个容器组件，里面包含了一个UI组件。前者负责与外部的通讯，将数据传给后者，由后者渲染出视图。<br>React-Redux规定，所有的UI组件都由用户提供，容器组件则是由React-Redux自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</p><h2 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h2><p>React-Redux提供connect方法，用于从UI组件生成容器组件。connect的意思，就是将这两种组件连起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">const</span> VisibleTodoList = connect()(TodoList);</span><br></pre></td></tr></table></figure><p>上面代码中，TodoList是UI组件，VisibleTodoList就是由React-Redux通过connect方法自动生成的容器组件。<br>但是，因为没有定义业务逻辑，上面这个容器组件毫无意义，只是UI组件的一个单纯的包装层。为了定义业务逻辑，需要给出下面两方面的信息。</p><ol><li>输入逻辑：外部的数据（即state对象）如何转换为UI组件的参数</li><li>输出逻辑：用户发出的动作如何变为 Action 对象，从UI组件传出去</li></ol><p>因此，connect方法的完整API如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">const</span> VisibleTodoList = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps,</span><br><span class="line">)(TodoList)</span><br></pre></td></tr></table></figure><p>上面代码中，connect 方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了UI组件的业务逻辑。<br>前者负责输入逻辑，即将state映射到UI组件的参数（props），后者负责输出逻辑，即将用户对UI组件的操作映射成Action。</p><h2 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps()"></a>mapStateToProps()</h2><p><code>mapStateToProps</code>是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI组件的）props对象的映射关系。<br>作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。请看下面的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    todos:getVisibleTodos(state.todos,state.visibilityFilter)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>mapStateToProps</code>是一个函数，它接受<code>state</code>作为参数，返回一个对象。这个对象有一个todos属性，代表UI组件的同名参数，<br>后面的<code>getVisibleTodos</code>也是一个函数，可以从<code>state</code>算出<code>todos</code>。<br>下面就是<code>getVisibleTodos</code>的一个例子，用来计算出<code>todos</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getVisibleTodos = <span class="function">(<span class="params">todos,filter</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(filter)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'SHOW_ALL'</span>:</span><br><span class="line">     <span class="keyword">return</span> todos;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'SHOW_COMPLETED'</span>:</span><br><span class="line">     <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span>=&gt;</span>t.completed)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'SHOW_ACTIVE'</span>:</span><br><span class="line">     <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> !t.completed)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unknow filter:'</span>+ filter)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mapStateToProps</code>会订阅Store，每当<code>state</code>更新的时候就会自动执行，重新计算UI组件的参数，从而触发UI组件的重新渲染。<br><code>mapStateToProps</code>的第一个参数总是<code>state</code>对象，还可以使用第二个参数，代表容器组件的props对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//容器组件的代码</span></span><br><span class="line"><span class="comment">//&lt;FilterLink filter="SHOW_ALL"&gt;</span></span><br><span class="line"><span class="comment">// ALL</span></span><br><span class="line"><span class="comment">//&lt;/FilterLink&gt;</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, ownProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    active: ownProps.filter === state.visibilityFilter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>ownProps</code>作为参数后，如果容器组件的参数发生变化，也会引发UI组件重新渲染。<br><code>connect</code>方法可以省略<code>mapStateToProps</code>参数，那样的话，UI组件就不会订阅Store，就是说Store的更新不会引起UI组件的更新。</p><h2 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps()"></a>mapDispatchToProps()</h2><p><code>mapDispatchToProps</code>是<code>connect</code>函数的第二个参数，用来建立UI组件的参数到<code>store.dispatch</code>方法的映射。也就是说，它定义了哪些<br>用户的操作应当作Action，传给Store。它可以是一个函数，也可以是一个对象。<br>如果<code>mapDispatchToProps</code>是一个函数，会得到<code>dispatch</code>和<code>ownProps</code>(容器组件的<code>props</code>对象)两个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = (</span><br><span class="line">  dispatch,</span><br><span class="line">  ownProps</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onClick:<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type:<span class="string">'SET_VISIBILITY_FILTER'</span>,</span><br><span class="line">        filter:ownProps.filter</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可以看到，<code>mapDispatchToProps</code>作为函数，应该返回一个对象，该对象的每一个键值对都是一个映射，定义了UI组件的参数怎样发出Action。<br>如果<code>mapDispatchToProps</code>是一个对象，它的每一个建名也是对应UI组件的同名参数，键值应该是一个函数，会被当做Action Creator，返回的Action<br>会由Redux自动触发，举例来说，上面的<code>mapDispatchToProps</code>写成对象就是下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  onClick:<span class="function">(<span class="params">filter</span>) =&gt;</span>&#123;</span><br><span class="line">    type:<span class="string">'SET_VISIBILITY_FILTER'</span>,</span><br><span class="line">    filter:filter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a><provider>组件</provider></h2><p><code>connect</code>方法生成容器组件以后，需要让容器组件拿到<code>state</code>对象，才能生成UI组件的参数。<br>一种解决方法是将<code>state</code>对象作为参数，传入容器组件。但是，这样做比较麻烦，尤其是容器组件可能在很深的层级，一级级将<code>state</code>传下去就很麻烦。<br>React-redux提供<code>Provider</code>组件，可以让容器组件拿到<code>state</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Prpvider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> todoApp  <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(todoApp);</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App/&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Provider</code>在根组件外面包了一层，这样一来，<code>App</code>的所有子组件就默认都可以拿到<code>state</code>了。<br>它的原理是<code>React</code>组件的<code>context</code>属性，请看源码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  getChildContext()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      store:<span class="keyword">this</span>.props.store</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Provider.childContextTypes = &#123;</span><br><span class="line">  store:React.PropTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>store</code>放在了上下文对象<code>context</code>。然后，子组件就可以从<code>context</code>拿到<code>store</code>，代码大致如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisibleTodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="keyword">this</span>.unsubscribe= store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      <span class="keyword">this</span>.forceUpdate()</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">const</span> props = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="keyword">const</span> state = store.getState;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">VisibleTodoList.contextTypes = &#123;</span><br><span class="line">  store: React.PropsTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>React-Redux</code>自动生成的容器组件代码，就类似上面这样，从而拿到<code>store</code>.</p><h2 id="实例：计数器"><a href="#实例：计数器" class="headerlink" title="实例：计数器"></a>实例：计数器</h2><p>下面是一个计数器组件，它是一个纯的UI组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value, onIncreaseClick &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;span&gt;&#123;vlaue&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick = &#123;onIncreaseClick&#125;&gt;Increase&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，这个 UI 组件有两个参数：value和onIncreaseClick。前者需要从state计算得到，后者需要向外发出Action。<br>接着，定义<code>value</code>到<code>state</code>的映射，以及<code>onIncreaseClick</code>到<code>dispatch</code>的映射。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value:state.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onIncreaseClick:<span class="function"><span class="params">()</span> =&gt;</span> dispatch(increaseAction)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Action Creator</span></span><br><span class="line"><span class="keyword">const</span> increaseAction = &#123; <span class="attr">type</span>: <span class="string">'increase'</span> &#125;;</span><br></pre></td></tr></table></figure><p>然后，使用<code>connect</code>方法生成容器组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(Counter)</span><br></pre></td></tr></table></figure><p>然后定义这个组件的Reducer。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reducer</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">state = &#123;count:<span class="number">0</span> &#125;, action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = state.count</span><br><span class="line">  <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increase'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>:count +<span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，生成<code>store</code>对象，并使用<code>Provider</code>在根组件外面包一层。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; loadState, saveState &#125; <span class="keyword">from</span> <span class="string">'./localStorage'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> persistedState = loadState();</span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  todoApp,</span><br><span class="line">  persistedState</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">store.subscribe(throttle(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  saveState(&#123;</span><br><span class="line">    todos:store.getState().todos,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store = &#123;store&#125;&gt;</span><br><span class="line">    &lt;App/&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')  </span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>完整代码看<a href="https://github.com/jackielii/simplest-redux-example/blob/master/index.js" target="_blank" rel="noopener">这里</a>.</p><h2 id="React-Router-路由库"><a href="#React-Router-路由库" class="headerlink" title="React-Router 路由库"></a>React-Router 路由库</h2><p>使用<code>React-Router</code>的项目，与其他项目没有不同之处，也是使用<code>Provider</code>在<code>Router</code>外面包一层，毕竟<code>Provider</code>的唯一功能就是传入<code>store</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Root = <span class="function">(<span class="params">&#123; store &#125;</span>) =&gt;</span>(</span><br><span class="line">  &lt;Provider store=&#123; store &#125;&gt;</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &lt;Route path=<span class="string">'/'</span> component=&#123;App&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Provider&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redux&quot;&gt;&lt;a href=&quot;#Redux&quot; class=&quot;headerlink&quot; title=&quot;Redux&quot;&gt;&lt;/a&gt;Redux&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://redux.js.org/?q=#&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://redux.js.org/?q=#&lt;/a&gt;&lt;br&gt;入门参考：&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;设计思想：&quot;&gt;&lt;a href=&quot;#设计思想：&quot; class=&quot;headerlink&quot; title=&quot;设计思想：&quot;&gt;&lt;/a&gt;设计思想：&lt;/h2&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Web 应用是一个状态机，视图和状态是一一对应的。&lt;/li&gt;
&lt;li&gt;所有的状态，保存在一个对象里面&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本概念和API&quot;&gt;&lt;a href=&quot;#基本概念和API&quot; class=&quot;headerlink&quot; title=&quot;基本概念和API&quot;&gt;&lt;/a&gt;基本概念和API&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Store&lt;br&gt;Store就是保存数据的地方，可以把它看成一个容器。整个应用只能有一个Store。&lt;br&gt;Redux提供&lt;code&gt;createStore&lt;/code&gt;这个函数，用来生成Store。&lt;/p&gt;
&lt;figure class=&quot;highlight jsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123;createStore&amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;redux&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; store=createStore(fn);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;createStore&lt;/code&gt;函数接受另一函数作为参数，返回生成的Store对象      &lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://fsysfq.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="react" scheme="http://fsysfq.top/tags/react/"/>
    
      <category term="redux" scheme="http://fsysfq.top/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>react tips</title>
    <link href="http://fsysfq.top/2017/03/04/react-tips/"/>
    <id>http://fsysfq.top/2017/03/04/react-tips/</id>
    <published>2017-03-04T14:40:18.000Z</published>
    <updated>2018-07-06T06:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断数据项是否是state"><a href="#判断数据项是否是state" class="headerlink" title="判断数据项是否是state"></a><code>判断数据项是否是state</code></h1><p>简单地对每一项数据提出三个问题：  </p><ul><li>是否是从父级通过 props 传入的？如果是，可能不是 state 。</li><li>是否会随着时间改变？如果不是，可能不是 state 。</li><li>能根据组件中其它 state 数据或者 props 计算出来吗？如果是，就不是 state 。</li></ul><h1 id="记住：-React-中数据是沿着组件树从上到下单向流动的。"><a href="#记住：-React-中数据是沿着组件树从上到下单向流动的。" class="headerlink" title="记住： React 中数据是沿着组件树从上到下单向流动的。"></a><code>记住： React 中数据是沿着组件树从上到下单向流动的。</code></h1><p>可能不会立刻明白哪个组件应该拥有哪些 state 数据模型。<br>这对新手通常是最难理解和最具挑战的，因此跟随以下步骤来弄清楚这点：<br>对于应用中的每一个 state 数据：</p><ul><li>找出每一个基于那个 state 渲染界面的组件。</li><li>找出共同的祖先组件（某个单个的组件，在组件树中位于需要这个 state 的所有组件的上面）。</li><li>要么是共同的祖先组件，要么是另外一个在组件树中位于更高层级的组件应该拥有这个 state 。</li><li><p>如果找不出拥有这个 state 数据模型的合适的组件，创建一个新的组件来维护这个 state ，然后添加到组件树中，层级位于所有共同拥有者组件的上面。</p><a id="more"></a><h1 id="state更新"><a href="#state更新" class="headerlink" title="state更新"></a>state更新</h1></li><li><p>不要直接更改state的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">'Hello'</span>;];</span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">comment</span>: <span class="string">'Hello'</span>&#125;);</span><br><span class="line"><span class="comment">//只有在构造函数中可以为this.state赋值</span></span><br></pre></td></tr></table></figure></li><li><p>state更新可能是异步的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Correct </span></span><br><span class="line"><span class="comment">//@param  prevState是state的前一个状态</span></span><br><span class="line"><span class="comment">//@param  props是当前传入的this.props的值</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li></ul><h1 id="React中函数式声明组件"><a href="#React中函数式声明组件" class="headerlink" title="React中函数式声明组件"></a><code>React中函数式声明组件</code></h1><blockquote><p><a href="https://segmentfault.com/a/1190000006180667" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006180667</a></p></blockquote><p>React中的每一个组件，都包含有一个属性（props），属性主要是从父组件传递给子组件，<br>在组件内部，我们可以通过this.props获取属性对象。</p><h1 id="React-中-context-的使用"><a href="#React-中-context-的使用" class="headerlink" title="React 中 context 的使用"></a><code>React 中 context 的使用</code></h1><p>为了有时候想传递数据通过组件树，但是不想给每一层级的组件手动传递属性，<br>那么 context 就能帮你 “越级” 传递数据到组件树中你想传递到的深层次组件。<br>有时候 A组件 为了给 B组件 中的 C组件 传递一个 prop ，<br>而需要把参数在组件中传递两次才能最终将 A组件 中的 prop 传递给 C组件 。</p><blockquote><p><a href="https://facebook.github.io/react/docs/context.html" target="_blank" rel="noopener">https://facebook.github.io/react/docs/context.html</a><br><a href="https://segmentfault.com/a/1190000005356878?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005356878?utm_source=tuicool&amp;utm_medium=referral</a></p></blockquote><h1 id="ref的值"><a href="#ref的值" class="headerlink" title="ref的值"></a><code>ref的值</code></h1><p>ref的值有两种类型，一种是字符串，一种是回调函数。<br>ref属性也可以是一个回调函数而不是一个名字。   这个函数将要在组件被挂载之后立即执行</p><h1 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a><code>PropTypes</code></h1><p>PropTypes.arrayOf()指定类型组成的数组，PropTypes.shape()指定特定属性组成的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TodoList.propTypes = &#123;</span><br><span class="line">  todos: PropTypes.arrayOf(PropTypes.shape(&#123;</span><br><span class="line">    id: PropTypes.number.isRequired,</span><br><span class="line">    completed: PropTypes.bool.isRequired,</span><br><span class="line">    text: PropTypes.string.isRequired</span><br><span class="line">  &#125;).isRequired).isRequired,</span><br><span class="line">  onTodoClick: PropTypes.func.isRequired</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a><code>componentWillReceiveProps</code></h1><p>在组件接收到新的 props 的时候调用。在初始化渲染的时候，该方法不会调用。<br>用此函数可以作为 react 在 prop 传入之后， render() 渲染之前更新 state 的机会。<br>老的 props 可以通过 this.props 获取到。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;判断数据项是否是state&quot;&gt;&lt;a href=&quot;#判断数据项是否是state&quot; class=&quot;headerlink&quot; title=&quot;判断数据项是否是state&quot;&gt;&lt;/a&gt;&lt;code&gt;判断数据项是否是state&lt;/code&gt;&lt;/h1&gt;&lt;p&gt;简单地对每一项数据提出三个问题：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否是从父级通过 props 传入的？如果是，可能不是 state 。&lt;/li&gt;
&lt;li&gt;是否会随着时间改变？如果不是，可能不是 state 。&lt;/li&gt;
&lt;li&gt;能根据组件中其它 state 数据或者 props 计算出来吗？如果是，就不是 state 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;记住：-React-中数据是沿着组件树从上到下单向流动的。&quot;&gt;&lt;a href=&quot;#记住：-React-中数据是沿着组件树从上到下单向流动的。&quot; class=&quot;headerlink&quot; title=&quot;记住： React 中数据是沿着组件树从上到下单向流动的。&quot;&gt;&lt;/a&gt;&lt;code&gt;记住： React 中数据是沿着组件树从上到下单向流动的。&lt;/code&gt;&lt;/h1&gt;&lt;p&gt;可能不会立刻明白哪个组件应该拥有哪些 state 数据模型。&lt;br&gt;这对新手通常是最难理解和最具挑战的，因此跟随以下步骤来弄清楚这点：&lt;br&gt;对于应用中的每一个 state 数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找出每一个基于那个 state 渲染界面的组件。&lt;/li&gt;
&lt;li&gt;找出共同的祖先组件（某个单个的组件，在组件树中位于需要这个 state 的所有组件的上面）。&lt;/li&gt;
&lt;li&gt;要么是共同的祖先组件，要么是另外一个在组件树中位于更高层级的组件应该拥有这个 state 。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果找不出拥有这个 state 数据模型的合适的组件，创建一个新的组件来维护这个 state ，然后添加到组件树中，层级位于所有共同拥有者组件的上面。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://fsysfq.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="react" scheme="http://fsysfq.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>responsive web design 笔记 </title>
    <link href="http://fsysfq.top/2017/03/04/responsive-web-design-%E7%AC%94%E8%AE%B0/"/>
    <id>http://fsysfq.top/2017/03/04/responsive-web-design-笔记/</id>
    <published>2017-03-04T14:06:50.000Z</published>
    <updated>2018-07-06T06:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="响应式网站设计"><a href="#响应式网站设计" class="headerlink" title="响应式网站设计"></a>响应式网站设计</h1><h2 id="本文是在学习responsive-web-design时，做的笔记。"><a href="#本文是在学习responsive-web-design时，做的笔记。" class="headerlink" title="本文是在学习responsive-web-design时，做的笔记。"></a>本文是在学习<a href="https://github.com/sivkun/responsive-web-design" target="_blank" rel="noopener">responsive-web-design</a>时，做的笔记。</h2><h2 id="响应式网站设计的优点"><a href="#响应式网站设计的优点" class="headerlink" title="响应式网站设计的优点"></a>响应式网站设计的优点</h2><ul><li>减少工作量<br>  网站、设计、代码、内容都只需要一份<br>  多出来的工作量只是js脚本、css样式做一些改动</li><li>节省时间</li><li>每个设备都能得到正确的设计</li><li>搜索优化</li></ul><h2 id="响应式网站设计的缺点"><a href="#响应式网站设计的缺点" class="headerlink" title="响应式网站设计的缺点"></a>响应式网站设计的缺点</h2><ul><li>会加载更多的样式和脚本资源</li><li>设计比较难精准定位和控制</li><li>老版本浏览器兼容不好</li></ul><h2 id="CSS3-媒体属性简介-略"><a href="#CSS3-媒体属性简介-略" class="headerlink" title="CSS3 媒体属性简介 略"></a>CSS3 媒体属性简介 略</h2><h2 id="viewport视口"><a href="#viewport视口" class="headerlink" title="viewport视口"></a>viewport视口</h2><p><code>布局视口（layout viewport）</code>: 虚拟的视口将页面呈现出来，布局视口的宽度是不变的。<br><code>可视视口（visual viewport）</code>:  对布局视口呈现出来的页面进行放大或者缩小，在固定的设备显示器看到的网页的内容区域的内容范围或大或小。<br> 比方说：320px宽的显示屏，网页宽度为960px，在显示屏中显示这个网页，渲染时会按照网页960px的宽度进行渲染，然后将整个页面缩放三分之一，<br> 这样整个页面显示出来，此时可视视口为960px因为整个页面你都看到了，即布局视口宽度等于可视视口宽度。将页面放大，在320px的设备中，<br> 只会看到页面的一部分，可视视口变小。可视视口尺寸不固定，随着用户缩放页面改变。 （默认宽度是屏幕的宽度）<br> 像是拿着放大镜看书，书是布局视口，通过放大镜看到的是可视视口，随着放大镜离书的远近，可视视口改变，左右移动放大镜，可看到整个书的内容。<br> 这样的话用户浏览网页时，需要不断的滑动、放大页面，很不方便。<br><code>理想视口（ideal viewport）</code>：布局视口在一个设备上的最佳尺寸。理想视口下的页面便于浏览器浏览阅读。<br>  理想视口就是为了构架手机浏览器优化的页面而添加的<br><a id="more"></a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span>/&gt;</span> <span class="comment">&lt;!--告诉设备要使用理想视口，该宽度等于屏幕的宽度。--&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果不指定上面属性，布局视口的宽度是设备厂商的默认值，指定该属性布局视口成为理想视口。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,minimum-scale=1.0,maximum=1.0,user-scaleable=no"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--最小缩放比例、最大缩放比例、 禁止缩放--&gt;</span></span><br></pre></td></tr></table></figure><p>渐进增强<br>优雅降级（推荐）</p><h2 id="响应式网站设计实践原则"><a href="#响应式网站设计实践原则" class="headerlink" title="响应式网站设计实践原则"></a>响应式网站设计实践原则</h2><ul><li>断点选择<br>例如：<br>0~480 小屏幕<br>481~800 中屏幕<br>801~1400 大屏幕<br>1400+ 巨屏幕</li></ul><h2 id="如何组织项目目录结构"><a href="#如何组织项目目录结构" class="headerlink" title="如何组织项目目录结构"></a>如何组织项目目录结构</h2><ul><li>约定优于配置（convention over configuration）<br>约定代码结构或命名规范减少配置数量<br>css vs style<br>img vs image<br>image vs images</li></ul><h2 id="markdown语法"><a href="#markdown语法" class="headerlink" title="markdown语法"></a>markdown语法</h2><p>dillinger.io 在线md编辑器<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用名言</span><br><span class="line"></span><br><span class="line">[百度](http://www.baidu.com)</span><br><span class="line"></span><br><span class="line">![图片](src/favicon.icon)</span><br><span class="line"></span><br><span class="line">**粗体** *斜体* ***粗体加斜体***</span><br><span class="line"></span><br><span class="line">表格</span><br><span class="line"></span><br><span class="line">|col1|col2|col3|</span><br><span class="line">|---:|:---:|:---|</span><br><span class="line">|col11111|col2dddddd|col333333|</span><br><span class="line">|col1|col2|col3|</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><hr><blockquote><p>引用名言</p></blockquote><p><a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a></p><p><img src="/2017/03/04/responsive-web-design-笔记/favicon.icon" alt="图片"></p><p><strong>粗体</strong> <em>斜体</em> <strong><em>粗体加斜体</em></strong></p><p>表格</p><table><thead><tr><th style="text-align:right">col1</th><th style="text-align:center">col2</th><th style="text-align:left">col3</th></tr></thead><tbody><tr><td style="text-align:right">col11111</td><td style="text-align:center">col2dddddd</td><td style="text-align:left">col333333</td></tr><tr><td style="text-align:right">col1</td><td style="text-align:center">col2</td><td style="text-align:left">col3</td></tr></tbody></table><hr><h2 id="html5标签"><a href="#html5标签" class="headerlink" title="html5标签"></a>html5标签</h2><p><code>&lt;article&gt;</code>标签是<code>&lt;section&gt;</code>标签的子集。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>在网页中，一些必不可少的图片使用<code>&lt;img&gt;</code>引入，可有可无的装饰性图片可以用标签的style引入。</li></ul><h2 id="px-em-rem"><a href="#px-em-rem" class="headerlink" title="px em rem"></a>px em rem</h2><ul><li>px 1个px相当于1个像素</li><li>em 相对长度单位<ol><li>em相对参照物为父元素的font-size</li><li>em 具有继承的特点</li><li>当没有设置font-size时，浏览器会有一个默认的em设置：1em=16px</li></ol><ul><li>em 的缺点：容易混乱</li></ul></li><li>rem<ol><li>rem的相对参照物为根元素html，相对于参照固定不变，所以较好计算</li><li>当没有设置font-size时，浏览器会有一个默认的rem设置：1rem=16px,这点与em是一致的<br>font-size:62.5% 1rem=10px (10/16*100%)<br>font-size:100% 1rem = 16px </li></ol></li></ul><h2 id="清除浮动-预防高度塌陷"><a href="#清除浮动-预防高度塌陷" class="headerlink" title="清除浮动,预防高度塌陷"></a>清除浮动,预防高度塌陷</h2><ol><li>加标签： <code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code></li><li>浮动容器加 <code>overflow:auto</code></li><li>包裹容器加 <code>float</code></li><li>包裹容器加after伪元素设置css<code>clear:both</code></li></ol><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC:"></a>BFC:</h2><p>相关内容一大堆 </p><blockquote><p><a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="noopener">http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html</a><br><a href="http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/</a><br><a href="http://web.jobbole.com/84808/" target="_blank" rel="noopener">http://web.jobbole.com/84808/</a></p></blockquote><p>在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。  </p><ul><li>Box: CSS布局的基本单位<br>　　Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：<br>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；<br>inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；<br>run-in box: css3 中才有， 这儿先不讲了。</li><li>Formatting context<br>　　Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</li><li>BFC(Block formatting context)直译为”块级格式化上下文”。<br>它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</li></ul><p><code>BFC有三个特性</code></p><ul><li><p>BFC会阻止垂直外边距（margin-top、margin-bottom）折叠</p><p>  按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直Margin的重叠，这个包括相邻元素，嵌套元素，只要他们之间没有阻挡(例如边框，非空内容，padding等)就会发生margin重叠。<br>因此要解决margin重叠问题，只要让它们不在同一个BFC就行了，但是对于两个相邻元素来说，意义不大，没有必要给它们加个外壳，但是对于嵌套元素来说就很有必要了，只要把父元素设为BFC就可以了。这样子元素的margin就不会和父元素的margin发生重叠了。</p></li><li><p>BFC不会重叠浮动元素</p></li><li>BFC可以包含浮动</li></ul><p>我们可以利用BFC的第三条特性来“清浮动”，这里其实说清浮动已经不再合适，应该说包含浮动。<br>也就是说只要父容器形成BFC就可以，简单看看如何形成BFC</p><ol><li>float为 left|right</li><li>overflow为 hidden|auto|scroll</li><li>display为 table-cell|table-caption|inline-block</li><li>position为 absolute|fixed</li><li>我们可以对父容器添加这些属性来形成BFC达到“清浮动”效果</li></ol><p>flex布局</p><h2 id="导航栏的问题每一个标签之间出现空隙"><a href="#导航栏的问题每一个标签之间出现空隙" class="headerlink" title="导航栏的问题每一个标签之间出现空隙"></a>导航栏的问题每一个标签之间出现空隙</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>快速登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>帮助<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>APP下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 解决方法：</p><ol><li><code>&lt;li&gt;</code>标签不换行</li><li><code>&lt;li&gt;</code>标签不闭合</li><li>设置<code>&lt;ul&gt;</code>字体font-size：0,内部<code>&lt;li&gt;</code>设置font-size；</li><li>设置<code>li+li{margin-left: -3px;}</code>负边距。</li><li>css4属性中有white-space-collapsing<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="selector-class">.notice</span> <span class="selector-tag">a</span><span class="selector-pseudo">:first-child</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">'最新公告：\00a0\00a0'</span>; <span class="comment">/*\00a0空白字符*/</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#aaa</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>伪元素</code><br>与伪类针对特殊状态的元素不同的是，伪元素是对元素中的特定内容进行操作，它所操作的层次比伪类更深了一层，也因此它的动态性比伪类要低得多。实际上，设计伪元素的目的就是去选取诸如元素内容第一个字（母）、第一行，选取某些内容前面或后面这种普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素。</p><p> <code>伪类</code><br>伪类选择元素基于的是当前元素处于的状态，或者说元素当前所具有的特性，而不是元素的id、class、属性等静态的标志。由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类。</p><p>webp<br>svg<br>png<br>jpg<br><code>响应式图片</code>方式<br>js或服务器<br>srcset<br>srcset配合sizes<br>picture<br>svg  【illustrator】</p><p>picturefill库</p><p>npm<br>^1.7.4 (大中小)  大   相同<br>~1.7.4          大中 相同  </p><p><code>处理兼容性</code></p><p><code>同步测试工具</code>browser-sync<br><code>browser-sync start --server &quot;src&quot;  --file &quot;src&quot;</code></p><p>自动化构建工具 1、Grunt 2、gulp<br>静态资源打包工具 1、webpack</p><p>原型设计<br>axure<br>sketch</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;响应式网站设计&quot;&gt;&lt;a href=&quot;#响应式网站设计&quot; class=&quot;headerlink&quot; title=&quot;响应式网站设计&quot;&gt;&lt;/a&gt;响应式网站设计&lt;/h1&gt;&lt;h2 id=&quot;本文是在学习responsive-web-design时，做的笔记。&quot;&gt;&lt;a href=&quot;#本文是在学习responsive-web-design时，做的笔记。&quot; class=&quot;headerlink&quot; title=&quot;本文是在学习responsive-web-design时，做的笔记。&quot;&gt;&lt;/a&gt;本文是在学习&lt;a href=&quot;https://github.com/sivkun/responsive-web-design&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;responsive-web-design&lt;/a&gt;时，做的笔记。&lt;/h2&gt;&lt;h2 id=&quot;响应式网站设计的优点&quot;&gt;&lt;a href=&quot;#响应式网站设计的优点&quot; class=&quot;headerlink&quot; title=&quot;响应式网站设计的优点&quot;&gt;&lt;/a&gt;响应式网站设计的优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;减少工作量&lt;br&gt;  网站、设计、代码、内容都只需要一份&lt;br&gt;  多出来的工作量只是js脚本、css样式做一些改动&lt;/li&gt;
&lt;li&gt;节省时间&lt;/li&gt;
&lt;li&gt;每个设备都能得到正确的设计&lt;/li&gt;
&lt;li&gt;搜索优化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;响应式网站设计的缺点&quot;&gt;&lt;a href=&quot;#响应式网站设计的缺点&quot; class=&quot;headerlink&quot; title=&quot;响应式网站设计的缺点&quot;&gt;&lt;/a&gt;响应式网站设计的缺点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;会加载更多的样式和脚本资源&lt;/li&gt;
&lt;li&gt;设计比较难精准定位和控制&lt;/li&gt;
&lt;li&gt;老版本浏览器兼容不好&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;CSS3-媒体属性简介-略&quot;&gt;&lt;a href=&quot;#CSS3-媒体属性简介-略&quot; class=&quot;headerlink&quot; title=&quot;CSS3 媒体属性简介 略&quot;&gt;&lt;/a&gt;CSS3 媒体属性简介 略&lt;/h2&gt;&lt;h2 id=&quot;viewport视口&quot;&gt;&lt;a href=&quot;#viewport视口&quot; class=&quot;headerlink&quot; title=&quot;viewport视口&quot;&gt;&lt;/a&gt;viewport视口&lt;/h2&gt;&lt;p&gt;&lt;code&gt;布局视口（layout viewport）&lt;/code&gt;: 虚拟的视口将页面呈现出来，布局视口的宽度是不变的。&lt;br&gt;&lt;code&gt;可视视口（visual viewport）&lt;/code&gt;:  对布局视口呈现出来的页面进行放大或者缩小，在固定的设备显示器看到的网页的内容区域的内容范围或大或小。&lt;br&gt; 比方说：320px宽的显示屏，网页宽度为960px，在显示屏中显示这个网页，渲染时会按照网页960px的宽度进行渲染，然后将整个页面缩放三分之一，&lt;br&gt; 这样整个页面显示出来，此时可视视口为960px因为整个页面你都看到了，即布局视口宽度等于可视视口宽度。将页面放大，在320px的设备中，&lt;br&gt; 只会看到页面的一部分，可视视口变小。可视视口尺寸不固定，随着用户缩放页面改变。 （默认宽度是屏幕的宽度）&lt;br&gt; 像是拿着放大镜看书，书是布局视口，通过放大镜看到的是可视视口，随着放大镜离书的远近，可视视口改变，左右移动放大镜，可看到整个书的内容。&lt;br&gt; 这样的话用户浏览网页时，需要不断的滑动、放大页面，很不方便。&lt;br&gt;&lt;code&gt;理想视口（ideal viewport）&lt;/code&gt;：布局视口在一个设备上的最佳尺寸。理想视口下的页面便于浏览器浏览阅读。&lt;br&gt;  理想视口就是为了构架手机浏览器优化的页面而添加的&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://fsysfq.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HTML" scheme="http://fsysfq.top/tags/HTML/"/>
    
      <category term="CSS" scheme="http://fsysfq.top/tags/CSS/"/>
    
      <category term="Markdown" scheme="http://fsysfq.top/tags/Markdown/"/>
    
  </entry>
  
</feed>
